"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const t = require("@babel/types");
const babel = require("@babel/core");
const _generate = require("@babel/generator");
const template = require("@babel/template");
const babelDeadCodeElimination = require("babel-dead-code-elimination");
const constants = require("./constants.cjs");
const ast = require("./ast.cjs");
function _interopNamespaceDefault(e) {
  const n = Object.create(null, { [Symbol.toStringTag]: { value: "Module" } });
  if (e) {
    for (const k in e) {
      if (k !== "default") {
        const d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: () => e[k]
        });
      }
    }
  }
  n.default = e;
  return Object.freeze(n);
}
const t__namespace = /* @__PURE__ */ _interopNamespaceDefault(t);
const template__namespace = /* @__PURE__ */ _interopNamespaceDefault(template);
let generate = _generate["default"];
if (!generate) {
  generate = _generate;
}
function compileCodeSplitReferenceRoute(opts) {
  const ast$1 = ast.parseAst(opts);
  if (!ast$1) {
    throw new Error(
      `Failed to compile ast for compileCodeSplitReferenceRoute() for the file: ${opts.filename}`
    );
  }
  babel.traverse(ast$1, {
    Program: {
      enter(programPath, programState) {
        const state = programState;
        const splitUrl = `${constants.splitPrefix}:${opts.filename}?${constants.splitPrefix}`;
        let existingCompImportPath = null;
        let existingLoaderImportPath = null;
        programPath.traverse(
          {
            CallExpression: (path) => {
              if (!t__namespace.isIdentifier(path.node.callee)) {
                return;
              }
              if (!(path.node.callee.name === "createRoute" || path.node.callee.name === "createFileRoute")) {
                return;
              }
              if (t__namespace.isCallExpression(path.parentPath.node)) {
                const options = resolveIdentifier(
                  path,
                  path.parentPath.node.arguments[0]
                );
                let found = false;
                const hasImportedOrDefinedIdentifier = (name) => {
                  return programPath.scope.hasBinding(name);
                };
                if (t__namespace.isObjectExpression(options)) {
                  options.properties.forEach((prop) => {
                    if (t__namespace.isObjectProperty(prop)) {
                      if (t__namespace.isIdentifier(prop.key)) {
                        if (prop.key.name === "component") {
                          const value = prop.value;
                          if (t__namespace.isIdentifier(value)) {
                            existingCompImportPath = getImportSpecifierAndPathFromLocalName(
                              programPath,
                              value.name
                            ).path;
                            removeIdentifierLiteral(path, value);
                          }
                          if (!hasImportedOrDefinedIdentifier(
                            "lazyRouteComponent"
                          )) {
                            programPath.unshiftContainer("body", [
                              template__namespace.statement(
                                `import { lazyRouteComponent } from '@tanstack/react-router'`
                              )()
                            ]);
                          }
                          if (!hasImportedOrDefinedIdentifier(
                            "$$splitComponentImporter"
                          )) {
                            programPath.unshiftContainer("body", [
                              template__namespace.statement(
                                `const $$splitComponentImporter = () => import('${splitUrl}')`
                              )()
                            ]);
                          }
                          prop.value = template__namespace.expression(
                            `lazyRouteComponent($$splitComponentImporter, 'component')`
                          )();
                          programPath.pushContainer("body", [
                            template__namespace.statement(
                              `function DummyComponent() { return null }`
                            )()
                          ]);
                          found = true;
                        } else if (prop.key.name === "loader") {
                          const value = prop.value;
                          if (t__namespace.isIdentifier(value)) {
                            existingLoaderImportPath = getImportSpecifierAndPathFromLocalName(
                              programPath,
                              value.name
                            ).path;
                            removeIdentifierLiteral(path, value);
                          }
                          if (!hasImportedOrDefinedIdentifier("lazyFn")) {
                            programPath.unshiftContainer("body", [
                              template__namespace.smart(
                                `import { lazyFn } from '@tanstack/react-router'`
                              )()
                            ]);
                          }
                          if (!hasImportedOrDefinedIdentifier(
                            "$$splitLoaderImporter"
                          )) {
                            programPath.unshiftContainer("body", [
                              template__namespace.statement(
                                `const $$splitLoaderImporter = () => import('${splitUrl}')`
                              )()
                            ]);
                          }
                          prop.value = template__namespace.expression(
                            `lazyFn($$splitLoaderImporter, 'loader')`
                          )();
                          found = true;
                        }
                      }
                    }
                    programPath.scope.crawl();
                  });
                }
                if (found) {
                  programPath.pushContainer("body", [
                    template__namespace.statement(`function TSR_Dummy_Component() {}`)()
                  ]);
                }
              }
            }
          },
          state
        );
        if (existingCompImportPath || existingLoaderImportPath) {
          programPath.traverse({
            ImportDeclaration(path) {
              if (path.node.specifiers.length > 0) return;
              if (path.node.source.value === existingCompImportPath || path.node.source.value === existingLoaderImportPath) {
                path.remove();
              }
            }
          });
        }
      }
    }
  });
  babelDeadCodeElimination.deadCodeElimination(ast$1);
  return generate(ast$1, {
    sourceMaps: true,
    minified: process.env.NODE_ENV === "production"
  });
}
const splitNodeTypes = ["component", "loader"];
function compileCodeSplitVirtualRoute(opts) {
  const ast$1 = ast.parseAst(opts);
  if (!ast$1) {
    throw new Error(
      `Failed to compile ast for compileCodeSplitVirtualRoute() for the file: ${opts.filename}`
    );
  }
  babel.traverse(ast$1, {
    Program: {
      enter(programPath, programState) {
        const state = programState;
        const splitNodesByType = {
          component: void 0,
          loader: void 0
        };
        programPath.traverse(
          {
            CallExpression: (path) => {
              if (!t__namespace.isIdentifier(path.node.callee)) {
                return;
              }
              if (!(path.node.callee.name === "createRoute" || path.node.callee.name === "createFileRoute")) {
                return;
              }
              if (t__namespace.isCallExpression(path.parentPath.node)) {
                const options = resolveIdentifier(
                  path,
                  path.parentPath.node.arguments[0]
                );
                if (t__namespace.isObjectExpression(options)) {
                  options.properties.forEach((prop) => {
                    if (t__namespace.isObjectProperty(prop)) {
                      splitNodeTypes.forEach((type) => {
                        if (t__namespace.isIdentifier(prop.key)) {
                          if (prop.key.name === type) {
                            splitNodesByType[type] = prop.value;
                          }
                        }
                      });
                    }
                  });
                  options.properties = [];
                }
              }
            }
          },
          state
        );
        splitNodeTypes.forEach((splitType) => {
          let splitNode = splitNodesByType[splitType];
          if (!splitNode) {
            return;
          }
          while (t__namespace.isIdentifier(splitNode)) {
            const binding = programPath.scope.getBinding(splitNode.name);
            splitNode = binding == null ? void 0 : binding.path.node;
          }
          if (splitNode) {
            if (t__namespace.isFunctionDeclaration(splitNode)) {
              programPath.pushContainer(
                "body",
                t__namespace.variableDeclaration("const", [
                  t__namespace.variableDeclarator(
                    t__namespace.identifier(splitType),
                    t__namespace.functionExpression(
                      splitNode.id || null,
                      // Anonymize the function expression
                      splitNode.params,
                      splitNode.body,
                      splitNode.generator,
                      splitNode.async
                    )
                  )
                ])
              );
            } else if (t__namespace.isFunctionExpression(splitNode) || t__namespace.isArrowFunctionExpression(splitNode)) {
              programPath.pushContainer(
                "body",
                t__namespace.variableDeclaration("const", [
                  t__namespace.variableDeclarator(
                    t__namespace.identifier(splitType),
                    splitNode
                  )
                ])
              );
            } else if (t__namespace.isImportSpecifier(splitNode) || t__namespace.isImportDefaultSpecifier(splitNode)) {
              programPath.pushContainer(
                "body",
                t__namespace.variableDeclaration("const", [
                  t__namespace.variableDeclarator(
                    t__namespace.identifier(splitType),
                    splitNode.local
                  )
                ])
              );
            } else if (t__namespace.isCallExpression(splitNode)) {
              const outputSplitNodeCode = generate(splitNode).code;
              const splitNodeAst = babel.parse(outputSplitNodeCode);
              if (!splitNodeAst) {
                throw new Error(
                  `Failed to parse the generated code for "${splitType}" in the node type "${splitNode.type}"`
                );
              }
              const statement = splitNodeAst.program.body[0];
              if (!statement) {
                throw new Error(
                  `Failed to parse the generated code for "${splitType}" in the node type "${splitNode.type}" as no statement was found in the program body`
                );
              }
              if (t__namespace.isExpressionStatement(statement)) {
                const expression = statement.expression;
                programPath.pushContainer(
                  "body",
                  t__namespace.variableDeclaration("const", [
                    t__namespace.variableDeclarator(t__namespace.identifier(splitType), expression)
                  ])
                );
              } else {
                throw new Error(
                  `Unexpected expression type encounter for "${splitType}" in the node type "${splitNode.type}"`
                );
              }
            } else {
              console.info("Unexpected splitNode type:", splitNode);
              throw new Error(`Unexpected splitNode type ☝️: ${splitNode.type}`);
            }
          }
          programPath.node.body = programPath.node.body.filter((node) => {
            return node !== splitNode;
          });
          programPath.pushContainer("body", [
            t__namespace.exportNamedDeclaration(null, [
              t__namespace.exportSpecifier(
                t__namespace.identifier(splitType),
                t__namespace.identifier(splitType)
              )
            ])
          ]);
        });
        programPath.traverse({
          ExportNamedDeclaration(path) {
            if (path.node.declaration) {
              if (t__namespace.isVariableDeclaration(path.node.declaration)) {
                path.replaceWith(
                  t__namespace.importDeclaration(
                    path.node.declaration.declarations.map(
                      (decl) => t__namespace.importSpecifier(
                        t__namespace.identifier(decl.id.name),
                        t__namespace.identifier(decl.id.name)
                      )
                    ),
                    t__namespace.stringLiteral(
                      opts.filename.split(`?${constants.splitPrefix}`)[0]
                    )
                  )
                );
              }
            }
          }
        });
      }
    }
  });
  babelDeadCodeElimination.deadCodeElimination(ast$1);
  return generate(ast$1, {
    sourceMaps: true,
    minified: process.env.NODE_ENV === "production"
  });
}
function getImportSpecifierAndPathFromLocalName(programPath, name) {
  let specifier = null;
  let path = null;
  programPath.traverse({
    ImportDeclaration(importPath) {
      const found = importPath.node.specifiers.find(
        (targetSpecifier) => targetSpecifier.local.name === name
      );
      if (found) {
        specifier = found;
        path = importPath.node.source.value;
      }
    }
  });
  return { specifier, path };
}
function resolveIdentifier(path, node) {
  if (t__namespace.isIdentifier(node)) {
    const binding = path.scope.getBinding(node.name);
    if (binding) {
      const declarator = binding.path.node;
      if (t__namespace.isObjectExpression(declarator.init)) {
        return declarator.init;
      } else if (t__namespace.isFunctionDeclaration(declarator.init)) {
        return declarator.init;
      }
    }
    return void 0;
  }
  return node;
}
function removeIdentifierLiteral(path, node) {
  if (t__namespace.isIdentifier(node)) {
    const binding = path.scope.getBinding(node.name);
    if (binding) {
      binding.path.remove();
    }
  }
}
exports.compileCodeSplitReferenceRoute = compileCodeSplitReferenceRoute;
exports.compileCodeSplitVirtualRoute = compileCodeSplitVirtualRoute;
//# sourceMappingURL=compilers.cjs.map
