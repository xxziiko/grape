{"version":3,"file":"compilers.js","sources":["../../src/compilers.ts"],"sourcesContent":["import * as t from '@babel/types'\nimport babel from '@babel/core'\nimport _generate from '@babel/generator'\nimport * as template from '@babel/template'\nimport { deadCodeElimination } from 'babel-dead-code-elimination'\n\nimport { splitPrefix } from './constants'\nimport { parseAst } from './ast'\nimport type { ParseAstOptions } from './ast'\n\n// Babel is a CJS package and uses `default` as named binding (`exports.default =`).\n// https://github.com/babel/babel/issues/15269.\nlet generate = (_generate as any)['default'] as typeof _generate\n\n// eslint-disable-next-line ts/no-unnecessary-condition\nif (!generate) {\n  generate = _generate\n}\n\ntype SplitModulesById = Record<\n  string,\n  { id: string; node: t.FunctionExpression }\n>\n\ninterface State {\n  filename: string\n  opts: {\n    minify: boolean\n    root: string\n  }\n  imported: Record<string, boolean>\n  refs: Set<any>\n  serverIndex: number\n  splitIndex: number\n  splitModulesById: SplitModulesById\n}\n\nexport function compileCodeSplitReferenceRoute(opts: ParseAstOptions) {\n  const ast = parseAst(opts)\n\n  if (!ast) {\n    throw new Error(\n      `Failed to compile ast for compileCodeSplitReferenceRoute() for the file: ${opts.filename}`,\n    )\n  }\n\n  babel.traverse(ast, {\n    Program: {\n      enter(programPath, programState) {\n        const state = programState as unknown as State\n\n        const splitUrl = `${splitPrefix}:${opts.filename}?${splitPrefix}`\n\n        /**\n         * If the component for the route is being imported from\n         * another file, this is to track the path to that file\n         * the path itself doesn't matter, we just need to keep\n         * track of it so that we can remove it from the imports\n         * list if it's not being used like:\n         *\n         * `import '../shared/imported'`\n         */\n        let existingCompImportPath: string | null = null\n        let existingLoaderImportPath: string | null = null\n\n        programPath.traverse(\n          {\n            CallExpression: (path) => {\n              if (!t.isIdentifier(path.node.callee)) {\n                return\n              }\n\n              if (\n                !(\n                  path.node.callee.name === 'createRoute' ||\n                  path.node.callee.name === 'createFileRoute'\n                )\n              ) {\n                return\n              }\n\n              if (t.isCallExpression(path.parentPath.node)) {\n                const options = resolveIdentifier(\n                  path,\n                  path.parentPath.node.arguments[0],\n                )\n\n                let found = false\n\n                const hasImportedOrDefinedIdentifier = (name: string) => {\n                  return programPath.scope.hasBinding(name)\n                }\n\n                if (t.isObjectExpression(options)) {\n                  options.properties.forEach((prop) => {\n                    if (t.isObjectProperty(prop)) {\n                      if (t.isIdentifier(prop.key)) {\n                        if (prop.key.name === 'component') {\n                          const value = prop.value\n\n                          if (t.isIdentifier(value)) {\n                            existingCompImportPath =\n                              getImportSpecifierAndPathFromLocalName(\n                                programPath,\n                                value.name,\n                              ).path\n\n                            removeIdentifierLiteral(path, value)\n                          }\n\n                          // Prepend the import statement to the program along with the importer function\n                          // Check to see if lazyRouteComponent is already imported before attempting\n                          // to import it again\n\n                          if (\n                            !hasImportedOrDefinedIdentifier(\n                              'lazyRouteComponent',\n                            )\n                          ) {\n                            programPath.unshiftContainer('body', [\n                              template.statement(\n                                `import { lazyRouteComponent } from '@tanstack/react-router'`,\n                              )(),\n                            ])\n                          }\n\n                          if (\n                            !hasImportedOrDefinedIdentifier(\n                              '$$splitComponentImporter',\n                            )\n                          ) {\n                            programPath.unshiftContainer('body', [\n                              template.statement(\n                                `const $$splitComponentImporter = () => import('${splitUrl}')`,\n                              )(),\n                            ])\n                          }\n\n                          prop.value = template.expression(\n                            `lazyRouteComponent($$splitComponentImporter, 'component')`,\n                          )()\n\n                          programPath.pushContainer('body', [\n                            template.statement(\n                              `function DummyComponent() { return null }`,\n                            )(),\n                          ])\n\n                          found = true\n                        } else if (prop.key.name === 'loader') {\n                          const value = prop.value\n\n                          if (t.isIdentifier(value)) {\n                            existingLoaderImportPath =\n                              getImportSpecifierAndPathFromLocalName(\n                                programPath,\n                                value.name,\n                              ).path\n\n                            removeIdentifierLiteral(path, value)\n                          }\n\n                          // Prepend the import statement to the program along with the importer function\n\n                          if (!hasImportedOrDefinedIdentifier('lazyFn')) {\n                            programPath.unshiftContainer('body', [\n                              template.smart(\n                                `import { lazyFn } from '@tanstack/react-router'`,\n                              )() as t.Statement,\n                            ])\n                          }\n\n                          if (\n                            !hasImportedOrDefinedIdentifier(\n                              '$$splitLoaderImporter',\n                            )\n                          ) {\n                            programPath.unshiftContainer('body', [\n                              template.statement(\n                                `const $$splitLoaderImporter = () => import('${splitUrl}')`,\n                              )(),\n                            ])\n                          }\n\n                          prop.value = template.expression(\n                            `lazyFn($$splitLoaderImporter, 'loader')`,\n                          )()\n\n                          found = true\n                        }\n                      }\n                    }\n\n                    programPath.scope.crawl()\n                  })\n                }\n\n                if (found as boolean) {\n                  programPath.pushContainer('body', [\n                    template.statement(`function TSR_Dummy_Component() {}`)(),\n                  ])\n                }\n              }\n            },\n          },\n          state,\n        )\n\n        /**\n         * If the component for the route is being imported,\n         * and it's not being used, remove the import statement\n         * from the program, by checking that the import has no\n         * specifiers\n         */\n        if (\n          (existingCompImportPath as string | null) ||\n          (existingLoaderImportPath as string | null)\n        ) {\n          programPath.traverse({\n            ImportDeclaration(path) {\n              if (path.node.specifiers.length > 0) return\n              if (\n                path.node.source.value === existingCompImportPath ||\n                path.node.source.value === existingLoaderImportPath\n              ) {\n                path.remove()\n              }\n            },\n          })\n        }\n      },\n    },\n  })\n\n  deadCodeElimination(ast)\n\n  return generate(ast, {\n    sourceMaps: true,\n    minified: process.env.NODE_ENV === 'production',\n  })\n}\n\nconst splitNodeTypes = ['component', 'loader'] as const\ntype SplitNodeType = (typeof splitNodeTypes)[number]\n\nexport function compileCodeSplitVirtualRoute(opts: ParseAstOptions) {\n  const ast = parseAst(opts)\n\n  if (!ast) {\n    throw new Error(\n      `Failed to compile ast for compileCodeSplitVirtualRoute() for the file: ${opts.filename}`,\n    )\n  }\n\n  babel.traverse(ast, {\n    Program: {\n      enter(programPath, programState) {\n        const state = programState as unknown as State\n\n        const splitNodesByType: Record<SplitNodeType, t.Node | undefined> = {\n          component: undefined,\n          loader: undefined,\n        }\n\n        // Find the node\n        programPath.traverse(\n          {\n            CallExpression: (path) => {\n              if (!t.isIdentifier(path.node.callee)) {\n                return\n              }\n\n              if (\n                !(\n                  path.node.callee.name === 'createRoute' ||\n                  path.node.callee.name === 'createFileRoute'\n                )\n              ) {\n                return\n              }\n\n              if (t.isCallExpression(path.parentPath.node)) {\n                const options = resolveIdentifier(\n                  path,\n                  path.parentPath.node.arguments[0],\n                )\n\n                if (t.isObjectExpression(options)) {\n                  options.properties.forEach((prop) => {\n                    if (t.isObjectProperty(prop)) {\n                      splitNodeTypes.forEach((type) => {\n                        if (t.isIdentifier(prop.key)) {\n                          if (prop.key.name === type) {\n                            splitNodesByType[type] = prop.value\n                          }\n                        }\n                      })\n                    }\n                  })\n\n                  // Remove all of the options\n                  options.properties = []\n                }\n              }\n            },\n          },\n          state,\n        )\n\n        splitNodeTypes.forEach((splitType) => {\n          let splitNode = splitNodesByType[splitType]\n\n          if (!splitNode) {\n            return\n          }\n\n          while (t.isIdentifier(splitNode)) {\n            const binding = programPath.scope.getBinding(splitNode.name)\n            splitNode = binding?.path.node\n          }\n\n          // Add the node to the program\n          if (splitNode) {\n            if (t.isFunctionDeclaration(splitNode)) {\n              programPath.pushContainer(\n                'body',\n                t.variableDeclaration('const', [\n                  t.variableDeclarator(\n                    t.identifier(splitType),\n                    t.functionExpression(\n                      splitNode.id || null, // Anonymize the function expression\n                      splitNode.params,\n                      splitNode.body,\n                      splitNode.generator,\n                      splitNode.async,\n                    ),\n                  ),\n                ]),\n              )\n            } else if (\n              t.isFunctionExpression(splitNode) ||\n              t.isArrowFunctionExpression(splitNode)\n            ) {\n              programPath.pushContainer(\n                'body',\n                t.variableDeclaration('const', [\n                  t.variableDeclarator(\n                    t.identifier(splitType),\n                    splitNode as any,\n                  ),\n                ]),\n              )\n            } else if (\n              t.isImportSpecifier(splitNode) ||\n              t.isImportDefaultSpecifier(splitNode)\n            ) {\n              programPath.pushContainer(\n                'body',\n                t.variableDeclaration('const', [\n                  t.variableDeclarator(\n                    t.identifier(splitType),\n                    splitNode.local,\n                  ),\n                ]),\n              )\n            } else if (t.isCallExpression(splitNode)) {\n              const outputSplitNodeCode = generate(splitNode).code\n              const splitNodeAst = babel.parse(outputSplitNodeCode)\n\n              if (!splitNodeAst) {\n                throw new Error(\n                  `Failed to parse the generated code for \"${splitType}\" in the node type \"${splitNode.type}\"`,\n                )\n              }\n\n              const statement = splitNodeAst.program.body[0]\n\n              if (!statement) {\n                throw new Error(\n                  `Failed to parse the generated code for \"${splitType}\" in the node type \"${splitNode.type}\" as no statement was found in the program body`,\n                )\n              }\n\n              if (t.isExpressionStatement(statement)) {\n                const expression = statement.expression\n                programPath.pushContainer(\n                  'body',\n                  t.variableDeclaration('const', [\n                    t.variableDeclarator(t.identifier(splitType), expression),\n                  ]),\n                )\n              } else {\n                throw new Error(\n                  `Unexpected expression type encounter for \"${splitType}\" in the node type \"${splitNode.type}\"`,\n                )\n              }\n            } else {\n              console.info('Unexpected splitNode type:', splitNode)\n              throw new Error(`Unexpected splitNode type ☝️: ${splitNode.type}`)\n            }\n          }\n\n          // If the splitNode exists at the top of the program\n          // then we need to remove that copy\n          programPath.node.body = programPath.node.body.filter((node) => {\n            return node !== splitNode\n          })\n\n          // Export the node\n          programPath.pushContainer('body', [\n            t.exportNamedDeclaration(null, [\n              t.exportSpecifier(\n                t.identifier(splitType),\n                t.identifier(splitType),\n              ),\n            ]),\n          ])\n        })\n\n        // convert exports to imports from the original file\n        programPath.traverse({\n          ExportNamedDeclaration(path) {\n            // e.g. export const x = 1 or export { x }\n            // becomes\n            // import { x } from '${opts.id}'\n\n            if (path.node.declaration) {\n              if (t.isVariableDeclaration(path.node.declaration)) {\n                path.replaceWith(\n                  t.importDeclaration(\n                    path.node.declaration.declarations.map((decl) =>\n                      t.importSpecifier(\n                        t.identifier((decl.id as any).name),\n                        t.identifier((decl.id as any).name),\n                      ),\n                    ),\n                    t.stringLiteral(\n                      opts.filename.split(`?${splitPrefix}`)[0] as string,\n                    ),\n                  ),\n                )\n              }\n            }\n          },\n        })\n      },\n    },\n  })\n\n  deadCodeElimination(ast)\n\n  return generate(ast, {\n    sourceMaps: true,\n    minified: process.env.NODE_ENV === 'production',\n  })\n}\n\nfunction getImportSpecifierAndPathFromLocalName(\n  programPath: babel.NodePath<t.Program>,\n  name: string,\n): {\n  specifier:\n    | t.ImportSpecifier\n    | t.ImportDefaultSpecifier\n    | t.ImportNamespaceSpecifier\n    | null\n  path: string | null\n} {\n  let specifier:\n    | t.ImportSpecifier\n    | t.ImportDefaultSpecifier\n    | t.ImportNamespaceSpecifier\n    | null = null\n  let path: string | null = null\n\n  programPath.traverse({\n    ImportDeclaration(importPath) {\n      const found = importPath.node.specifiers.find(\n        (targetSpecifier) => targetSpecifier.local.name === name,\n      )\n      if (found) {\n        specifier = found\n        path = importPath.node.source.value\n      }\n    },\n  })\n\n  return { specifier, path }\n}\n\n// Reusable function to get literal value or resolve variable to literal\nfunction resolveIdentifier(path: any, node: any) {\n  if (t.isIdentifier(node)) {\n    const binding = path.scope.getBinding(node.name)\n    if (\n      binding\n      // && binding.kind === 'const'\n    ) {\n      const declarator = binding.path.node\n      if (t.isObjectExpression(declarator.init)) {\n        return declarator.init\n      } else if (t.isFunctionDeclaration(declarator.init)) {\n        return declarator.init\n      }\n    }\n    return undefined\n  }\n\n  return node\n}\n\nfunction removeIdentifierLiteral(path: any, node: any) {\n  if (t.isIdentifier(node)) {\n    const binding = path.scope.getBinding(node.name)\n    if (binding) {\n      binding.path.remove()\n    }\n  }\n}\n"],"names":["babel"],"mappings":"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"}