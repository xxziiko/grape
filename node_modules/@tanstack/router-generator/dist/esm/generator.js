import path from "node:path";
import * as fs from "node:fs";
import * as fsp from "node:fs/promises";
import * as prettier from "prettier";
import { logging, trimPathLeft, cleanPath } from "./utils.js";
let latestTask = 0;
const rootPathId = "__root";
const routeGroupPatternRegex = /\(.+\)/g;
const possiblyNestedRouteGroupPatternRegex = /\([^/]+\)\/?/g;
const disallowedRouteGroupConfiguration = /\(([^)]+)\).(ts|js|tsx|jsx)/;
async function getRouteNodes(config) {
  const { routeFilePrefix, routeFileIgnorePrefix, routeFileIgnorePattern } = config;
  const logger = logging({ disabled: config.disableLogging });
  const routeFileIgnoreRegExp = new RegExp(routeFileIgnorePattern ?? "", "g");
  const routeNodes = [];
  async function recurse(dir) {
    const fullDir = path.resolve(config.routesDirectory, dir);
    let dirList = await fsp.readdir(fullDir, { withFileTypes: true });
    dirList = dirList.filter((d) => {
      if (d.name.startsWith(".") || routeFileIgnorePrefix && d.name.startsWith(routeFileIgnorePrefix)) {
        return false;
      }
      if (routeFilePrefix) {
        return d.name.startsWith(routeFilePrefix);
      }
      if (routeFileIgnorePattern) {
        return !d.name.match(routeFileIgnoreRegExp);
      }
      return true;
    });
    await Promise.all(
      dirList.map(async (dirent) => {
        var _a;
        const fullPath = path.join(fullDir, dirent.name);
        const relativePath = path.join(dir, dirent.name);
        if (dirent.isDirectory()) {
          await recurse(relativePath);
        } else if (fullPath.match(/\.(tsx|ts|jsx|js)$/)) {
          const filePath = replaceBackslash(path.join(dir, dirent.name));
          const filePathNoExt = removeExt(filePath);
          let routePath = cleanPath(`/${filePathNoExt.split(".").join("/")}`) || "";
          if (routeFilePrefix) {
            routePath = routePath.replaceAll(routeFilePrefix, "");
          }
          if (disallowedRouteGroupConfiguration.test(dirent.name)) {
            const errorMessage = `A route configuration for a route group was found at \`${filePath}\`. This is not supported. Did you mean to use a layout/pathless route instead?`;
            logger.error(`ERROR: ${errorMessage}`);
            throw new Error(errorMessage);
          }
          const variableName = routePathToVariable(routePath);
          const isLazy = routePath.endsWith("/lazy");
          if (isLazy) {
            routePath = routePath.replace(/\/lazy$/, "");
          }
          const isRoute = routePath.endsWith("/route");
          const isComponent = routePath.endsWith("/component");
          const isErrorComponent = routePath.endsWith("/errorComponent");
          const isPendingComponent = routePath.endsWith("/pendingComponent");
          const isLoader = routePath.endsWith("/loader");
          const segments = routePath.split("/");
          const isLayout = ((_a = segments[segments.length - 1]) == null ? void 0 : _a.startsWith("_")) || false;
          [
            [isComponent, "component"],
            [isErrorComponent, "errorComponent"],
            [isPendingComponent, "pendingComponent"],
            [isLoader, "loader"]
          ].forEach(([isType, type]) => {
            if (isType) {
              logger.warn(
                `WARNING: The \`.${type}.tsx\` suffix used for the ${filePath} file is deprecated. Use the new \`.lazy.tsx\` suffix instead.`
              );
            }
          });
          routePath = routePath.replace(
            /\/(component|errorComponent|pendingComponent|loader|route|lazy)$/,
            ""
          );
          if (routePath === "index") {
            routePath = "/";
          }
          routePath = routePath.replace(/\/index$/, "/") || "/";
          routeNodes.push({
            filePath,
            fullPath,
            routePath,
            variableName,
            isRoute,
            isComponent,
            isErrorComponent,
            isPendingComponent,
            isLoader,
            isLazy,
            isLayout
          });
        }
      })
    );
    return routeNodes;
  }
  await recurse("./");
  return routeNodes;
}
let isFirst = false;
let skipMessage = false;
async function generator(config) {
  const logger = logging({ disabled: config.disableLogging });
  logger.log("");
  if (!isFirst) {
    logger.log("♻️  Generating routes...");
    isFirst = true;
  } else if (skipMessage) {
    skipMessage = false;
  } else {
    logger.log("♻️  Regenerating routes...");
  }
  const taskId = latestTask + 1;
  latestTask = taskId;
  const checkLatest = () => {
    if (latestTask !== taskId) {
      skipMessage = true;
      return false;
    }
    return true;
  };
  const start = Date.now();
  const routePathIdPrefix = config.routeFilePrefix ?? "";
  const beforeRouteNodes = await getRouteNodes(config);
  const rootRouteNode = beforeRouteNodes.find(
    (d) => d.routePath === `/${rootPathId}`
  );
  const preRouteNodes = multiSortBy(beforeRouteNodes, [
    (d) => d.routePath === "/" ? -1 : 1,
    (d) => {
      var _a;
      return (_a = d.routePath) == null ? void 0 : _a.split("/").length;
    },
    (d) => d.filePath.match(/[./]index[.]/) ? 1 : -1,
    (d) => d.filePath.match(
      /[./](component|errorComponent|pendingComponent|loader|lazy)[.]/
    ) ? 1 : -1,
    (d) => d.filePath.match(/[./]route[.]/) ? -1 : 1,
    (d) => {
      var _a;
      return ((_a = d.routePath) == null ? void 0 : _a.endsWith("/")) ? -1 : 1;
    },
    (d) => d.routePath
  ]).filter((d) => ![`/${rootPathId}`].includes(d.routePath || ""));
  const routeTree = [];
  const routePiecesByPath = {};
  const routeNodes = [];
  const handleNode = async (node) => {
    var _a, _b;
    let parentRoute = hasParentRoute(routeNodes, node, node.routePath);
    if ((parentRoute == null ? void 0 : parentRoute.isVirtualParentRoute) && ((_a = parentRoute.children) == null ? void 0 : _a.length)) {
      const possibleParentRoute = hasParentRoute(
        parentRoute.children,
        node,
        node.routePath
      );
      if (possibleParentRoute) {
        parentRoute = possibleParentRoute;
      }
    }
    if (parentRoute) node.parent = parentRoute;
    node.path = determineNodePath(node);
    const trimmedPath = trimPathLeft(node.path ?? "");
    const split = trimmedPath.split("/");
    const first = split[0] ?? trimmedPath;
    const lastRouteSegment = split[split.length - 1] ?? trimmedPath;
    node.isNonPath = lastRouteSegment.startsWith("_") || routeGroupPatternRegex.test(lastRouteSegment);
    node.isNonLayout = first.endsWith("_");
    node.cleanedPath = removeGroups(
      removeUnderscores(removeLayoutSegments(node.path)) ?? ""
    );
    if (!node.isVirtualParentRoute && !node.isVirtual) {
      const routeCode = fs.readFileSync(node.fullPath, "utf-8");
      const escapedRoutePath = removeTrailingUnderscores(
        ((_b = node.routePath) == null ? void 0 : _b.replaceAll("$", "$$")) ?? ""
      );
      let replaced = routeCode;
      if (!routeCode) {
        if (node.isLazy) {
          replaced = [
            `import { createLazyFileRoute } from '@tanstack/react-router'`,
            `export const Route = createLazyFileRoute('${escapedRoutePath}')({
  component: () => <div>Hello ${escapedRoutePath}!</div>
})`
          ].join("\n\n");
        } else if (node.isRoute || !node.isComponent && !node.isErrorComponent && !node.isPendingComponent && !node.isLoader) {
          replaced = [
            `import { createFileRoute } from '@tanstack/react-router'`,
            `export const Route = createFileRoute('${escapedRoutePath}')({
  component: () => <div>Hello ${escapedRoutePath}!</div>
})`
          ].join("\n\n");
        }
      } else {
        replaced = routeCode.replace(
          /(FileRoute\(\s*['"])([^\s]*)(['"],?\s*\))/g,
          (match, p1, p2, p3) => `${p1}${escapedRoutePath}${p3}`
        ).replace(
          /(import\s*\{.*)(create(Lazy)?FileRoute)(.*\}\s*from\s*['"]@tanstack\/react-router['"])/gs,
          (match, p1, p2, p3, p4) => `${p1}${node.isLazy ? "createLazyFileRoute" : "createFileRoute"}${p4}`
        ).replace(
          /create(Lazy)?FileRoute(\(\s*['"])([^\s]*)(['"],?\s*\))/g,
          (match, p1, p2, p3, p4) => `${node.isLazy ? "createLazyFileRoute" : "createFileRoute"}${p2}${escapedRoutePath}${p4}`
        );
      }
      if (replaced !== routeCode) {
        logger.log(`🟡 Updating ${node.fullPath}`);
        await fsp.writeFile(node.fullPath, replaced);
      }
    }
    if (!node.isVirtual && (node.isLoader || node.isComponent || node.isErrorComponent || node.isPendingComponent || node.isLazy)) {
      routePiecesByPath[node.routePath] = routePiecesByPath[node.routePath] || {};
      routePiecesByPath[node.routePath][node.isLazy ? "lazy" : node.isLoader ? "loader" : node.isErrorComponent ? "errorComponent" : node.isPendingComponent ? "pendingComponent" : "component"] = node;
      const anchorRoute = routeNodes.find((d) => d.routePath === node.routePath);
      if (!anchorRoute) {
        await handleNode({
          ...node,
          isVirtual: true,
          isLazy: false,
          isLoader: false,
          isComponent: false,
          isErrorComponent: false,
          isPendingComponent: false
        });
      }
      return;
    }
    const cleanedPathIsEmpty = (node.cleanedPath || "").length === 0;
    const nonPathRoute = node.isRoute && node.isNonPath;
    node.isVirtualParentRequired = node.isLayout || nonPathRoute ? !cleanedPathIsEmpty : false;
    if (!node.isVirtual && node.isVirtualParentRequired) {
      const parentRoutePath = removeLastSegmentFromPath(node.routePath) || "/";
      const parentVariableName = routePathToVariable(parentRoutePath);
      const anchorRoute = routeNodes.find(
        (d) => d.routePath === parentRoutePath
      );
      if (!anchorRoute) {
        const parentNode = {
          ...node,
          path: removeLastSegmentFromPath(node.path) || "/",
          filePath: removeLastSegmentFromPath(node.filePath) || "/",
          fullPath: removeLastSegmentFromPath(node.fullPath) || "/",
          routePath: parentRoutePath,
          variableName: parentVariableName,
          isVirtual: true,
          isLayout: false,
          isVirtualParentRoute: true,
          isVirtualParentRequired: false
        };
        parentNode.children = parentNode.children ?? [];
        parentNode.children.push(node);
        node.parent = parentNode;
        if (node.isLayout) {
          node.path = determineNodePath(node);
        }
        await handleNode(parentNode);
      } else {
        anchorRoute.children = anchorRoute.children ?? [];
        anchorRoute.children.push(node);
        node.parent = anchorRoute;
      }
    }
    if (node.parent) {
      if (!node.isVirtualParentRequired) {
        node.parent.children = node.parent.children ?? [];
        node.parent.children.push(node);
      }
    } else {
      routeTree.push(node);
    }
    routeNodes.push(node);
  };
  for (const node of preRouteNodes) {
    await handleNode(node);
  }
  function buildRouteConfig(nodes, depth = 1) {
    const children = nodes.map((node) => {
      var _a, _b;
      if (node.isRoot) {
        return;
      }
      if (node.isLayout && !((_a = node.children) == null ? void 0 : _a.length)) {
        return;
      }
      const route = `${node.variableName}Route`;
      if ((_b = node.children) == null ? void 0 : _b.length) {
        const childConfigs = buildRouteConfig(node.children, depth + 1);
        return `${route}: ${route}.addChildren({${spaces(depth * 4)}${childConfigs}})`;
      }
      return route;
    });
    return children.filter(Boolean).join(`,`);
  }
  const routeConfigChildrenText = buildRouteConfig(routeTree);
  const sortedRouteNodes = multiSortBy(routeNodes, [
    (d) => {
      var _a;
      return ((_a = d.routePath) == null ? void 0 : _a.includes(`/${rootPathId}`)) ? -1 : 1;
    },
    (d) => {
      var _a;
      return (_a = d.routePath) == null ? void 0 : _a.split("/").length;
    },
    (d) => {
      var _a;
      return ((_a = d.routePath) == null ? void 0 : _a.endsWith("index'")) ? -1 : 1;
    },
    (d) => d
  ]);
  const imports = Object.entries({
    createFileRoute: sortedRouteNodes.some((d) => d.isVirtual),
    lazyFn: sortedRouteNodes.some(
      (node) => {
        var _a;
        return (_a = routePiecesByPath[node.routePath]) == null ? void 0 : _a.loader;
      }
    ),
    lazyRouteComponent: sortedRouteNodes.some(
      (node) => {
        var _a, _b, _c;
        return ((_a = routePiecesByPath[node.routePath]) == null ? void 0 : _a.component) || ((_b = routePiecesByPath[node.routePath]) == null ? void 0 : _b.errorComponent) || ((_c = routePiecesByPath[node.routePath]) == null ? void 0 : _c.pendingComponent);
      }
    )
  }).filter((d) => d[1]).map((d) => d[0]);
  const virtualRouteNodes = sortedRouteNodes.filter((d) => d.isVirtual);
  const rootPathIdExtension = config.addExtensions && rootRouteNode ? path.extname(rootRouteNode.filePath) : "";
  const routeImports = [
    ...config.routeTreeFileHeader,
    "// This file is auto-generated by TanStack Router",
    imports.length ? `import { ${imports.join(", ")} } from '@tanstack/react-router'
` : "",
    "// Import Routes",
    [
      `import { Route as rootRoute } from './${replaceBackslash(
        path.relative(
          path.dirname(config.generatedRouteTree),
          path.resolve(
            config.routesDirectory,
            `${routePathIdPrefix}${rootPathId}${rootPathIdExtension}`
          )
        )
      )}'`,
      ...sortedRouteNodes.filter((d) => !d.isVirtual).map((node) => {
        return `import { Route as ${node.variableName}Import } from './${replaceBackslash(
          removeExt(
            path.relative(
              path.dirname(config.generatedRouteTree),
              path.resolve(config.routesDirectory, node.filePath)
            ),
            config.addExtensions
          )
        )}'`;
      })
    ].join("\n"),
    virtualRouteNodes.length ? "// Create Virtual Routes" : "",
    virtualRouteNodes.map((node) => {
      return `const ${node.variableName}Import = createFileRoute('${removeTrailingUnderscores(
        node.routePath
      )}')()`;
    }).join("\n"),
    "// Create/Update Routes",
    sortedRouteNodes.map((node) => {
      var _a, _b, _c, _d, _e, _f;
      const loaderNode = (_a = routePiecesByPath[node.routePath]) == null ? void 0 : _a.loader;
      const componentNode = (_b = routePiecesByPath[node.routePath]) == null ? void 0 : _b.component;
      const errorComponentNode = (_c = routePiecesByPath[node.routePath]) == null ? void 0 : _c.errorComponent;
      const pendingComponentNode = (_d = routePiecesByPath[node.routePath]) == null ? void 0 : _d.pendingComponent;
      const lazyComponentNode = (_e = routePiecesByPath[node.routePath]) == null ? void 0 : _e.lazy;
      return [
        `const ${node.variableName}Route = ${node.variableName}Import.update({
          ${[
          node.isNonPath ? `id: '${node.path}'` : `path: '${node.cleanedPath}'`,
          `getParentRoute: () => ${((_f = node.parent) == null ? void 0 : _f.variableName) ?? "root"}Route`
        ].filter(Boolean).join(",")}
        }${config.disableTypes ? "" : "as any"})`,
        loaderNode ? `.updateLoader({ loader: lazyFn(() => import('./${replaceBackslash(
          removeExt(
            path.relative(
              path.dirname(config.generatedRouteTree),
              path.resolve(config.routesDirectory, loaderNode.filePath)
            ),
            config.addExtensions
          )
        )}'), 'loader') })` : "",
        componentNode || errorComponentNode || pendingComponentNode ? `.update({
              ${[
          ["component", componentNode],
          ["errorComponent", errorComponentNode],
          ["pendingComponent", pendingComponentNode]
        ].filter((d) => d[1]).map((d) => {
          return `${d[0]}: lazyRouteComponent(() => import('./${replaceBackslash(
            removeExt(
              path.relative(
                path.dirname(config.generatedRouteTree),
                path.resolve(config.routesDirectory, d[1].filePath)
              ),
              config.addExtensions
            )
          )}'), '${d[0]}')`;
        }).join("\n,")}
            })` : "",
        lazyComponentNode ? `.lazy(() => import('./${replaceBackslash(
          removeExt(
            path.relative(
              path.dirname(config.generatedRouteTree),
              path.resolve(
                config.routesDirectory,
                lazyComponentNode.filePath
              )
            ),
            config.addExtensions
          )
        )}').then((d) => d.Route))` : ""
      ].join("");
    }).join("\n\n"),
    ...config.disableTypes ? [] : [
      "// Populate the FileRoutesByPath interface",
      `declare module '@tanstack/react-router' {
  interface FileRoutesByPath {
    ${routeNodes.map((routeNode) => {
        var _a, _b;
        const [filePathId, routeId] = getFilePathIdAndRouteIdFromPath(
          routeNode.routePath
        );
        return `'${filePathId}': {
          id: '${routeId}'
          path: '${inferPath(routeNode)}'
          fullPath: '${inferFullPath(routeNode)}'
          preLoaderRoute: typeof ${routeNode.variableName}Import
          parentRoute: typeof ${routeNode.isVirtualParentRequired ? `${(_a = routeNode.parent) == null ? void 0 : _a.variableName}Route` : ((_b = routeNode.parent) == null ? void 0 : _b.variableName) ? `${routeNode.parent.variableName}Import` : "rootRoute"}
        }`;
      }).join("\n")}
  }
}`
    ],
    "// Create and export the route tree",
    `export const routeTree = rootRoute.addChildren({${routeConfigChildrenText}})`,
    ...config.routeTreeFileFooter
  ].filter(Boolean).join("\n\n");
  const routeManifest = JSON.stringify(
    {
      routes: {
        __root__: {
          filePath: rootRouteNode == null ? void 0 : rootRouteNode.filePath,
          children: routeTree.map(
            (d) => getFilePathIdAndRouteIdFromPath(d.routePath)[1]
          )
        },
        ...Object.fromEntries(
          routeNodes.map((d) => {
            var _a, _b;
            const [filePathId, routeId] = getFilePathIdAndRouteIdFromPath(
              d.routePath
            );
            return [
              routeId,
              {
                filePath: d.filePath,
                parent: ((_a = d.parent) == null ? void 0 : _a.routePath) ? getFilePathIdAndRouteIdFromPath(d.parent.routePath)[1] : void 0,
                children: (_b = d.children) == null ? void 0 : _b.map(
                  (childRoute) => getFilePathIdAndRouteIdFromPath(childRoute.routePath)[1]
                )
              }
            ];
          })
        )
      }
    },
    null,
    2
  );
  const routeConfigFileContent = await prettier.format(
    [
      routeImports,
      "\n",
      "/* ROUTE_MANIFEST_START",
      routeManifest,
      "ROUTE_MANIFEST_END */"
    ].join("\n"),
    {
      semi: config.semicolons,
      singleQuote: config.quoteStyle === "single",
      parser: "typescript"
    }
  );
  if (!checkLatest()) return;
  const existingRouteTreeContent = await fsp.readFile(path.resolve(config.generatedRouteTree), "utf-8").catch((err) => {
    if (err.code === "ENOENT") {
      return "";
    }
    throw err;
  });
  if (!checkLatest()) return;
  await fsp.mkdir(path.dirname(path.resolve(config.generatedRouteTree)), {
    recursive: true
  });
  if (!checkLatest()) return;
  if (existingRouteTreeContent !== routeConfigFileContent) {
    await fsp.writeFile(
      path.resolve(config.generatedRouteTree),
      routeConfigFileContent
    );
    if (!checkLatest()) return;
  }
  logger.log(
    `✅ Processed ${routeNodes.length === 1 ? "route" : "routes"} in ${Date.now() - start}ms`
  );
}
function routePathToVariable(routePath) {
  var _a;
  return ((_a = removeUnderscores(routePath)) == null ? void 0 : _a.replace(/\/\$\//g, "/splat/").replace(/\$$/g, "splat").replace(/\$/g, "").split(/[/-]/g).map((d, i) => i > 0 ? capitalize(d) : d).join("").replace(/([^a-zA-Z0-9]|[.])/gm, "").replace(/^(\d)/g, "R$1")) ?? "";
}
function removeExt(d, keepExtension = false) {
  return keepExtension ? d : d.substring(0, d.lastIndexOf(".")) || d;
}
function spaces(d) {
  return Array.from({ length: d }).map(() => " ").join("");
}
function multiSortBy(arr, accessors = [(d) => d]) {
  return arr.map((d, i) => [d, i]).sort(([a, ai], [b, bi]) => {
    for (const accessor of accessors) {
      const ao = accessor(a);
      const bo = accessor(b);
      if (typeof ao === "undefined") {
        if (typeof bo === "undefined") {
          continue;
        }
        return 1;
      }
      if (ao === bo) {
        continue;
      }
      return ao > bo ? 1 : -1;
    }
    return ai - bi;
  }).map(([d]) => d);
}
function capitalize(s) {
  if (typeof s !== "string") return "";
  return s.charAt(0).toUpperCase() + s.slice(1);
}
function removeUnderscores(s) {
  return s == null ? void 0 : s.replaceAll(/(^_|_$)/gi, "").replaceAll(/(\/_|_\/)/gi, "/");
}
function removeTrailingUnderscores(s) {
  return s == null ? void 0 : s.replaceAll(/(_$)/gi, "").replaceAll(/(_\/)/gi, "/");
}
function replaceBackslash(s) {
  return s.replaceAll(/\\/gi, "/");
}
function removeGroups(s) {
  return s.replace(possiblyNestedRouteGroupPatternRegex, "");
}
function determineNodePath(node) {
  var _a;
  return node.path = node.parent ? ((_a = node.routePath) == null ? void 0 : _a.replace(node.parent.routePath, "")) || "/" : node.routePath;
}
function removeLastSegmentFromPath(routePath = "/") {
  const segments = routePath.split("/");
  segments.pop();
  return segments.join("/");
}
function removeLayoutSegments(routePath = "/") {
  const segments = routePath.split("/");
  const newSegments = segments.filter((segment) => !segment.startsWith("_"));
  return newSegments.join("/");
}
function hasParentRoute(routes, node, routePathToCheck) {
  if (!routePathToCheck || routePathToCheck === "/") {
    return null;
  }
  const sortedNodes = multiSortBy(routes, [
    (d) => d.routePath.length * -1,
    (d) => d.variableName
  ]).filter((d) => d.routePath !== `/${rootPathId}`);
  for (const route of sortedNodes) {
    if (route.routePath === "/") continue;
    if (routePathToCheck.startsWith(`${route.routePath}/`) && route.routePath !== routePathToCheck) {
      return route;
    }
  }
  const segments = routePathToCheck.split("/");
  segments.pop();
  const parentRoutePath = segments.join("/");
  return hasParentRoute(routes, node, parentRoutePath);
}
const inferFullPath = (routeNode) => {
  const fullPath = removeGroups(
    removeUnderscores(removeLayoutSegments(routeNode.routePath)) ?? ""
  );
  return routeNode.cleanedPath === "/" ? fullPath : fullPath.replace(/\/$/, "");
};
const inferPath = (routeNode) => {
  var _a;
  return routeNode.cleanedPath === "/" ? routeNode.cleanedPath : ((_a = routeNode.cleanedPath) == null ? void 0 : _a.replace(/\/$/, "")) ?? "";
};
function getFilePathIdAndRouteIdFromPath(pathname) {
  const filePathId = removeTrailingUnderscores(pathname);
  const id = removeGroups(filePathId ?? "");
  return [filePathId, id];
}
export {
  generator,
  hasParentRoute,
  inferFullPath,
  inferPath,
  multiSortBy,
  removeExt,
  removeLastSegmentFromPath,
  rootPathId
};
//# sourceMappingURL=generator.js.map
