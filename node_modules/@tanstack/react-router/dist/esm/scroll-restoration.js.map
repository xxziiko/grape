{"version":3,"file":"scroll-restoration.js","sources":["../../src/scroll-restoration.tsx"],"sourcesContent":["import * as React from 'react'\nimport { useRouter } from './useRouter'\nimport { functionalUpdate } from './utils'\nimport type { ParsedLocation } from './location'\nimport type { NonNullableUpdater } from './utils'\n\nconst useLayoutEffect =\n  typeof window !== 'undefined' ? React.useLayoutEffect : React.useEffect\n\nconst windowKey = 'window'\nconst delimiter = '___'\n\nlet weakScrolledElements = new WeakSet<any>()\n\ntype CacheValue = Record<string, { scrollX: number; scrollY: number }>\ntype CacheState = {\n  cached: CacheValue\n  next: CacheValue\n}\n\ntype Cache = {\n  state: CacheState\n  set: (updater: NonNullableUpdater<CacheState>) => void\n}\n\nconst sessionsStorage = typeof window !== 'undefined' && window.sessionStorage\n\nconst cache: Cache = sessionsStorage\n  ? (() => {\n      const storageKey = 'tsr-scroll-restoration-v2'\n\n      const state: CacheState = JSON.parse(\n        window.sessionStorage.getItem(storageKey) || 'null',\n      ) || { cached: {}, next: {} }\n\n      return {\n        state,\n        set: (updater) => {\n          cache.state = functionalUpdate(updater, cache.state)\n          window.sessionStorage.setItem(storageKey, JSON.stringify(cache.state))\n        },\n      }\n    })()\n  : (undefined as any)\n\nexport type ScrollRestorationOptions = {\n  getKey?: (location: ParsedLocation) => string\n}\n\n/**\n * The default `getKey` function for `useScrollRestoration`.\n * It returns the `key` from the location state or the `href` of the location.\n *\n * The `location.href` is used as a fallback to support the use case where the location state is not available like the initial render.\n */\nconst defaultGetKey = (location: ParsedLocation) => {\n  return location.state.key! || location.href\n}\n\nexport function useScrollRestoration(options?: ScrollRestorationOptions) {\n  const router = useRouter()\n\n  useLayoutEffect(() => {\n    const getKey = options?.getKey || defaultGetKey\n\n    const { history } = window\n    history.scrollRestoration = 'manual'\n\n    const onScroll = (event: Event) => {\n      if (weakScrolledElements.has(event.target)) return\n      weakScrolledElements.add(event.target)\n\n      let elementSelector = ''\n\n      if (event.target === document || event.target === window) {\n        elementSelector = windowKey\n      } else {\n        const attrId = (event.target as Element).getAttribute(\n          'data-scroll-restoration-id',\n        )\n\n        if (attrId) {\n          elementSelector = `[data-scroll-restoration-id=\"${attrId}\"]`\n        } else {\n          elementSelector = getCssSelector(event.target)\n        }\n      }\n\n      if (!cache.state.next[elementSelector]) {\n        cache.set((c) => ({\n          ...c,\n          next: {\n            ...c.next,\n            [elementSelector]: {\n              scrollX: NaN,\n              scrollY: NaN,\n            },\n          },\n        }))\n      }\n    }\n\n    if (typeof document !== 'undefined') {\n      document.addEventListener('scroll', onScroll, true)\n    }\n\n    const unsubOnBeforeLoad = router.subscribe('onBeforeLoad', (event) => {\n      if (event.pathChanged) {\n        const restoreKey = getKey(event.fromLocation)\n        for (const elementSelector in cache.state.next) {\n          const entry = cache.state.next[elementSelector]!\n          if (elementSelector === windowKey) {\n            entry.scrollX = window.scrollX || 0\n            entry.scrollY = window.scrollY || 0\n          } else if (elementSelector) {\n            const element = document.querySelector(elementSelector)\n            entry.scrollX = element?.scrollLeft || 0\n            entry.scrollY = element?.scrollTop || 0\n          }\n\n          cache.set((c) => {\n            const next = { ...c.next }\n            delete next[elementSelector]\n\n            return {\n              ...c,\n              next,\n              cached: {\n                ...c.cached,\n                [[restoreKey, elementSelector].join(delimiter)]: entry,\n              },\n            }\n          })\n        }\n      }\n    })\n\n    const unsubOnResolved = router.subscribe('onResolved', (event) => {\n      if (event.pathChanged) {\n        if (!router.resetNextScroll) {\n          return\n        }\n\n        router.resetNextScroll = true\n\n        const restoreKey = getKey(event.toLocation)\n        let windowRestored = false\n\n        for (const cacheKey in cache.state.cached) {\n          const entry = cache.state.cached[cacheKey]!\n          const [key, elementSelector] = cacheKey.split(delimiter)\n          if (key === restoreKey) {\n            if (elementSelector === windowKey) {\n              windowRestored = true\n              window.scrollTo(entry.scrollX, entry.scrollY)\n            } else if (elementSelector) {\n              const element = document.querySelector(elementSelector)\n              if (element) {\n                element.scrollLeft = entry.scrollX\n                element.scrollTop = entry.scrollY\n              }\n            }\n          }\n        }\n\n        if (!windowRestored) {\n          window.scrollTo(0, 0)\n        }\n\n        cache.set((c) => ({ ...c, next: {} }))\n        weakScrolledElements = new WeakSet<any>()\n      }\n    })\n\n    return () => {\n      document.removeEventListener('scroll', onScroll)\n      unsubOnBeforeLoad()\n      unsubOnResolved()\n    }\n  }, [options?.getKey, router])\n}\n\nexport function ScrollRestoration(props: ScrollRestorationOptions) {\n  useScrollRestoration(props)\n  return null\n}\n\nexport function useElementScrollRestoration(\n  options: (\n    | {\n        id: string\n        getElement?: () => Element | undefined | null\n      }\n    | {\n        id?: string\n        getElement: () => Element | undefined | null\n      }\n  ) & {\n    getKey?: (location: ParsedLocation) => string\n  },\n) {\n  const router = useRouter()\n  const getKey = options.getKey || defaultGetKey\n\n  let elementSelector = ''\n\n  if (options.id) {\n    elementSelector = `[data-scroll-restoration-id=\"${options.id}\"]`\n  } else {\n    const element = options.getElement?.()\n    if (!element) {\n      return\n    }\n    elementSelector = getCssSelector(element)\n  }\n\n  const restoreKey = getKey(router.latestLocation)\n  const cacheKey = [restoreKey, elementSelector].join(delimiter)\n  return cache.state.cached[cacheKey]\n}\n\nfunction getCssSelector(el: any): string {\n  const path = []\n  let parent\n  while ((parent = el.parentNode)) {\n    path.unshift(\n      `${el.tagName}:nth-child(${\n        ([].indexOf as any).call(parent.children, el) + 1\n      })`,\n    )\n    el = parent\n  }\n  return `${path.join(' > ')}`.toLowerCase()\n}\n"],"names":[],"mappings":"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"}