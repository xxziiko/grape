{"version":3,"file":"route.js","sources":["../../src/route.ts"],"sourcesContent":["import invariant from 'tiny-invariant'\nimport { useMatch } from './useMatch'\nimport { useLoaderDeps } from './useLoaderDeps'\nimport { useLoaderData } from './useLoaderData'\nimport { joinPaths, trimPathLeft } from './path'\nimport { useParams } from './useParams'\nimport { useSearch } from './useSearch'\nimport { notFound } from './not-found'\nimport { useNavigate } from './useNavigate'\nimport { rootRouteId } from './root'\nimport type { RootRouteId } from './root'\nimport type { UseNavigateResult } from './useNavigate'\nimport type * as React from 'react'\nimport type { MakeRouteMatch, RouteMatch } from './Matches'\nimport type { NavigateOptions, ParsePathParams, ToSubOptions } from './link'\nimport type { ParsedLocation } from './location'\nimport type { RouteById, RouteIds, RoutePaths } from './routeInfo'\nimport type { AnyRouter, RegisteredRouter, Router } from './router'\nimport type { Assign, Expand, IsAny, NoInfer, PickRequired } from './utils'\nimport type { BuildLocationFn, NavigateFn } from './RouterProvider'\nimport type { NotFoundError } from './not-found'\nimport type { LazyRoute } from './fileRoute'\n\nexport type AnyPathParams = {}\n\nexport type SearchSchemaInput = {\n  __TSearchSchemaInput__: 'TSearchSchemaInput'\n}\n\nexport type AnySearchSchema = {}\n\nexport type AnyContext = {}\n\nexport interface RouteContext {}\n\nexport type PreloadableObj = { preload?: () => Promise<void> }\n\nexport type RoutePathOptions<TCustomId, TPath> =\n  | {\n      path: TPath\n    }\n  | {\n      id: TCustomId\n    }\n\nexport interface StaticDataRouteOption {}\n\nexport type RoutePathOptionsIntersection<TCustomId, TPath> = {\n  path: TPath\n  id: TCustomId\n}\n\nexport type RouteOptions<\n  TParentRoute extends AnyRoute = AnyRoute,\n  TCustomId extends string = string,\n  TPath extends string = string,\n  TSearchSchemaInput = Record<string, unknown>,\n  TSearchSchema = {},\n  TFullSearchSchema = TSearchSchema,\n  TParams = AnyPathParams,\n  TAllParams = TParams,\n  TRouteContextReturn = RouteContext,\n  TRouteContext = RouteContext,\n  TParentAllContext = AnyContext,\n  TAllContext = AnyContext,\n  TLoaderDeps extends Record<string, any> = {},\n  TLoaderDataReturn = {},\n  TLoaderData = ResolveLoaderData<TLoaderDataReturn>,\n> = BaseRouteOptions<\n  TParentRoute,\n  TCustomId,\n  TPath,\n  TSearchSchemaInput,\n  TSearchSchema,\n  TFullSearchSchema,\n  TParams,\n  TAllParams,\n  TRouteContextReturn,\n  TParentAllContext,\n  TAllContext,\n  TLoaderDeps,\n  TLoaderDataReturn\n> &\n  UpdatableRouteOptions<\n    NoInfer<TCustomId>,\n    NoInfer<TAllParams>,\n    NoInfer<TFullSearchSchema>,\n    NoInfer<TLoaderData>,\n    NoInfer<TAllContext>,\n    NoInfer<TRouteContext>,\n    NoInfer<TLoaderDeps>\n  >\n\nexport type ParseParamsFn<TPath extends string, TParams> = (\n  rawParams: Record<ParsePathParams<TPath>, string>,\n) => TParams extends Record<ParsePathParams<TPath>, any>\n  ? TParams\n  : Record<ParsePathParams<TPath>, any>\n\nexport type StringifyParamsFn<TPath extends string, TParams> = (\n  params: TParams,\n) => Record<ParsePathParams<TPath>, string>\n\nexport type ParamsOptions<TPath extends string, TParams> = {\n  params?: {\n    parse: ParseParamsFn<TPath, TParams>\n    stringify: StringifyParamsFn<TPath, TParams>\n  }\n\n  /** \n  @deprecated Use params.parse instead\n  */\n  parseParams?: ParseParamsFn<TPath, TParams>\n\n  /** \n  @deprecated Use params.stringify instead\n  */\n  stringifyParams?: StringifyParamsFn<TPath, TParams>\n}\n\nexport interface FullSearchSchemaOption<TFullSearchSchema> {\n  search: TFullSearchSchema\n}\n\nexport type FileBaseRouteOptions<\n  TPath extends string = string,\n  TSearchSchemaInput = Record<string, unknown>,\n  TSearchSchema = {},\n  TFullSearchSchema = TSearchSchema,\n  TParams = {},\n  TAllParams = {},\n  TRouteContextReturn = RouteContext,\n  TParentAllContext = AnyContext,\n  TAllContext = AnyContext,\n  TLoaderDeps extends Record<string, any> = {},\n  TLoaderDataReturn = {},\n> = {\n  validateSearch?:\n    | ((input: TSearchSchemaInput) => TSearchSchema)\n    | { parse: (input: TSearchSchemaInput) => TSearchSchema }\n  shouldReload?:\n    | boolean\n    | ((\n        match: LoaderFnContext<TAllParams, TFullSearchSchema, TAllContext>,\n      ) => any)\n  // This async function is called before a route is loaded.\n  // If an error is thrown here, the route's loader will not be called.\n  // If thrown during a navigation, the navigation will be cancelled and the error will be passed to the `onError` function.\n  // If thrown during a preload event, the error will be logged to the console.\n  beforeLoad?: (\n    ctx: BeforeLoadContext<TFullSearchSchema, TAllParams, TParentAllContext>,\n  ) => Promise<TRouteContextReturn> | TRouteContextReturn | void\n  loaderDeps?: (opts: FullSearchSchemaOption<TFullSearchSchema>) => TLoaderDeps\n  loader?: (\n    ctx: LoaderFnContext<TAllParams, TLoaderDeps, TAllContext>,\n  ) => TLoaderDataReturn | Promise<TLoaderDataReturn>\n} & ParamsOptions<TPath, TParams>\n\nexport type BaseRouteOptions<\n  TParentRoute extends AnyRoute = AnyRoute,\n  TCustomId extends string = string,\n  TPath extends string = string,\n  TSearchSchemaInput = Record<string, unknown>,\n  TSearchSchema = {},\n  TFullSearchSchema = TSearchSchema,\n  TParams = {},\n  TAllParams = {},\n  TRouteContextReturn = RouteContext,\n  TParentAllContext = AnyContext,\n  TAllContext = AnyContext,\n  TLoaderDeps extends Record<string, any> = {},\n  TLoaderDataReturn = {},\n> = RoutePathOptions<TCustomId, TPath> &\n  FileBaseRouteOptions<\n    TPath,\n    TSearchSchemaInput,\n    TSearchSchema,\n    TFullSearchSchema,\n    TParams,\n    TAllParams,\n    TRouteContextReturn,\n    TParentAllContext,\n    TAllContext,\n    TLoaderDeps,\n    TLoaderDataReturn\n  > & {\n    getParentRoute: () => TParentRoute\n  }\n\nexport interface BeforeLoadContext<\n  TFullSearchSchema,\n  TAllParams,\n  TParentAllContext,\n> extends FullSearchSchemaOption<TFullSearchSchema> {\n  abortController: AbortController\n  preload: boolean\n  params: Expand<TAllParams>\n  context: TParentAllContext\n  location: ParsedLocation\n  /**\n   * @deprecated Use `throw redirect({ to: '/somewhere' })` instead\n   **/\n  navigate: NavigateFn\n  buildLocation: BuildLocationFn\n  cause: 'preload' | 'enter' | 'stay'\n}\n\nexport type UpdatableRouteOptions<\n  TRouteId,\n  TAllParams,\n  TFullSearchSchema,\n  TLoaderData,\n  TAllContext,\n  TRouteContext,\n  TLoaderDeps,\n  TRouteMatch = RouteMatch<\n    TRouteId,\n    TAllParams,\n    TFullSearchSchema,\n    TLoaderData,\n    TAllContext,\n    TRouteContext,\n    TLoaderDeps\n  >,\n> = {\n  // test?: (args: TAllContext) => void\n  // If true, this route will be matched as case-sensitive\n  caseSensitive?: boolean\n  // If true, this route will be forcefully wrapped in a suspense boundary\n  wrapInSuspense?: boolean\n  // The content to be rendered when the route is matched. If no component is provided, defaults to `<Outlet />`\n  component?: RouteComponent\n  errorComponent?: false | null | ErrorRouteComponent\n  notFoundComponent?: NotFoundRouteComponent\n  pendingComponent?: RouteComponent\n  pendingMs?: number\n  pendingMinMs?: number\n  staleTime?: number\n  gcTime?: number\n  preloadStaleTime?: number\n  preloadGcTime?: number\n  // Filter functions that can manipulate search params *before* they are passed to links and navigate\n  // calls that match this route.\n  preSearchFilters?: Array<SearchFilter<TFullSearchSchema>>\n  // Filter functions that can manipulate search params *after* they are passed to links and navigate\n  // calls that match this route.\n  postSearchFilters?: Array<SearchFilter<TFullSearchSchema>>\n  onCatch?: (error: Error, errorInfo: React.ErrorInfo) => void\n  onError?: (err: any) => void\n  // These functions are called as route matches are loaded, stick around and leave the active\n  // matches\n  onEnter?: (match: TRouteMatch) => void\n  onStay?: (match: TRouteMatch) => void\n  onLeave?: (match: TRouteMatch) => void\n  meta?: (ctx: {\n    matches: Array<TRouteMatch>\n    match: TRouteMatch\n    params: TAllParams\n    loaderData: TLoaderData\n  }) => Array<React.JSX.IntrinsicElements['meta']>\n  links?: () => Array<React.JSX.IntrinsicElements['link']>\n  scripts?: () => Array<React.JSX.IntrinsicElements['script']>\n  headers?: (ctx: { loaderData: TLoaderData }) => Record<string, string>\n} & UpdatableStaticRouteOption\n\nexport type UpdatableStaticRouteOption =\n  {} extends PickRequired<StaticDataRouteOption>\n    ? {\n        staticData?: StaticDataRouteOption\n      }\n    : {\n        staticData: StaticDataRouteOption\n      }\n\nexport type MetaDescriptor =\n  | { charSet: 'utf-8' }\n  | { title: string }\n  | { name: string; content: string }\n  | { property: string; content: string }\n  | { httpEquiv: string; content: string }\n  | { 'script:ld+json': LdJsonObject }\n  | { tagName: 'meta' | 'link'; [name: string]: string }\n  | Record<string, unknown>\n\ntype LdJsonObject = { [Key in string]: LdJsonValue } & {\n  [Key in string]?: LdJsonValue | undefined\n}\ntype LdJsonArray = Array<LdJsonValue> | ReadonlyArray<LdJsonValue>\ntype LdJsonPrimitive = string | number | boolean | null\ntype LdJsonValue = LdJsonPrimitive | LdJsonObject | LdJsonArray\n\nexport type RouteLinkEntry = {}\n\n// The parse type here allows a zod schema to be passed directly to the validator\nexport type SearchSchemaValidator<TInput, TReturn> =\n  | SearchSchemaValidatorObj<TInput, TReturn>\n  | SearchSchemaValidatorFn<TInput, TReturn>\n\nexport type SearchSchemaValidatorObj<TInput, TReturn> = {\n  parse?: SearchSchemaValidatorFn<TInput, TReturn>\n}\n\nexport type SearchSchemaValidatorFn<TInput, TReturn> = (\n  searchObj: TInput,\n) => TReturn\n\nexport type RouteLoaderFn<\n  in out TAllParams = {},\n  in out TLoaderDeps extends Record<string, any> = {},\n  in out TAllContext = AnyContext,\n  TLoaderData = undefined,\n> = (\n  match: LoaderFnContext<TAllParams, TLoaderDeps, TAllContext>,\n) => TLoaderData | Promise<TLoaderData>\n\nexport interface LoaderFnContext<\n  in out TAllParams = {},\n  in out TLoaderDeps = {},\n  in out TAllContext = AnyContext,\n> {\n  abortController: AbortController\n  preload: boolean\n  params: Expand<TAllParams>\n  deps: TLoaderDeps\n  context: TAllContext\n  location: ParsedLocation // Do not supply search schema here so as to demotivate people from trying to shortcut loaderDeps\n  /**\n   * @deprecated Use `throw redirect({ to: '/somewhere' })` instead\n   **/\n  navigate: (opts: NavigateOptions<AnyRouter>) => Promise<void>\n  parentMatchPromise?: Promise<void>\n  cause: 'preload' | 'enter' | 'stay'\n  route: Route\n}\n\nexport type SearchFilter<TInput, TResult = TInput> = (prev: TInput) => TResult\n\nexport type ResolveId<\n  TParentRoute,\n  TCustomId extends string,\n  TPath extends string,\n> = TParentRoute extends { id: infer TParentId extends string }\n  ? RoutePrefix<TParentId, string extends TCustomId ? TPath : TCustomId>\n  : RootRouteId\n\nexport type InferFullSearchSchema<TRoute> = TRoute extends {\n  types: {\n    fullSearchSchema: infer TFullSearchSchema\n  }\n}\n  ? TFullSearchSchema\n  : {}\n\nexport type InferFullSearchSchemaInput<TRoute> = TRoute extends {\n  types: {\n    fullSearchSchemaInput: infer TFullSearchSchemaInput\n  }\n}\n  ? TFullSearchSchemaInput\n  : {}\n\nexport type InferAllParams<TRoute> = TRoute extends {\n  types: {\n    allParams: infer TAllParams\n  }\n}\n  ? TAllParams\n  : {}\n\nexport type InferAllContext<TRoute> = TRoute extends {\n  types: {\n    allContext: infer TAllContext\n  }\n}\n  ? TAllContext\n  : {}\n\nexport type ResolveSearchSchemaUsed<TSearchSchemaInput, TSearchSchema> =\n  TSearchSchemaInput extends SearchSchemaInput\n    ? Omit<TSearchSchemaInput, keyof SearchSchemaInput>\n    : TSearchSchema\n\nexport type ResolveFullSearchSchema<\n  TParentRoute extends AnyRoute,\n  TSearchSchema,\n> = Assign<InferFullSearchSchema<TParentRoute>, TSearchSchema>\n\nexport type ResolveFullSearchSchemaInput<\n  TParentRoute extends AnyRoute,\n  TSearchSchemaUsed,\n> = Assign<InferFullSearchSchemaInput<TParentRoute>, TSearchSchemaUsed>\n\nexport type ResolveRouteContext<TRouteContextReturn> = [\n  TRouteContextReturn,\n] extends [never]\n  ? RouteContext\n  : TRouteContextReturn\n\nexport type ResolveAllContext<\n  TParentRoute extends AnyRoute,\n  TRouteContext,\n> = Assign<InferAllContext<TParentRoute>, TRouteContext>\n\nexport type ResolveLoaderData<TLoaderDataReturn> = [TLoaderDataReturn] extends [\n  never,\n]\n  ? undefined\n  : TLoaderDataReturn\n\nexport interface AnyRoute\n  extends Route<\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any\n  > {}\n\nexport type AnyRouteWithContext<TContext> = Route<\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  TContext,\n  any,\n  any,\n  any,\n  any\n>\n\nexport type ResolveAllParamsFromParent<\n  TParentRoute extends AnyRoute,\n  TParams,\n> = Assign<InferAllParams<TParentRoute>, TParams>\n\nexport type RouteConstraints = {\n  TParentRoute: AnyRoute\n  TPath: string\n  TFullPath: string\n  TCustomId: string\n  TId: string\n  TSearchSchema: AnySearchSchema\n  TFullSearchSchema: AnySearchSchema\n  TParams: Record<string, any>\n  TAllParams: Record<string, any>\n  TParentContext: AnyContext\n  TRouteContext: RouteContext\n  TAllContext: AnyContext\n  TRouterContext: AnyContext\n  TChildren: unknown\n  TRouteTree: AnyRoute\n}\n\nexport function getRouteApi<\n  TId extends RouteIds<RegisteredRouter['routeTree']>,\n  TRouter extends AnyRouter = RegisteredRouter,\n  TRoute extends AnyRoute = RouteById<TRouter['routeTree'], TId>,\n  TFullSearchSchema = TRoute['types']['fullSearchSchema'],\n  TAllParams = TRoute['types']['allParams'],\n  TAllContext = TRoute['types']['allContext'],\n  TLoaderDeps = TRoute['types']['loaderDeps'],\n  TLoaderData = TRoute['types']['loaderData'],\n>(id: TId) {\n  return new RouteApi<\n    TId,\n    TRouter,\n    TRoute,\n    TFullSearchSchema,\n    TAllParams,\n    TAllContext,\n    TLoaderDeps,\n    TLoaderData\n  >({ id })\n}\n\nexport class RouteApi<\n  TId extends RouteIds<RegisteredRouter['routeTree']>,\n  TRouter extends AnyRouter = RegisteredRouter,\n  TRoute extends AnyRoute = RouteById<TRouter['routeTree'], TId>,\n  TFullSearchSchema = TRoute['types']['fullSearchSchema'],\n  TAllParams = TRoute['types']['allParams'],\n  TAllContext = TRoute['types']['allContext'],\n  TLoaderDeps = TRoute['types']['loaderDeps'],\n  TLoaderData = TRoute['types']['loaderData'],\n> {\n  id: TId\n\n  /**\n   * @deprecated Use the `getRouteApi` function instead.\n   */\n  constructor({ id }: { id: TId }) {\n    this.id = id as any\n  }\n\n  useMatch = <\n    TRouteTree extends AnyRoute = TRouter['routeTree'],\n    TRouteMatch = MakeRouteMatch<TRouteTree, TId>,\n    TSelected = TRouteMatch,\n  >(opts?: {\n    select?: (match: TRouteMatch) => TSelected\n  }): TSelected => {\n    return useMatch({ select: opts?.select, from: this.id })\n  }\n\n  useRouteContext = <TSelected = Expand<TAllContext>>(opts?: {\n    select?: (s: Expand<TAllContext>) => TSelected\n  }): TSelected => {\n    return useMatch({\n      from: this.id,\n      select: (d: any) => (opts?.select ? opts.select(d.context) : d.context),\n    })\n  }\n\n  useSearch = <TSelected = Expand<TFullSearchSchema>>(opts?: {\n    select?: (s: Expand<TFullSearchSchema>) => TSelected\n  }): TSelected => {\n    return useSearch({ ...opts, from: this.id })\n  }\n\n  useParams = <TSelected = Expand<TAllParams>>(opts?: {\n    select?: (s: Expand<TAllParams>) => TSelected\n  }): TSelected => {\n    return useParams({ ...opts, from: this.id })\n  }\n\n  useLoaderDeps = <TSelected = TLoaderDeps>(opts?: {\n    select?: (s: TLoaderDeps) => TSelected\n  }): TSelected => {\n    return useLoaderDeps({ ...opts, from: this.id, strict: false } as any)\n  }\n\n  useLoaderData = <TSelected = TLoaderData>(opts?: {\n    select?: (s: TLoaderData) => TSelected\n  }): TSelected => {\n    return useLoaderData({ ...opts, from: this.id, strict: false } as any)\n  }\n\n  useNavigate = (): UseNavigateResult<TRoute['fullPath']> => {\n    return useNavigate({ from: this.id })\n  }\n\n  notFound = (opts?: NotFoundError) => {\n    return notFound({ routeId: this.id as string, ...opts })\n  }\n}\n\nexport class Route<\n  in out TParentRoute extends RouteConstraints['TParentRoute'] = AnyRoute,\n  in out TPath extends RouteConstraints['TPath'] = '/',\n  in out TFullPath extends RouteConstraints['TFullPath'] = ResolveFullPath<\n    TParentRoute,\n    TPath\n  >,\n  in out TCustomId extends RouteConstraints['TCustomId'] = string,\n  in out TId extends RouteConstraints['TId'] = ResolveId<\n    TParentRoute,\n    TCustomId,\n    TPath\n  >,\n  in out TSearchSchemaInput = Record<string, unknown>,\n  in out TSearchSchema = {},\n  in out TSearchSchemaUsed = ResolveSearchSchemaUsed<\n    TSearchSchemaInput,\n    TSearchSchema\n  >,\n  in out TFullSearchSchemaInput = ResolveFullSearchSchemaInput<\n    TParentRoute,\n    TSearchSchemaUsed\n  >,\n  in out TFullSearchSchema = ResolveFullSearchSchema<\n    TParentRoute,\n    TSearchSchema\n  >,\n  in out TParams = Record<ParsePathParams<TPath>, string>,\n  in out TAllParams = ResolveAllParamsFromParent<TParentRoute, TParams>,\n  TRouteContextReturn = RouteContext,\n  in out TRouteContext = ResolveRouteContext<TRouteContextReturn>,\n  in out TAllContext = ResolveAllContext<TParentRoute, TRouteContext>,\n  in out TLoaderDeps extends Record<string, any> = {},\n  TLoaderDataReturn = {},\n  in out TLoaderData = ResolveLoaderData<TLoaderDataReturn>,\n  in out TChildren = unknown,\n> {\n  isRoot: TParentRoute extends Route<any> ? true : false\n  options: RouteOptions<\n    TParentRoute,\n    TCustomId,\n    TPath,\n    TSearchSchemaInput,\n    TSearchSchema,\n    TFullSearchSchema,\n    TParams,\n    TAllParams,\n    TRouteContextReturn,\n    TRouteContext,\n    InferAllContext<TParentRoute>,\n    TAllContext,\n    TLoaderDeps,\n    TLoaderDataReturn,\n    TLoaderData\n  >\n\n  // Set up in this.init()\n  parentRoute!: TParentRoute\n  id!: TId\n  // customId!: TCustomId\n  path!: TPath\n  fullPath!: TFullPath\n  to!: TrimPathRight<TFullPath>\n\n  // Optional\n  children?: TChildren\n  originalIndex?: number\n  router?: AnyRouter\n  rank!: number\n  lazyFn?: () => Promise<LazyRoute<any>>\n  _lazyPromise?: Promise<void>\n\n  /**\n   * @deprecated Use the `createRoute` function instead.\n   */\n  constructor(\n    options?: RouteOptions<\n      TParentRoute,\n      TCustomId,\n      TPath,\n      TSearchSchemaInput,\n      TSearchSchema,\n      TFullSearchSchema,\n      TParams,\n      TAllParams,\n      TRouteContextReturn,\n      TRouteContext,\n      InferAllContext<TParentRoute>,\n      TAllContext,\n      TLoaderDeps,\n      TLoaderDataReturn,\n      TLoaderData\n    >,\n  ) {\n    this.options = (options as any) || {}\n\n    this.isRoot = !options?.getParentRoute as any\n    invariant(\n      !((options as any)?.id && (options as any)?.path),\n      `Route cannot have both an 'id' and a 'path' option.`,\n    )\n    ;(this as any).$$typeof = Symbol.for('react.memo')\n  }\n\n  types!: {\n    parentRoute: TParentRoute\n    path: TPath\n    to: TrimPathRight<TFullPath>\n    fullPath: TFullPath\n    customId: TCustomId\n    id: TId\n    searchSchema: TSearchSchema\n    searchSchemaInput: TSearchSchemaInput\n    searchSchemaUsed: TSearchSchemaUsed\n    fullSearchSchema: TFullSearchSchema\n    fullSearchSchemaInput: TFullSearchSchemaInput\n    params: TParams\n    allParams: TAllParams\n    routeContext: TRouteContext\n    allContext: TAllContext\n    children: TChildren\n    loaderData: TLoaderData\n    loaderDeps: TLoaderDeps\n  }\n\n  init = (opts: { originalIndex: number }): void => {\n    this.originalIndex = opts.originalIndex\n\n    const options = this.options as\n      | (RouteOptions<\n          TParentRoute,\n          TCustomId,\n          TPath,\n          TSearchSchemaInput,\n          TSearchSchema,\n          TFullSearchSchema,\n          TParams,\n          TAllParams,\n          TRouteContextReturn,\n          TRouteContext,\n          InferAllContext<TParentRoute>,\n          TAllContext,\n          TLoaderDeps,\n          TLoaderDataReturn,\n          TLoaderData\n        > &\n          RoutePathOptionsIntersection<TCustomId, TPath>)\n      | undefined\n\n    const isRoot = !options?.path && !options?.id\n\n    // eslint-disable-next-line ts/no-unnecessary-condition\n    this.parentRoute = this.options?.getParentRoute?.()\n\n    if (isRoot) {\n      this.path = rootRouteId as TPath\n    } else {\n      invariant(\n        this.parentRoute,\n        `Child Route instances must pass a 'getParentRoute: () => ParentRoute' option that returns a Route instance.`,\n      )\n    }\n\n    let path: undefined | string = isRoot ? rootRouteId : options.path\n\n    // If the path is anything other than an index path, trim it up\n    if (path && path !== '/') {\n      path = trimPathLeft(path)\n    }\n\n    const customId = options?.id || path\n\n    // Strip the parentId prefix from the first level of children\n    let id = isRoot\n      ? rootRouteId\n      : joinPaths([\n          this.parentRoute.id === rootRouteId ? '' : this.parentRoute.id,\n          customId,\n        ])\n\n    if (path === rootRouteId) {\n      path = '/'\n    }\n\n    if (id !== rootRouteId) {\n      id = joinPaths(['/', id])\n    }\n\n    const fullPath =\n      id === rootRouteId ? '/' : joinPaths([this.parentRoute.fullPath, path])\n\n    this.path = path as TPath\n    this.id = id as TId\n    // this.customId = customId as TCustomId\n    this.fullPath = fullPath as TFullPath\n    this.to = fullPath as TrimPathRight<TFullPath>\n  }\n\n  addChildren<\n    const TNewChildren extends\n      | Record<string, AnyRoute>\n      | ReadonlyArray<AnyRoute>,\n  >(\n    children: TNewChildren,\n  ): Route<\n    TParentRoute,\n    TPath,\n    TFullPath,\n    TCustomId,\n    TId,\n    TSearchSchemaInput,\n    TSearchSchema,\n    TSearchSchemaUsed,\n    TFullSearchSchemaInput,\n    TFullSearchSchema,\n    TParams,\n    TAllParams,\n    TRouteContextReturn,\n    TRouteContext,\n    TAllContext,\n    TLoaderDeps,\n    TLoaderDataReturn,\n    TLoaderData,\n    TNewChildren\n  > {\n    this.children = (\n      Array.isArray(children) ? children : Object.values(children)\n    ) as any\n    return this as any\n  }\n\n  updateLoader = <TNewLoaderData = unknown>(options: {\n    loader: RouteLoaderFn<TAllParams, TLoaderDeps, TAllContext, TNewLoaderData>\n  }) => {\n    Object.assign(this.options, options)\n    return this as unknown as Route<\n      TParentRoute,\n      TPath,\n      TFullPath,\n      TCustomId,\n      TId,\n      TSearchSchemaInput,\n      TSearchSchema,\n      TSearchSchemaUsed,\n      TFullSearchSchemaInput,\n      TFullSearchSchema,\n      TParams,\n      TAllParams,\n      TRouteContextReturn,\n      TRouteContext,\n      TAllContext,\n      TLoaderDeps,\n      TNewLoaderData,\n      TChildren\n    >\n  }\n\n  update = (\n    options: UpdatableRouteOptions<\n      TCustomId,\n      TAllParams,\n      TFullSearchSchema,\n      TLoaderData,\n      TAllContext,\n      TRouteContext,\n      TLoaderDeps\n    >,\n  ): this => {\n    Object.assign(this.options, options)\n    return this\n  }\n\n  lazy = (lazyFn: () => Promise<LazyRoute<any>>): this => {\n    this.lazyFn = lazyFn\n    return this\n  }\n\n  useMatch = <\n    TRouter extends AnyRouter = RegisteredRouter,\n    TRouteTree extends AnyRoute = TRouter['routeTree'],\n    TRouteMatch = MakeRouteMatch<TRouteTree, TId>,\n    TSelected = TRouteMatch,\n  >(opts?: {\n    select?: (match: TRouteMatch) => TSelected\n  }): TSelected => {\n    return useMatch({ ...opts, from: this.id })\n  }\n\n  useRouteContext = <TSelected = Expand<TAllContext>>(opts?: {\n    select?: (search: Expand<TAllContext>) => TSelected\n  }): TSelected => {\n    return useMatch({\n      ...opts,\n      from: this.id,\n      select: (d: any) => (opts?.select ? opts.select(d.context) : d.context),\n    })\n  }\n\n  useSearch = <TSelected = Expand<TFullSearchSchema>>(opts?: {\n    select?: (search: Expand<TFullSearchSchema>) => TSelected\n  }): TSelected => {\n    return useSearch({ ...opts, from: this.id })\n  }\n\n  useParams = <TSelected = Expand<TAllParams>>(opts?: {\n    select?: (search: Expand<TAllParams>) => TSelected\n  }): TSelected => {\n    return useParams({ ...opts, from: this.id })\n  }\n\n  useLoaderDeps = <TSelected = TLoaderDeps>(opts?: {\n    select?: (s: TLoaderDeps) => TSelected\n  }): TSelected => {\n    return useLoaderDeps({ ...opts, from: this.id } as any)\n  }\n\n  useLoaderData = <TSelected = TLoaderData>(opts?: {\n    select?: (search: TLoaderData) => TSelected\n  }): TSelected => {\n    return useLoaderData({ ...opts, from: this.id } as any)\n  }\n\n  useNavigate = (): UseNavigateResult<TFullPath> => {\n    return useNavigate({ from: this.id })\n  }\n}\n\nexport function createRoute<\n  TParentRoute extends RouteConstraints['TParentRoute'] = AnyRoute,\n  TPath extends RouteConstraints['TPath'] = '/',\n  TFullPath extends RouteConstraints['TFullPath'] = ResolveFullPath<\n    TParentRoute,\n    TPath\n  >,\n  TCustomId extends RouteConstraints['TCustomId'] = string,\n  TId extends RouteConstraints['TId'] = ResolveId<\n    TParentRoute,\n    TCustomId,\n    TPath\n  >,\n  TSearchSchemaInput = Record<string, unknown>,\n  TSearchSchema = {},\n  TSearchSchemaUsed = ResolveSearchSchemaUsed<\n    TSearchSchemaInput,\n    TSearchSchema\n  >,\n  TFullSearchSchemaInput = ResolveFullSearchSchemaInput<\n    TParentRoute,\n    TSearchSchemaUsed\n  >,\n  TFullSearchSchema = ResolveFullSearchSchema<TParentRoute, TSearchSchema>,\n  TParams = Record<ParsePathParams<TPath>, string>,\n  TAllParams = ResolveAllParamsFromParent<TParentRoute, TParams>,\n  TRouteContextReturn = RouteContext,\n  TRouteContext = ResolveRouteContext<TRouteContextReturn>,\n  TAllContext = ResolveAllContext<TParentRoute, TRouteContext>,\n  TLoaderDeps extends Record<string, any> = {},\n  TLoaderDataReturn = {},\n  TLoaderData = ResolveLoaderData<TLoaderDataReturn>,\n  TChildren = unknown,\n>(\n  options: RouteOptions<\n    TParentRoute,\n    TCustomId,\n    TPath,\n    TSearchSchemaInput,\n    TSearchSchema,\n    TFullSearchSchema,\n    TParams,\n    TAllParams,\n    TRouteContextReturn,\n    TRouteContext,\n    InferAllContext<TParentRoute>,\n    TAllContext,\n    TLoaderDeps,\n    TLoaderDataReturn,\n    TLoaderData\n  >,\n) {\n  return new Route<\n    TParentRoute,\n    TPath,\n    TFullPath,\n    TCustomId,\n    TId,\n    TSearchSchemaInput,\n    TSearchSchema,\n    TSearchSchemaUsed,\n    TFullSearchSchemaInput,\n    TFullSearchSchema,\n    TParams,\n    TAllParams,\n    TRouteContextReturn,\n    TRouteContext,\n    TAllContext,\n    TLoaderDeps,\n    TLoaderDataReturn,\n    TLoaderData,\n    TChildren\n  >(options)\n}\n\nexport type AnyRootRoute = RootRoute<any, any, any, any, any, any, any, any>\n\nexport type RootRouteOptions<\n  TSearchSchemaInput = {},\n  TSearchSchema = {},\n  TRouteContextReturn = RouteContext,\n  TRouteContext = ResolveRouteContext<TRouteContextReturn>,\n  TRouterContext = {},\n  TLoaderDeps extends Record<string, any> = {},\n  TLoaderDataReturn = {},\n  TLoaderData = ResolveLoaderData<TLoaderDataReturn>,\n> = Omit<\n  RouteOptions<\n    any, // TParentRoute\n    RootRouteId, // TCustomId\n    '', // TPath\n    TSearchSchemaInput, // TSearchSchemaInput\n    TSearchSchema, // TSearchSchema\n    TSearchSchema, // TFullSearchSchema\n    {}, // TParams\n    {}, // TAllParams\n    TRouteContextReturn, // TRouteContextReturn\n    TRouteContext, // TRouteContext\n    TRouterContext, // TParentAllContext\n    Assign<TRouterContext, TRouteContext>, // TAllContext\n    TLoaderDeps,\n    TLoaderDataReturn, // TLoaderDataReturn,\n    TLoaderData // TLoaderData,\n  >,\n  | 'path'\n  | 'id'\n  | 'getParentRoute'\n  | 'caseSensitive'\n  | 'parseParams'\n  | 'stringifyParams'\n  | 'params'\n>\n\nexport function createRootRouteWithContext<TRouterContext extends {}>() {\n  return <\n    TSearchSchemaInput = {},\n    TSearchSchema = {},\n    TSearchSchemaUsed = ResolveSearchSchemaUsed<\n      TSearchSchemaInput,\n      TSearchSchema\n    >,\n    TRouteContextReturn extends RouteContext = RouteContext,\n    TRouteContext extends\n      RouteContext = ResolveRouteContext<TRouteContextReturn>,\n    TLoaderDeps extends Record<string, any> = {},\n    TLoaderDataReturn = {},\n    TLoaderData = ResolveLoaderData<TLoaderDataReturn>,\n  >(\n    options?: RootRouteOptions<\n      TSearchSchemaInput,\n      TSearchSchema,\n      TRouteContextReturn,\n      TRouteContext,\n      TRouterContext,\n      TLoaderDeps,\n      TLoaderDataReturn,\n      TLoaderData\n    >,\n  ) => {\n    return createRootRoute<\n      TSearchSchemaInput,\n      TSearchSchema,\n      TSearchSchemaUsed,\n      TRouteContextReturn,\n      TRouteContext,\n      TRouterContext,\n      TLoaderDeps,\n      TLoaderData\n    >(options as any)\n  }\n}\n\n/**\n * @deprecated Use the `createRootRouteWithContext` function instead.\n */\nexport const rootRouteWithContext = createRootRouteWithContext\n\nexport class RootRoute<\n  in out TSearchSchemaInput = {},\n  in out TSearchSchema = {},\n  in out TSearchSchemaUsed = {},\n  TRouteContextReturn = RouteContext,\n  in out TRouteContext = ResolveRouteContext<TRouteContextReturn>,\n  in out TRouterContext = {},\n  TLoaderDeps extends Record<string, any> = {},\n  TLoaderDataReturn = {},\n  in out TLoaderData = ResolveLoaderData<TLoaderDataReturn>,\n  TChildren = unknown,\n> extends Route<\n  any, // TParentRoute\n  '/', // TPath\n  '/', // TFullPath\n  string, // TCustomId\n  RootRouteId, // TId\n  TSearchSchemaInput, // TSearchSchemaInput\n  TSearchSchema, // TSearchSchema\n  TSearchSchemaUsed,\n  TSearchSchemaUsed, // TFullSearchSchemaInput\n  TSearchSchema, // TFullSearchSchema\n  {}, // TParams\n  {}, // TAllParams\n  TRouteContextReturn, // TRouteContextReturn\n  TRouteContext, // TRouteContext\n  Assign<TRouterContext, TRouteContext>, // TAllContext\n  TLoaderDeps,\n  TLoaderDataReturn,\n  TLoaderData,\n  TChildren // TChildren\n> {\n  /**\n   * @deprecated `RootRoute` is now an internal implementation detail. Use `createRootRoute()` instead.\n   */\n  constructor(\n    options?: RootRouteOptions<\n      TSearchSchemaInput,\n      TSearchSchema,\n      TRouteContextReturn,\n      TRouteContext,\n      TRouterContext,\n      TLoaderDeps,\n      TLoaderDataReturn,\n      TLoaderData\n    >,\n  ) {\n    super(options as any)\n  }\n\n  addChildren<\n    const TNewChildren extends\n      | Record<string, AnyRoute>\n      | ReadonlyArray<AnyRoute>,\n  >(\n    children: TNewChildren,\n  ): RootRoute<\n    TSearchSchemaInput,\n    TSearchSchema,\n    TSearchSchemaUsed,\n    TRouteContextReturn,\n    TRouteContext,\n    TRouterContext,\n    TLoaderDeps,\n    TLoaderDataReturn,\n    TLoaderData,\n    TNewChildren\n  > {\n    return super.addChildren(children)\n  }\n}\n\nexport function createRootRoute<\n  TSearchSchemaInput = {},\n  TSearchSchema = {},\n  TSearchSchemaUsed = ResolveSearchSchemaUsed<\n    TSearchSchemaInput,\n    TSearchSchema\n  >,\n  TRouteContextReturn = RouteContext,\n  TRouteContext = ResolveRouteContext<TRouteContextReturn>,\n  TRouterContext = {},\n  TLoaderDeps extends Record<string, any> = {},\n  TLoaderDataReturn = {},\n  TLoaderData = ResolveLoaderData<TLoaderDataReturn>,\n>(\n  options?: Omit<\n    RouteOptions<\n      any, // TParentRoute\n      RootRouteId, // TCustomId\n      '', // TPath\n      TSearchSchemaInput, // TSearchSchemaInput\n      TSearchSchema, // TSearchSchema\n      TSearchSchema,\n      {}, // TParams\n      {}, // TAllParams\n      TRouteContextReturn, // TRouteContextReturn\n      TRouteContext, // TRouteContext\n      TRouterContext,\n      Assign<TRouterContext, TRouteContext>, // TAllContext\n      TLoaderDeps,\n      TLoaderDataReturn,\n      TLoaderData\n    >,\n    | 'path'\n    | 'id'\n    | 'getParentRoute'\n    | 'caseSensitive'\n    | 'parseParams'\n    | 'stringifyParams'\n    | 'params'\n  >,\n) {\n  return new RootRoute<\n    TSearchSchemaInput,\n    TSearchSchema,\n    TSearchSchemaUsed,\n    TRouteContextReturn,\n    TRouteContext,\n    TRouterContext,\n    TLoaderDeps,\n    TLoaderDataReturn,\n    TLoaderData\n  >(options)\n}\n\nexport type ResolveFullPath<\n  TParentRoute extends AnyRoute,\n  TPath extends string,\n  TPrefixed = RoutePrefix<TParentRoute['fullPath'], TPath>,\n> = TPrefixed extends RootRouteId ? '/' : TPrefixed\n\ntype RoutePrefix<\n  TPrefix extends string,\n  TPath extends string,\n> = string extends TPath\n  ? RootRouteId\n  : TPath extends string\n    ? TPrefix extends RootRouteId\n      ? TPath extends '/'\n        ? '/'\n        : `/${TrimPath<TPath>}`\n      : `${TPrefix}/${TPath}` extends '/'\n        ? '/'\n        : `/${TrimPathLeft<`${TrimPathRight<TPrefix>}/${TrimPath<TPath>}`>}`\n    : never\n\nexport type TrimPath<T extends string> = '' extends T\n  ? ''\n  : TrimPathRight<TrimPathLeft<T>>\n\nexport type TrimPathLeft<T extends string> =\n  T extends `${RootRouteId}/${infer U}`\n    ? TrimPathLeft<U>\n    : T extends `/${infer U}`\n      ? TrimPathLeft<U>\n      : T\nexport type TrimPathRight<T extends string> = T extends '/'\n  ? '/'\n  : T extends `${infer U}/`\n    ? TrimPathRight<U>\n    : T\n\nexport type RouteMask<TRouteTree extends AnyRoute> = {\n  routeTree: TRouteTree\n  from: RoutePaths<TRouteTree>\n  to?: any\n  params?: any\n  search?: any\n  hash?: any\n  state?: any\n  unmaskOnReload?: boolean\n}\n\nexport function createRouteMask<\n  TRouteTree extends AnyRoute,\n  TFrom extends RoutePaths<TRouteTree>,\n  TTo extends string,\n>(\n  opts: {\n    routeTree: TRouteTree\n  } & ToSubOptions<Router<TRouteTree, 'never'>, TFrom, TTo>,\n): RouteMask<TRouteTree> {\n  return opts as any\n}\n\n/**\n * @deprecated Use `ErrorComponentProps` instead.\n */\nexport type ErrorRouteProps = {\n  error: unknown\n  info?: { componentStack: string }\n  reset: () => void\n}\n\nexport type ErrorComponentProps = {\n  error: Error\n  info?: { componentStack: string }\n  reset: () => void\n}\nexport type NotFoundRouteProps = {\n  // TODO: Make sure this is `| null | undefined` (this is for global not-founds)\n  data: unknown\n}\n//\n\nexport type ReactNode = any\n\nexport type SyncRouteComponent<TProps> =\n  | ((props: TProps) => ReactNode)\n  | React.LazyExoticComponent<(props: TProps) => ReactNode>\n\nexport type AsyncRouteComponent<TProps> = SyncRouteComponent<TProps> & {\n  preload?: () => Promise<void>\n}\n\nexport type RouteComponent<TProps = any> = AsyncRouteComponent<TProps>\n\nexport type ErrorRouteComponent = RouteComponent<ErrorComponentProps>\n\nexport type NotFoundRouteComponent = SyncRouteComponent<NotFoundRouteProps>\n\nexport class NotFoundRoute<\n  TParentRoute extends AnyRootRoute,\n  TSearchSchemaInput = Record<string, unknown>,\n  TSearchSchema = {},\n  TSearchSchemaUsed = {},\n  TFullSearchSchemaInput = ResolveFullSearchSchemaInput<\n    TParentRoute,\n    TSearchSchemaUsed\n  >,\n  TFullSearchSchema = ResolveFullSearchSchema<TParentRoute, TSearchSchema>,\n  TRouteContextReturn = AnyContext,\n  TRouteContext = RouteContext,\n  TAllContext = ResolveAllContext<TParentRoute, TRouteContext>,\n  TLoaderDeps extends Record<string, any> = {},\n  TLoaderDataReturn = {},\n  TLoaderData = ResolveLoaderData<TLoaderDataReturn>,\n  TChildren = unknown,\n> extends Route<\n  TParentRoute,\n  '/404',\n  '/404',\n  '404',\n  '404',\n  TSearchSchemaInput,\n  TSearchSchema,\n  TSearchSchemaUsed,\n  TFullSearchSchemaInput,\n  TFullSearchSchema,\n  {},\n  {},\n  TRouteContextReturn,\n  TRouteContext,\n  TAllContext,\n  TLoaderDeps,\n  TLoaderDataReturn,\n  TLoaderData,\n  TChildren\n> {\n  constructor(\n    options: Omit<\n      RouteOptions<\n        TParentRoute,\n        string,\n        string,\n        TSearchSchemaInput,\n        TSearchSchema,\n        TFullSearchSchema,\n        {},\n        {},\n        TRouteContextReturn,\n        TRouteContext,\n        InferAllContext<TParentRoute>,\n        TAllContext,\n        TLoaderDeps,\n        TLoaderDataReturn,\n        TLoaderData\n      >,\n      | 'caseSensitive'\n      | 'parseParams'\n      | 'stringifyParams'\n      | 'path'\n      | 'id'\n      | 'params'\n    >,\n  ) {\n    super({\n      ...(options as any),\n      id: '404',\n    })\n  }\n}\n"],"names":["options"],"mappings":"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"}