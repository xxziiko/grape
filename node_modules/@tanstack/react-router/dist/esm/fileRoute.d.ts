import { ParsePathParams } from './link.js';
import { AnyContext, AnyPathParams, AnyRoute, AnySearchSchema, FileBaseRouteOptions, InferAllContext, ResolveAllContext, ResolveAllParamsFromParent, ResolveFullSearchSchema, ResolveFullSearchSchemaInput, ResolveLoaderData, ResolveRouteContext, ResolveSearchSchemaUsed, Route, RouteConstraints, RouteContext, RouteLoaderFn, UpdatableRouteOptions } from './route.js';
import { Assign } from './utils.js';
import { MakeRouteMatch } from './Matches.js';
import { NoInfer } from '@tanstack/react-store';
import { RegisteredRouter } from './router.js';
import { RouteById, RouteIds } from './routeInfo.js';

export interface FileRoutesByPath {
}
export declare function createFileRoute<TFilePath extends keyof FileRoutesByPath, TParentRoute extends AnyRoute = FileRoutesByPath[TFilePath]['parentRoute'], TId extends RouteConstraints['TId'] = FileRoutesByPath[TFilePath]['id'], TPath extends RouteConstraints['TPath'] = FileRoutesByPath[TFilePath]['path'], TFullPath extends RouteConstraints['TFullPath'] = FileRoutesByPath[TFilePath]['fullPath']>(path: TFilePath): <TSearchSchemaInput = Record<string, unknown>, TSearchSchema = {}, TSearchSchemaUsed = ResolveSearchSchemaUsed<TSearchSchemaInput, TSearchSchema>, TFullSearchSchemaInput = Assign<import('./route').InferFullSearchSchemaInput<TParentRoute>, TSearchSchemaUsed>, TFullSearchSchema = Assign<import('./route').InferFullSearchSchema<TParentRoute>, TSearchSchema>, TParams = Record<ParsePathParams<TPath, never>, string>, TAllParams = Assign<import('./route').InferAllParams<TParentRoute>, TParams>, TRouteContextReturn = RouteContext, TRouteContext = ResolveRouteContext<TRouteContextReturn>, TAllContext = Assign<InferAllContext<TParentRoute>, TRouteContext>, TLoaderDeps extends Record<string, any> = {}, TLoaderDataReturn = {}, TLoaderData = ResolveLoaderData<TLoaderDataReturn>, TChildren = unknown>(options?: ({
    validateSearch?: ((input: TSearchSchemaInput) => TSearchSchema) | {
        parse: (input: TSearchSchemaInput) => TSearchSchema;
    } | undefined;
    shouldReload?: boolean | ((match: import('./route').LoaderFnContext<TAllParams, TFullSearchSchema, TAllContext>) => any) | undefined;
    beforeLoad?: ((ctx: import('./route').BeforeLoadContext<TFullSearchSchema, TAllParams, InferAllContext<TParentRoute>>) => Promise<TRouteContextReturn> | TRouteContextReturn | void) | undefined;
    loaderDeps?: ((opts: import('./route').FullSearchSchemaOption<TFullSearchSchema>) => TLoaderDeps) | undefined;
    loader?: ((ctx: import('./route').LoaderFnContext<TAllParams, TLoaderDeps, TAllContext>) => TLoaderDataReturn | Promise<TLoaderDataReturn>) | undefined;
} & import('./route').ParamsOptions<TPath, TParams> & {
    caseSensitive?: boolean;
    wrapInSuspense?: boolean;
    component?: import('./route').RouteComponent;
    errorComponent?: false | null | import('./route').ErrorRouteComponent;
    notFoundComponent?: import('./route').NotFoundRouteComponent;
    pendingComponent?: import('./route').RouteComponent;
    pendingMs?: number;
    pendingMinMs?: number;
    staleTime?: number;
    gcTime?: number;
    preloadStaleTime?: number;
    preloadGcTime?: number;
    preSearchFilters?: import('./route').SearchFilter<TFullSearchSchema, TFullSearchSchema>[] | undefined;
    postSearchFilters?: import('./route').SearchFilter<TFullSearchSchema, TFullSearchSchema>[] | undefined;
    onCatch?: (error: Error, errorInfo: import('react').ErrorInfo) => void;
    onError?: (err: any) => void;
    onEnter?: ((match: import('./Matches').RouteMatch<TId, TAllParams, TFullSearchSchema, TLoaderData, TAllContext, TRouteContext, TLoaderDeps>) => void) | undefined;
    onStay?: ((match: import('./Matches').RouteMatch<TId, TAllParams, TFullSearchSchema, TLoaderData, TAllContext, TRouteContext, TLoaderDeps>) => void) | undefined;
    onLeave?: ((match: import('./Matches').RouteMatch<TId, TAllParams, TFullSearchSchema, TLoaderData, TAllContext, TRouteContext, TLoaderDeps>) => void) | undefined;
    meta?: ((ctx: {
        matches: import('./Matches').RouteMatch<TId, TAllParams, TFullSearchSchema, TLoaderData, TAllContext, TRouteContext, TLoaderDeps>[];
        match: import('./Matches').RouteMatch<TId, TAllParams, TFullSearchSchema, TLoaderData, TAllContext, TRouteContext, TLoaderDeps>;
        params: TAllParams;
        loaderData: TLoaderData;
    }) => Array<import("react").JSX.IntrinsicElements["meta"]>) | undefined;
    links?: () => Array<import("react").JSX.IntrinsicElements["link"]>;
    scripts?: () => Array<import("react").JSX.IntrinsicElements["script"]>;
    headers?: ((ctx: {
        loaderData: TLoaderData;
    }) => Record<string, string>) | undefined;
} & {
    staticData?: import('./route').StaticDataRouteOption;
}) | undefined) => Route<TParentRoute, TPath, TFullPath, TFilePath, TId, TSearchSchemaInput, TSearchSchema, TSearchSchemaUsed, TFullSearchSchemaInput, TFullSearchSchema, TParams, TAllParams, TRouteContextReturn, TRouteContext, TAllContext, TLoaderDeps, TLoaderDataReturn, TLoaderData, TChildren>;
/**
  @deprecated It's no longer recommended to use the `FileRoute` class directly.
  Instead, use `createFileRoute('/path/to/file')(options)` to create a file route.
*/
export declare class FileRoute<TFilePath extends keyof FileRoutesByPath, TParentRoute extends AnyRoute = FileRoutesByPath[TFilePath]['parentRoute'], TId extends RouteConstraints['TId'] = FileRoutesByPath[TFilePath]['id'], TPath extends RouteConstraints['TPath'] = FileRoutesByPath[TFilePath]['path'], TFullPath extends RouteConstraints['TFullPath'] = FileRoutesByPath[TFilePath]['fullPath']> {
    path: TFilePath;
    silent?: boolean;
    constructor(path: TFilePath, _opts?: {
        silent: boolean;
    });
    createRoute: <TSearchSchemaInput = Record<string, unknown>, TSearchSchema = {}, TSearchSchemaUsed = ResolveSearchSchemaUsed<TSearchSchemaInput, TSearchSchema>, TFullSearchSchemaInput = ResolveFullSearchSchemaInput<TParentRoute, TSearchSchemaUsed>, TFullSearchSchema = ResolveFullSearchSchema<TParentRoute, TSearchSchema>, TParams = Record<ParsePathParams<TPath>, string>, TAllParams = ResolveAllParamsFromParent<TParentRoute, TParams>, TRouteContextReturn = RouteContext, TRouteContext = ResolveRouteContext<TRouteContextReturn>, TAllContext = ResolveAllContext<TParentRoute, TRouteContext>, TLoaderDeps extends Record<string, any> = {}, TLoaderDataReturn = {}, TLoaderData = ResolveLoaderData<TLoaderDataReturn>, TChildren = unknown>(options?: FileBaseRouteOptions<TPath, TSearchSchemaInput, TSearchSchema, TFullSearchSchema, TParams, TAllParams, TRouteContextReturn, InferAllContext<TParentRoute>, TAllContext, TLoaderDeps, TLoaderDataReturn> & UpdatableRouteOptions<TId, TAllParams, TFullSearchSchema, TLoaderData, TAllContext, TRouteContext, TLoaderDeps>) => Route<TParentRoute, TPath, TFullPath, TFilePath, TId, TSearchSchemaInput, TSearchSchema, TSearchSchemaUsed, TFullSearchSchemaInput, TFullSearchSchema, TParams, TAllParams, TRouteContextReturn, TRouteContext, TAllContext, TLoaderDeps, TLoaderDataReturn, TLoaderData, TChildren>;
}
/**
  @deprecated It's recommended not to split loaders into separate files.
  Instead, place the loader function in the the main route file, inside the
  `createFileRoute('/path/to/file)(options)` options.
*/
export declare function FileRouteLoader<TFilePath extends keyof FileRoutesByPath, TRoute extends FileRoutesByPath[TFilePath]['preLoaderRoute']>(_path: TFilePath): <TLoaderData>(loaderFn: RouteLoaderFn<TRoute['types']['allParams'], TRoute['types']['loaderDeps'], TRoute['types']['allContext'], TLoaderData>) => RouteLoaderFn<TRoute['types']['allParams'], TRoute['types']['loaderDeps'], TRoute['types']['allContext'], NoInfer<TLoaderData>>;
export type LazyRouteOptions = Pick<UpdatableRouteOptions<string, AnyPathParams, AnySearchSchema, {}, AnyContext, AnyContext, {}>, 'component' | 'errorComponent' | 'pendingComponent' | 'notFoundComponent'>;
export declare class LazyRoute<TRoute extends AnyRoute> {
    options: {
        id: string;
    } & LazyRouteOptions;
    constructor(opts: {
        id: string;
    } & LazyRouteOptions);
    useMatch: <TRouteMatch = MakeRouteMatch<any, TRoute["types"]["id"]>, TSelected = TRouteMatch>(opts?: {
        select?: (match: TRouteMatch) => TSelected;
    }) => TSelected;
    useRouteContext: <TSelected = TRoute["types"]["allContext"]>(opts?: {
        select?: (s: TRoute["types"]["allContext"]) => TSelected;
    }) => TSelected;
    useSearch: <TSelected = TRoute["types"]["fullSearchSchema"]>(opts?: {
        select?: (s: TRoute["types"]["fullSearchSchema"]) => TSelected;
    }) => TSelected;
    useParams: <TSelected = TRoute["types"]["allParams"]>(opts?: {
        select?: (s: TRoute["types"]["allParams"]) => TSelected;
    }) => TSelected;
    useLoaderDeps: <TSelected = TRoute["types"]["loaderDeps"]>(opts?: {
        select?: (s: TRoute["types"]["loaderDeps"]) => TSelected;
    }) => TSelected;
    useLoaderData: <TSelected = TRoute["types"]["loaderData"]>(opts?: {
        select?: (s: TRoute["types"]["loaderData"]) => TSelected;
    }) => TSelected;
    useNavigate: () => import('./useNavigate').UseNavigateResult<string>;
}
export declare function createLazyRoute<TId extends RouteIds<RegisteredRouter['routeTree']>, TRoute extends AnyRoute = RouteById<RegisteredRouter['routeTree'], TId>>(id: TId): (opts: LazyRouteOptions) => LazyRoute<TRoute>;
export declare function createLazyFileRoute<TFilePath extends keyof FileRoutesByPath, TRoute extends FileRoutesByPath[TFilePath]['preLoaderRoute']>(path: TFilePath): (opts: LazyRouteOptions) => LazyRoute<TRoute>;
