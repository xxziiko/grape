{"version":3,"file":"link.js","sources":["../../src/link.tsx"],"sourcesContent":["'use client'\n\nimport * as React from 'react'\nimport { flushSync } from 'react-dom'\nimport { useRouterState } from './useRouterState'\nimport { useRouter } from './useRouter'\nimport { deepEqual, functionalUpdate } from './utils'\nimport { exactPathTest, removeTrailingSlash } from './path'\nimport type { AnyRouter, ParsedLocation } from '.'\nimport type { HistoryState } from '@tanstack/history'\nimport type {\n  AllParams,\n  CatchAllPaths,\n  FullSearchSchema,\n  FullSearchSchemaInput,\n  RouteByPath,\n  RouteByToPath,\n  RoutePaths,\n  RouteToPath,\n} from './routeInfo'\nimport type { RegisteredRouter } from './router'\nimport type {\n  Expand,\n  MakeDifferenceOptional,\n  NoInfer,\n  NonNullableUpdater,\n  PickRequired,\n  Updater,\n  WithoutEmpty,\n} from './utils'\n\nexport type CleanPath<T extends string> = T extends `${infer L}//${infer R}`\n  ? CleanPath<`${CleanPath<L>}/${CleanPath<R>}`>\n  : T extends `${infer L}//`\n    ? `${CleanPath<L>}/`\n    : T extends `//${infer L}`\n      ? `/${CleanPath<L>}`\n      : T\n\nexport type Split<TValue, TIncludeTrailingSlash = true> = TValue extends unknown\n  ? string extends TValue\n    ? Array<string>\n    : TValue extends string\n      ? CleanPath<TValue> extends ''\n        ? []\n        : TIncludeTrailingSlash extends true\n          ? CleanPath<TValue> extends `${infer T}/`\n            ? [...Split<T>, '/']\n            : CleanPath<TValue> extends `/${infer U}`\n              ? Split<U>\n              : CleanPath<TValue> extends `${infer T}/${infer U}`\n                ? [...Split<T>, ...Split<U>]\n                : [TValue]\n          : CleanPath<TValue> extends `${infer T}/${infer U}`\n            ? [...Split<T>, ...Split<U>]\n            : TValue extends string\n              ? [TValue]\n              : never\n      : never\n  : never\n\nexport type ParsePathParams<\n  T extends string,\n  TAcc = never,\n> = T extends `${string}$${infer TPossiblyParam}`\n  ? TPossiblyParam extends `${infer TParam}/${infer TRest}`\n    ? ParsePathParams<TRest, TParam extends '' ? '_splat' : TParam | TAcc>\n    : TPossiblyParam extends ''\n      ? '_splat'\n      : TPossiblyParam | TAcc\n  : TAcc\n\nexport type Join<T, TDelimiter extends string = '/'> = T extends []\n  ? ''\n  : T extends [infer L extends string]\n    ? L\n    : T extends [\n          infer L extends string,\n          ...infer Tail extends [...Array<string>],\n        ]\n      ? CleanPath<`${L}${TDelimiter}${Join<Tail>}`>\n      : never\n\nexport type Last<T extends Array<any>> = T extends [...infer _, infer L]\n  ? L\n  : never\n\nexport type RemoveTrailingSlashes<T> = T extends `${infer R}/` ? R : T\n\nexport type RemoveLeadingSlashes<T> = T extends `/${infer R}` ? R : T\n\nexport type ResolvePaths<TRouter extends AnyRouter, TSearchPath> =\n  RouteByPath<\n    TRouter['routeTree'],\n    RemoveTrailingSlashes<TSearchPath>\n  > extends never\n    ? RouteToPath<TRouter, TRouter['routeTree']>\n    : RouteToPath<\n        TRouter,\n        RouteByPath<TRouter['routeTree'], RemoveTrailingSlashes<TSearchPath>>\n      >\n\nexport type SearchPaths<\n  TRouter extends AnyRouter,\n  TSearchPath extends string,\n  TPaths = ResolvePaths<TRouter, TSearchPath>,\n> = TPaths extends `${RemoveTrailingSlashes<TSearchPath>}${infer TRest}`\n  ? TRest\n  : never\n\nexport type SearchRelativePathAutoComplete<\n  TRouter extends AnyRouter,\n  TTo extends string,\n  TSearchPath extends string,\n> = `${TTo}/${RemoveLeadingSlashes<SearchPaths<TRouter, TSearchPath>>}`\n\nexport type RelativeToParentPathAutoComplete<\n  TRouter extends AnyRouter,\n  TFrom extends string,\n  TTo extends string,\n  TResolvedPath extends string = RemoveTrailingSlashes<\n    ResolveRelativePath<TFrom, TTo>\n  >,\n> =\n  | SearchRelativePathAutoComplete<TRouter, TTo, TResolvedPath>\n  | (TResolvedPath extends '' ? never : `${TTo}/../`)\n\nexport type RelativeToCurrentPathAutoComplete<\n  TRouter extends AnyRouter,\n  TFrom extends string,\n  TTo extends string,\n  TRestTo extends string,\n  TResolvedPath extends\n    string = RemoveTrailingSlashes<`${RemoveTrailingSlashes<TFrom>}/${RemoveLeadingSlashes<TRestTo>}`>,\n> = SearchRelativePathAutoComplete<TRouter, TTo, TResolvedPath>\n\nexport type AbsolutePathAutoComplete<\n  TRouter extends AnyRouter,\n  TFrom extends string,\n> =\n  | (string extends TFrom\n      ? './'\n      : TFrom extends `/`\n        ? never\n        : SearchPaths<TRouter, TFrom> extends ''\n          ? never\n          : './')\n  | (string extends TFrom ? '../' : TFrom extends `/` ? never : '../')\n  | RouteToPath<TRouter, TRouter['routeTree']>\n  | (TFrom extends '/'\n      ? never\n      : string extends TFrom\n        ? never\n        : RemoveLeadingSlashes<SearchPaths<TRouter, TFrom>>)\n\nexport type RelativeToPathAutoComplete<\n  TRouter extends AnyRouter,\n  TFrom extends string,\n  TTo extends string,\n> = TTo extends `..${string}`\n  ? RelativeToParentPathAutoComplete<TRouter, TFrom, RemoveTrailingSlashes<TTo>>\n  : TTo extends `./${infer TRestTTo}`\n    ? RelativeToCurrentPathAutoComplete<\n        TRouter,\n        TFrom,\n        RemoveTrailingSlashes<TTo>,\n        TRestTTo\n      >\n    : AbsolutePathAutoComplete<TRouter, TFrom>\n\nexport type NavigateOptions<\n  TRouter extends AnyRouter = RegisteredRouter,\n  TFrom extends RoutePaths<TRouter['routeTree']> | string = string,\n  TTo extends string = '',\n  TMaskFrom extends RoutePaths<TRouter['routeTree']> | string = TFrom,\n  TMaskTo extends string = '',\n> = ToOptions<TRouter, TFrom, TTo, TMaskFrom, TMaskTo> & NavigateOptionProps\n\nexport interface NavigateOptionProps {\n  // `replace` is a boolean that determines whether the navigation should replace the current history entry or push a new one.\n  replace?: boolean\n  resetScroll?: boolean\n  /** @deprecated All navigations now use startTransition under the hood */\n  startTransition?: boolean\n  // if set to `true`, the router will wrap the resulting navigation in a document.startViewTransition() call.\n  viewTransition?: boolean\n  ignoreBlocker?: boolean\n}\n\nexport type ToOptions<\n  TRouter extends AnyRouter = RegisteredRouter,\n  TFrom extends RoutePaths<TRouter['routeTree']> | string = string,\n  TTo extends string = '',\n  TMaskFrom extends RoutePaths<TRouter['routeTree']> | string = TFrom,\n  TMaskTo extends string = '',\n> = ToSubOptions<TRouter, TFrom, TTo> & MaskOptions<TRouter, TMaskFrom, TMaskTo>\n\nexport interface MaskOptions<\n  in out TRouter extends AnyRouter,\n  in out TMaskFrom extends RoutePaths<TRouter['routeTree']> | string,\n  in out TMaskTo extends string,\n> {\n  _fromLocation?: ParsedLocation\n  mask?: ToMaskOptions<TRouter, TMaskFrom, TMaskTo>\n}\n\nexport type ToMaskOptions<\n  TRouteTree extends AnyRouter = RegisteredRouter,\n  TMaskFrom extends RoutePaths<TRouteTree['routeTree']> | string = string,\n  TMaskTo extends string = '',\n> = ToSubOptions<TRouteTree, TMaskFrom, TMaskTo> & {\n  unmaskOnReload?: boolean\n}\n\nexport type ToSubOptions<\n  TRouter extends AnyRouter = RegisteredRouter,\n  TFrom extends RoutePaths<TRouter['routeTree']> | string = string,\n  TTo extends string = '',\n> = ToSubOptionsProps<TRouter, TFrom, TTo> &\n  SearchParamOptions<TRouter, TFrom, TTo> &\n  PathParamOptions<TRouter, TFrom, TTo>\n\nexport interface ToSubOptionsProps<\n  in out TRouter extends AnyRouter = RegisteredRouter,\n  in out TFrom extends RoutePaths<TRouter['routeTree']> | string = string,\n  in out TTo extends string = '',\n> {\n  to?: ToPathOption<TRouter, TFrom, TTo> & {}\n  hash?: true | Updater<string>\n  state?: true | NonNullableUpdater<HistoryState>\n  // The source route path. This is automatically set when using route-level APIs, but for type-safe relative routing on the router itself, this is required\n  from?: FromPathOption<TRouter, TFrom> & {}\n}\n\nexport type ParamsReducerFn<\n  in out TRouter extends AnyRouter,\n  in out TParamVariant extends ParamVariant,\n  in out TFrom,\n  in out TTo,\n> = (\n  current: Expand<ResolveFromParams<TRouter, TParamVariant, TFrom>>,\n) => Expand<ResolveRelativeToParams<TRouter, TParamVariant, TFrom, TTo>>\n\ntype ParamsReducer<\n  TRouter extends AnyRouter,\n  TParamVariant extends ParamVariant,\n  TFrom,\n  TTo,\n> =\n  | Expand<ResolveRelativeToParams<TRouter, TParamVariant, TFrom, TTo>>\n  | (ParamsReducerFn<TRouter, TParamVariant, TFrom, TTo> & {})\n\ntype ParamVariant = 'PATH' | 'SEARCH'\n\nexport type ResolveRoute<\n  TRouter extends AnyRouter,\n  TFrom,\n  TTo,\n  TPath = ResolveRelativePath<TFrom, TTo>,\n> = TPath extends string\n  ? string extends TTo\n    ? RouteByPath<TRouter['routeTree'], TPath>\n    : RouteByToPath<TRouter, TPath>\n  : never\n\ntype ResolveFromParamType<TParamVariant extends ParamVariant> =\n  TParamVariant extends 'PATH' ? 'allParams' : 'fullSearchSchema'\n\ntype ResolveFromAllParams<\n  TRouter extends AnyRouter,\n  TParamVariant extends ParamVariant,\n> = TParamVariant extends 'PATH'\n  ? AllParams<TRouter['routeTree']>\n  : FullSearchSchema<TRouter['routeTree']>\n\ntype ResolveFromParams<\n  TRouter extends AnyRouter,\n  TParamVariant extends ParamVariant,\n  TFrom,\n> = string extends TFrom\n  ? ResolveFromAllParams<TRouter, TParamVariant>\n  : RouteByPath<\n      TRouter['routeTree'],\n      TFrom\n    >['types'][ResolveFromParamType<TParamVariant>]\n\ntype ResolveToParamType<TParamVariant extends ParamVariant> =\n  TParamVariant extends 'PATH' ? 'allParams' : 'fullSearchSchemaInput'\n\ntype ResolveAllToParams<\n  TRouter extends AnyRouter,\n  TParamVariant extends ParamVariant,\n> = TParamVariant extends 'PATH'\n  ? AllParams<TRouter['routeTree']>\n  : FullSearchSchemaInput<TRouter['routeTree']>\n\nexport type ResolveToParams<\n  TRouter extends AnyRouter,\n  TParamVariant extends ParamVariant,\n  TFrom,\n  TTo,\n> =\n  ResolveRelativePath<TFrom, TTo> extends infer TPath\n    ? string extends TPath\n      ? ResolveAllToParams<TRouter, TParamVariant>\n      : TPath extends CatchAllPaths\n        ? ResolveAllToParams<TRouter, TParamVariant>\n        : ResolveRoute<\n            TRouter,\n            TFrom,\n            TTo\n          >['types'][ResolveToParamType<TParamVariant>]\n    : never\n\ntype ResolveRelativeToParams<\n  TRouter extends AnyRouter,\n  TParamVariant extends ParamVariant,\n  TFrom,\n  TTo,\n  TToParams = ResolveToParams<TRouter, TParamVariant, TFrom, TTo>,\n> = TParamVariant extends 'SEARCH'\n  ? TToParams\n  : string extends TFrom\n    ? TToParams\n    : MakeDifferenceOptional<\n        ResolveFromParams<TRouter, TParamVariant, TFrom>,\n        TToParams\n      >\n\ninterface MakeOptionalSearchParams<\n  in out TRouter extends AnyRouter,\n  in out TFrom,\n  in out TTo,\n> {\n  search?: true | (ParamsReducer<TRouter, 'SEARCH', TFrom, TTo> & {})\n}\n\ninterface MakeOptionalPathParams<\n  in out TRouter extends AnyRouter,\n  in out TFrom,\n  in out TTo,\n> {\n  params?: true | (ParamsReducer<TRouter, 'PATH', TFrom, TTo> & {})\n}\n\ntype MakeRequiredParamsReducer<\n  TRouter extends AnyRouter,\n  TParamVariant extends ParamVariant,\n  TFrom,\n  TTo,\n> =\n  | (string extends TFrom\n      ? never\n      : ResolveFromParams<TRouter, TParamVariant, TFrom> extends WithoutEmpty<\n            PickRequired<\n              ResolveRelativeToParams<TRouter, TParamVariant, TFrom, TTo>\n            >\n          >\n        ? true\n        : never)\n  | (ParamsReducer<TRouter, TParamVariant, TFrom, TTo> & {})\n\nexport interface MakeRequiredPathParams<\n  in out TRouter extends AnyRouter,\n  in out TFrom,\n  in out TTo,\n> {\n  params: MakeRequiredParamsReducer<TRouter, 'PATH', TFrom, TTo> & {}\n}\n\nexport interface MakeRequiredSearchParams<\n  in out TRouter extends AnyRouter,\n  in out TFrom,\n  in out TTo,\n> {\n  search: MakeRequiredParamsReducer<TRouter, 'SEARCH', TFrom, TTo> & {}\n}\n\nexport type IsRequiredParams<TParams> =\n  Record<never, never> extends TParams ? never : true\n\nexport type IsRequired<\n  TRouter extends AnyRouter,\n  TParamVariant extends ParamVariant,\n  TFrom,\n  TTo,\n> =\n  ResolveRelativePath<TFrom, TTo> extends infer TPath\n    ? string extends TPath\n      ? never\n      : TPath extends CatchAllPaths\n        ? never\n        : IsRequiredParams<\n            ResolveRelativeToParams<TRouter, TParamVariant, TFrom, TTo>\n          >\n    : never\n\nexport type SearchParamOptions<\n  TRouter extends AnyRouter,\n  TFrom,\n  TTo extends string,\n> =\n  IsRequired<TRouter, 'SEARCH', TFrom, TTo> extends never\n    ? MakeOptionalSearchParams<TRouter, TFrom, TTo>\n    : MakeRequiredSearchParams<TRouter, TFrom, TTo>\n\nexport type PathParamOptions<\n  TRouter extends AnyRouter,\n  TFrom,\n  TTo extends string,\n> =\n  IsRequired<TRouter, 'PATH', TFrom, TTo> extends never\n    ? MakeOptionalPathParams<TRouter, TFrom, TTo>\n    : MakeRequiredPathParams<TRouter, TFrom, TTo>\n\nexport type ToPathOption<\n  TRouter extends AnyRouter = AnyRouter,\n  TFrom extends string = string,\n  TTo extends string = string,\n> =\n  | CheckPath<TRouter, TTo, never, TFrom, TTo>\n  | RelativeToPathAutoComplete<\n      TRouter,\n      NoInfer<TFrom> extends string ? NoInfer<TFrom> : '',\n      NoInfer<TTo> & string\n    >\n\nexport type CheckFromPath<\n  TRouter extends AnyRouter,\n  TPass,\n  TFail,\n  TFrom,\n> = string extends TFrom\n  ? TPass\n  : RouteByPath<TRouter['routeTree'], TFrom> extends never\n    ? TFail\n    : TPass\n\nexport type FromPathOption<TRouter extends AnyRouter, TFrom> =\n  | CheckFromPath<\n      TRouter,\n      string extends TFrom ? TFrom & {} : TFrom,\n      never,\n      TFrom\n    >\n  | RoutePaths<TRouter['routeTree']>\n\nexport interface ActiveOptions {\n  exact?: boolean\n  includeHash?: boolean\n  includeSearch?: boolean\n}\n\nexport type LinkOptions<\n  TRouter extends AnyRouter = RegisteredRouter,\n  TFrom extends string = string,\n  TTo extends string = '',\n  TMaskFrom extends string = TFrom,\n  TMaskTo extends string = '',\n> = NavigateOptions<TRouter, TFrom, TTo, TMaskFrom, TMaskTo> & LinkOptionsProps\n\nexport interface LinkOptionsProps {\n  // The standard anchor tag target attribute\n  target?: HTMLAnchorElement['target']\n  // Defaults to `{ exact: false, includeHash: false }`\n  activeOptions?: ActiveOptions\n  // If set, will preload the linked route on hover and cache it for this many milliseconds in hopes that the user will eventually navigate there.\n  preload?: false | 'intent'\n  // Delay intent preloading by this many milliseconds. If the intent exits before this delay, the preload will be cancelled.\n  preloadDelay?: number\n  // If true, will render the link without the href attribute\n  disabled?: boolean\n}\n\nexport type CheckPath<TRouter extends AnyRouter, TPass, TFail, TFrom, TTo> =\n  string extends ResolveRelativePath<TFrom, TTo>\n    ? TPass\n    : ResolveRelativePath<TFrom, TTo> extends CatchAllPaths\n      ? TPass\n      : ResolveRoute<TRouter, TFrom, TTo> extends never\n        ? TFail\n        : TPass\n\nexport type ResolveRelativePath<TFrom, TTo = '.'> = string extends TFrom\n  ? TTo\n  : string extends TTo\n    ? TFrom\n    : TFrom extends string\n      ? TTo extends string\n        ? TTo extends '.'\n          ? TFrom\n          : TTo extends `./`\n            ? Join<[TFrom, '/']>\n            : TTo extends `./${infer TRest}`\n              ? ResolveRelativePath<TFrom, TRest>\n              : TTo extends `/${infer TRest}`\n                ? TTo\n                : Split<TTo> extends ['..', ...infer ToRest]\n                  ? Split<TFrom> extends [...infer FromRest, infer FromTail]\n                    ? ToRest extends ['/']\n                      ? Join<['/', ...FromRest, '/']>\n                      : ResolveRelativePath<Join<FromRest>, Join<ToRest>>\n                    : never\n                  : Split<TTo> extends ['.', ...infer ToRest]\n                    ? ToRest extends ['/']\n                      ? Join<[TFrom, '/']>\n                      : ResolveRelativePath<TFrom, Join<ToRest>>\n                    : CleanPath<Join<['/', ...Split<TFrom>, ...Split<TTo>]>>\n        : never\n      : never\n\n// type Test1 = ResolveRelativePath<'/', '/posts'>\n// //   ^?\n// type Test4 = ResolveRelativePath<'/posts/1/comments', '../..'>\n// //   ^?\n// type Test5 = ResolveRelativePath<'/posts/1/comments', '../../..'>\n// //   ^?\n// type Test6 = ResolveRelativePath<'/posts/1/comments', './1'>\n// //   ^?\n// type Test7 = ResolveRelativePath<'/posts/1/comments', './1/2'>\n// //   ^?\n// type Test8 = ResolveRelativePath<'/posts/1/comments', '../edit'>\n// //   ^?\n// type Test9 = ResolveRelativePath<'/posts/1/comments', '1'>\n// //   ^?\n// type Test10 = ResolveRelativePath<'/posts/1/comments', './1'>\n// //   ^?\n// type Test11 = ResolveRelativePath<'/posts/1/comments', './1/2'>\n// //   ^?\n\ntype LinkCurrentTargetElement = {\n  preloadTimeout?: null | ReturnType<typeof setTimeout>\n}\n\nconst preloadWarning = 'Error preloading route! ☝️'\n\nexport function useLinkProps<\n  TRouter extends AnyRouter = RegisteredRouter,\n  TFrom extends RoutePaths<TRouter['routeTree']> | string = string,\n  TTo extends string = '',\n  TMaskFrom extends RoutePaths<TRouter['routeTree']> | string = TFrom,\n  TMaskTo extends string = '',\n>(\n  options: UseLinkPropsOptions<TRouter, TFrom, TTo, TMaskFrom, TMaskTo>,\n): React.AnchorHTMLAttributes<HTMLAnchorElement> {\n  const router = useRouter()\n  const [isTransitioning, setIsTransitioning] = React.useState(false)\n\n  const {\n    // custom props\n    activeProps = () => ({ className: 'active' }),\n    inactiveProps = () => ({}),\n    activeOptions,\n    hash,\n    search,\n    params,\n    to,\n    state,\n    mask,\n    preload: userPreload,\n    preloadDelay: userPreloadDelay,\n    replace,\n    startTransition,\n    resetScroll,\n    viewTransition,\n    // element props\n    children,\n    target,\n    disabled,\n    style,\n    className,\n    onClick,\n    onFocus,\n    onMouseEnter,\n    onMouseLeave,\n    onTouchStart,\n    ignoreBlocker,\n    ...rest\n  } = options\n\n  // If this link simply reloads the current route,\n  // make sure it has a new key so it will trigger a data refresh\n\n  // If this `to` is a valid external URL, return\n  // null for LinkUtils\n\n  let type: 'internal' | 'external' = 'internal'\n\n  try {\n    new URL(`${to}`)\n    type = 'external'\n  } catch {}\n\n  const next = router.buildLocation(options as any)\n  const preload = userPreload ?? router.options.defaultPreload\n  const preloadDelay =\n    userPreloadDelay ?? router.options.defaultPreloadDelay ?? 0\n\n  const isActive = useRouterState({\n    select: (s) => {\n      // Compare path/hash for matches\n      const currentPathSplit = removeTrailingSlash(\n        s.location.pathname,\n        router.basepath,\n      ).split('/')\n      const nextPathSplit = removeTrailingSlash(\n        next.pathname,\n        router.basepath,\n      ).split('/')\n      const pathIsFuzzyEqual = nextPathSplit.every(\n        (d, i) => d === currentPathSplit[i],\n      )\n      // Combine the matches based on user router.options\n      const pathTest = activeOptions?.exact\n        ? exactPathTest(s.location.pathname, next.pathname, router.basepath)\n        : pathIsFuzzyEqual\n      const hashTest = activeOptions?.includeHash\n        ? s.location.hash === next.hash\n        : true\n      const searchTest =\n        (activeOptions?.includeSearch ?? true)\n          ? deepEqual(s.location.search, next.search, !activeOptions?.exact)\n          : true\n\n      // The final \"active\" test\n      return pathTest && hashTest && searchTest\n    },\n  })\n\n  if (type === 'external') {\n    return {\n      ...rest,\n      type,\n      href: to,\n      ...(children && { children }),\n      ...(target && { target }),\n      ...(disabled && { disabled }),\n      ...(style && { style }),\n      ...(className && { className }),\n      ...(onClick && { onClick }),\n      ...(onFocus && { onFocus }),\n      ...(onMouseEnter && { onMouseEnter }),\n      ...(onMouseLeave && { onMouseLeave }),\n      ...(onTouchStart && { onTouchStart }),\n    }\n  }\n\n  // The click handler\n  const handleClick = (e: MouseEvent) => {\n    if (\n      !disabled &&\n      !isCtrlEvent(e) &&\n      !e.defaultPrevented &&\n      (!target || target === '_self') &&\n      e.button === 0\n    ) {\n      e.preventDefault()\n\n      flushSync(() => {\n        setIsTransitioning(true)\n      })\n\n      const unsub = router.subscribe('onResolved', () => {\n        unsub()\n        setIsTransitioning(false)\n      })\n\n      // All is well? Navigate!\n      router.commitLocation({\n        ...next,\n        replace,\n        resetScroll,\n        startTransition,\n        viewTransition,\n        ignoreBlocker,\n      })\n    }\n  }\n\n  const doPreload = () => {\n    router.preloadRoute(options as any).catch((err) => {\n      console.warn(err)\n      console.warn(preloadWarning)\n    })\n  }\n\n  // The click handler\n  const handleFocus = (e: MouseEvent) => {\n    if (disabled) return\n    if (preload) {\n      doPreload()\n    }\n  }\n\n  const handleTouchStart = handleFocus\n\n  const handleEnter = (e: MouseEvent) => {\n    if (disabled) return\n    const eventTarget = (e.target || {}) as LinkCurrentTargetElement\n\n    if (preload) {\n      if (eventTarget.preloadTimeout) {\n        return\n      }\n\n      eventTarget.preloadTimeout = setTimeout(() => {\n        eventTarget.preloadTimeout = null\n        doPreload()\n      }, preloadDelay)\n    }\n  }\n\n  const handleLeave = (e: MouseEvent) => {\n    if (disabled) return\n    const eventTarget = (e.target || {}) as LinkCurrentTargetElement\n\n    if (eventTarget.preloadTimeout) {\n      clearTimeout(eventTarget.preloadTimeout)\n      eventTarget.preloadTimeout = null\n    }\n  }\n\n  const composeHandlers =\n    (handlers: Array<undefined | ((e: any) => void)>) =>\n    (e: { persist?: () => void; defaultPrevented: boolean }) => {\n      e.persist?.()\n      handlers.filter(Boolean).forEach((handler) => {\n        if (e.defaultPrevented) return\n        handler!(e)\n      })\n    }\n\n  // Get the active props\n  const resolvedActiveProps: React.HTMLAttributes<HTMLAnchorElement> = isActive\n    ? (functionalUpdate(activeProps as any, {}) ?? {})\n    : {}\n\n  // Get the inactive props\n  const resolvedInactiveProps: React.HTMLAttributes<HTMLAnchorElement> =\n    isActive ? {} : functionalUpdate(inactiveProps, {})\n\n  const resolvedClassName = [\n    className,\n    resolvedActiveProps.className,\n    resolvedInactiveProps.className,\n  ]\n    .filter(Boolean)\n    .join(' ')\n\n  const resolvedStyle = {\n    ...style,\n    ...resolvedActiveProps.style,\n    ...resolvedInactiveProps.style,\n  }\n\n  return {\n    ...resolvedActiveProps,\n    ...resolvedInactiveProps,\n    ...rest,\n    href: disabled\n      ? undefined\n      : next.maskedLocation\n        ? router.history.createHref(next.maskedLocation.href)\n        : router.history.createHref(next.href),\n    onClick: composeHandlers([onClick, handleClick]),\n    onFocus: composeHandlers([onFocus, handleFocus]),\n    onMouseEnter: composeHandlers([onMouseEnter, handleEnter]),\n    onMouseLeave: composeHandlers([onMouseLeave, handleLeave]),\n    onTouchStart: composeHandlers([onTouchStart, handleTouchStart]),\n    disabled: !!disabled,\n    target,\n    ...(Object.keys(resolvedStyle).length && { style: resolvedStyle }),\n    ...(resolvedClassName && { className: resolvedClassName }),\n    ...(disabled && {\n      role: 'link',\n      'aria-disabled': true,\n    }),\n    ...(isActive && { 'data-status': 'active', 'aria-current': 'page' }),\n    ...(isTransitioning && { 'data-transitioning': 'transitioning' }),\n  }\n}\n\nexport type UseLinkPropsOptions<\n  TRouter extends AnyRouter = RegisteredRouter,\n  TFrom extends RoutePaths<TRouter['routeTree']> | string = string,\n  TTo extends string = '',\n  TMaskFrom extends RoutePaths<TRouter['routeTree']> | string = TFrom,\n  TMaskTo extends string = '',\n> = ActiveLinkOptions<TRouter, TFrom, TTo, TMaskFrom, TMaskTo> &\n  React.AnchorHTMLAttributes<HTMLAnchorElement>\n\nexport type ActiveLinkOptions<\n  TRouter extends AnyRouter = RegisteredRouter,\n  TFrom extends string = string,\n  TTo extends string = '',\n  TMaskFrom extends string = TFrom,\n  TMaskTo extends string = '',\n> = LinkOptions<TRouter, TFrom, TTo, TMaskFrom, TMaskTo> & ActiveLinkOptionProps\n\nexport interface ActiveLinkOptionProps {\n  /**\n   * A function that returns additional props for the `active` state of this link.\n   * These props override other props passed to the link (`style`'s are merged, `className`'s are concatenated)\n   */\n  activeProps?:\n    | React.AnchorHTMLAttributes<HTMLAnchorElement>\n    | (() => React.AnchorHTMLAttributes<HTMLAnchorElement>)\n  /**\n   * A function that returns additional props for the `inactive` state of this link.\n   * These props override other props passed to the link (`style`'s are merged, `className`'s are concatenated)\n   */\n  inactiveProps?:\n    | React.AnchorHTMLAttributes<HTMLAnchorElement>\n    | (() => React.AnchorHTMLAttributes<HTMLAnchorElement>)\n}\n\nexport type LinkProps<\n  TRouter extends AnyRouter = RegisteredRouter,\n  TFrom extends string = string,\n  TTo extends string = '',\n  TMaskFrom extends string = TFrom,\n  TMaskTo extends string = '',\n> = ActiveLinkOptions<TRouter, TFrom, TTo, TMaskFrom, TMaskTo> &\n  LinkPropsChildren\n\nexport interface LinkPropsChildren {\n  // If a function is passed as a child, it will be given the `isActive` boolean to aid in further styling on the element it returns\n  children?:\n    | React.ReactNode\n    | ((state: {\n        isActive: boolean\n        isTransitioning: boolean\n      }) => React.ReactNode)\n}\n\ntype LinkComponentReactProps<TComp> = React.PropsWithoutRef<\n  TComp extends React.FC<infer TProps> | React.Component<infer TProps>\n    ? TProps\n    : TComp extends keyof React.JSX.IntrinsicElements\n      ? Omit<React.HTMLProps<TComp>, 'children' | 'preload'>\n      : never\n> &\n  React.RefAttributes<\n    TComp extends\n      | React.FC<{ ref: infer TRef }>\n      | React.Component<{ ref: infer TRef }>\n      ? TRef\n      : TComp extends keyof React.JSX.IntrinsicElements\n        ? React.ComponentRef<TComp>\n        : never\n  >\n\nexport type LinkComponentProps<\n  TComp,\n  TRouter extends AnyRouter = RegisteredRouter,\n  TFrom extends string = string,\n  TTo extends string = '',\n  TMaskFrom extends string = TFrom,\n  TMaskTo extends string = '',\n> = LinkComponentReactProps<TComp> &\n  LinkProps<TRouter, TFrom, TTo, TMaskFrom, TMaskTo>\n\nexport type LinkComponent<TComp> = <\n  TRouter extends RegisteredRouter = RegisteredRouter,\n  TFrom extends string = string,\n  TTo extends string = '',\n  TMaskFrom extends string = TFrom,\n  TMaskTo extends string = '',\n>(\n  props: LinkComponentProps<TComp, TRouter, TFrom, TTo, TMaskFrom, TMaskTo>,\n) => React.ReactElement\n\nexport function createLink<const TComp>(Comp: TComp): LinkComponent<TComp> {\n  return React.forwardRef(function CreatedLink(props, ref) {\n    return <Link {...(props as any)} _asChild={Comp} ref={ref} />\n  }) as any\n}\n\nexport const Link: LinkComponent<'a'> = React.forwardRef((props: any, ref) => {\n  const { _asChild, ...rest } = props\n  const { type, ...linkProps } = useLinkProps(rest)\n\n  const children =\n    typeof rest.children === 'function'\n      ? rest.children({\n          isActive: (linkProps as any)['data-status'] === 'active',\n        })\n      : rest.children\n\n  if (typeof _asChild === 'undefined') {\n    // the ReturnType of useLinkProps returns the correct type for a <a> element, not a general component that has a delete prop\n    // @ts-expect-error\n    delete linkProps.disabled\n  }\n\n  return React.createElement(\n    _asChild ? _asChild : 'a',\n    {\n      ...linkProps,\n      ref,\n    },\n    children,\n  )\n}) as any\n\nfunction isCtrlEvent(e: MouseEvent) {\n  return !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey)\n}\n"],"names":[],"mappings":";;;;;;;;AAshBA;AAEO;AASL;AACA;AAEM;AAAA;AAAA;;AAGmB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACS;AACK;AACd;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACG;AASL;AAEI;AACE;AACG;AAAA;AACD;AAEF;AACA;AACN;AAGA;AAAgC;AAG5B;AAAyB;AACZ;AACJ;AAET;AAAsB;AACf;AACE;AAET;AAAuC;AACH;AAG9B;AAGN;AAGA;AAMA;AAA+B;AACjC;AAGF;AACS;AAAA;AACF;AACH;AACM;AACqB;AACJ;AACI;AACN;AACQ;AACJ;AACA;AACU;AACA;AACA;AAAA;AAKjC;AACJ;AAOE;AAEA;AACE;AAAuB;AAGzB;AACQ;AACN;AAAwB;AAI1B;AAAsB;AACjB;AACH;AACA;AACA;AACA;AACA;AACD;AACH;AAGF;AACE;AACE;AACA;AAA2B;AAC5B;AAIG;AACJ;AACA;AACY;;AACZ;AAGF;AAEM;AACJ;AACM;AAEN;AACE;AACE;AAAA;AAGU;AACV;AACU;;AACG;AACjB;AAGI;AACJ;AACM;AAEN;AACE;AACA;AAA6B;AAC/B;AAGF;;AAGI;AACA;AACE;AACA;AAAU;AACX;AAIC;AAKN;AAGA;AAA0B;AACxB;AACoB;AACE;AAKxB;AAAsB;AACjB;AACoB;AACE;AAGpB;AAAA;AACF;AACA;AACA;AAKsC;AACM;AACA;AACU;AACA;AACK;AAClD;AACZ;AACgE;AACR;AACxC;AACR;AACW;AACnB;AACkE;AACH;AAEnE;AA4FO;AACL;AACE;AAA2D;AAE/D;AAEO;AACL;AACA;AAEA;AAEoB;AACoC;AAIpD;AAGF;AAAiB;AAGnB;AAAa;AACW;AACtB;AACK;AACH;AACF;AACA;AAEJ;AAEA;AACS;AACT;;;;;;"}