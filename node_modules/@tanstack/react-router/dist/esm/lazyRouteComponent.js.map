{"version":3,"file":"lazyRouteComponent.js","sources":["../../src/lazyRouteComponent.tsx"],"sourcesContent":["import * as React from 'react'\nimport type { AsyncRouteComponent } from './route'\n\n// If the load fails due to module not found, it may mean a new version of\n// the build was deployed and the user's browser is still using an old version.\n// If this happens, the old version in the user's browser would have an outdated\n// URL to the lazy module.\n// In that case, we want to attempt one window refresh to get the latest.\nfunction isModuleNotFoundError(error: any): boolean {\n  return (\n    typeof error?.message === 'string' &&\n    /Failed to fetch dynamically imported module/.test(error.message)\n  )\n}\n\nexport function lazyRouteComponent<\n  T extends Record<string, any>,\n  TKey extends keyof T = 'default',\n>(\n  importer: () => Promise<T>,\n  exportName?: TKey,\n): T[TKey] extends (props: infer TProps) => any\n  ? AsyncRouteComponent<TProps>\n  : never {\n  let loadPromise: Promise<any> | undefined\n  let comp: T[TKey] | T['default']\n  let error: any\n\n  const load = () => {\n    if (!loadPromise) {\n      loadPromise = importer()\n        .then((res) => {\n          loadPromise = undefined\n          comp = res[exportName ?? 'default']\n        })\n        .catch((err) => {\n          error = err\n        })\n    }\n\n    return loadPromise\n  }\n\n  const lazyComp = function Lazy(props: any) {\n    // Now that we're out of preload and into actual render path,\n    // throw the error if it was a module not found error during preload\n    if (error) {\n      if (isModuleNotFoundError(error)) {\n        // We don't want an error thrown from preload in this case, because\n        // there's nothing we want to do about module not found during preload.\n        // Record the error, recover the promise with a null return,\n        // and we will attempt module not found resolution during the render path.\n\n        if (\n          error instanceof Error &&\n          typeof window !== 'undefined' &&\n          typeof sessionStorage !== 'undefined'\n        ) {\n          // Again, we want to reload one time on module not found error and not enter\n          // a reload loop if there is some other issue besides an old deploy.\n          // That's why we store our reload attempt in sessionStorage.\n          // Use error.message as key because it contains the module path that failed.\n          const storageKey = `tanstack_router_reload:${error.message}`\n          if (!sessionStorage.getItem(storageKey)) {\n            sessionStorage.setItem(storageKey, '1')\n            window.location.reload()\n\n            // Return empty component while we wait for window to reload\n            return {\n              default: () => null,\n            }\n          }\n        }\n      }\n\n      // Otherwise, just throw the error\n      throw error\n    }\n\n    if (!comp) {\n      throw load()\n    }\n\n    return React.createElement(comp, props)\n  }\n\n  ;(lazyComp as any).preload = load\n\n  return lazyComp as any\n}\n"],"names":[],"mappings":";AAQA,SAAS,sBAAsB,OAAqB;AAClD,SACE,QAAO,+BAAO,aAAY,YAC1B,8CAA8C,KAAK,MAAM,OAAO;AAEpE;AAEgB,SAAA,mBAId,UACA,YAGQ;AACJ,MAAA;AACA,MAAA;AACA,MAAA;AAEJ,QAAM,OAAO,MAAM;AACjB,QAAI,CAAC,aAAa;AAChB,oBAAc,SAAS,EACpB,KAAK,CAAC,QAAQ;AACC,sBAAA;AACP,eAAA,IAAI,cAAc,SAAS;AAAA,MAAA,CACnC,EACA,MAAM,CAAC,QAAQ;AACN,gBAAA;AAAA,MAAA,CACT;AAAA,IACL;AAEO,WAAA;AAAA,EAAA;AAGH,QAAA,WAAW,SAAS,KAAK,OAAY;AAGzC,QAAI,OAAO;AACL,UAAA,sBAAsB,KAAK,GAAG;AAMhC,YACE,iBAAiB,SACjB,OAAO,WAAW,eAClB,OAAO,mBAAmB,aAC1B;AAKM,gBAAA,aAAa,0BAA0B,MAAM,OAAO;AAC1D,cAAI,CAAC,eAAe,QAAQ,UAAU,GAAG;AACxB,2BAAA,QAAQ,YAAY,GAAG;AACtC,mBAAO,SAAS;AAGT,mBAAA;AAAA,cACL,SAAS,MAAM;AAAA,YAAA;AAAA,UAEnB;AAAA,QACF;AAAA,MACF;AAGM,YAAA;AAAA,IACR;AAEA,QAAI,CAAC,MAAM;AACT,YAAM,KAAK;AAAA,IACb;AAEO,WAAA,MAAM,cAAc,MAAM,KAAK;AAAA,EAAA;AAGtC,WAAiB,UAAU;AAEtB,SAAA;AACT;"}