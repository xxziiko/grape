import { AnyRouter, RegisteredRouter } from './router.js';
import { AnyRoute, ReactNode, StaticDataRouteOption } from './route.js';
import { ResolveRelativePath, ToOptions } from './link.js';
import { AllContext, AllLoaderData, AllParams, FullSearchSchema, ParseRoute, RouteById, RouteByPath, RouteIds, RoutePaths } from './routeInfo.js';
import { ControlledPromise, DeepPartial, NoInfer } from './utils.js';
import * as React from 'react';
export interface RouteMatch<TRouteId, TAllParams, TFullSearchSchema, TLoaderData, TAllContext, TRouteContext, TLoaderDeps> {
    id: string;
    routeId: TRouteId;
    index: number;
    pathname: string;
    params: TAllParams;
    status: 'pending' | 'success' | 'error' | 'redirected' | 'notFound';
    isFetching: false | 'beforeLoad' | 'loader';
    error: unknown;
    paramsError: unknown;
    searchError: unknown;
    updatedAt: number;
    componentsPromise?: Promise<Array<void>>;
    loadPromise?: ControlledPromise<void>;
    beforeLoadPromise?: ControlledPromise<void>;
    loaderPromise?: ControlledPromise<void>;
    loaderData?: TLoaderData;
    routeContext: TRouteContext;
    context: TAllContext;
    search: TFullSearchSchema;
    fetchCount: number;
    abortController: AbortController;
    cause: 'preload' | 'enter' | 'stay';
    loaderDeps: TLoaderDeps;
    preload: boolean;
    invalid: boolean;
    meta?: Array<React.JSX.IntrinsicElements['meta']>;
    links?: Array<React.JSX.IntrinsicElements['link']>;
    scripts?: Array<React.JSX.IntrinsicElements['script']>;
    headers?: Record<string, string>;
    globalNotFound?: boolean;
    staticData: StaticDataRouteOption;
    minPendingPromise?: ControlledPromise<void>;
    pendingTimeout?: ReturnType<typeof setTimeout>;
}
export type MakeRouteMatch<TRouteTree extends AnyRoute = RegisteredRouter['routeTree'], TRouteId = ParseRoute<TRouteTree>['id'], TStrict extends boolean = true, TTypes extends AnyRoute['types'] = RouteById<TRouteTree, TRouteId>['types'], TAllParams = TStrict extends false ? AllParams<TRouteTree> : TTypes['allParams'], TFullSearchSchema = TStrict extends false ? FullSearchSchema<TRouteTree> : TTypes['fullSearchSchema'], TLoaderData = TStrict extends false ? AllLoaderData<TRouteTree> : TTypes['loaderData'], TAllContext = TStrict extends false ? AllContext<TRouteTree> : TTypes['allContext'], TRouteContext = TTypes['routeContext'], TLoaderDeps = TTypes['loaderDeps']> = RouteMatch<TRouteId, TAllParams, TFullSearchSchema, TLoaderData, TAllContext, TRouteContext, TLoaderDeps>;
export type AnyRouteMatch = RouteMatch<any, any, any, any, any, any, any>;
export declare function Matches(): import("react/jsx-runtime").JSX.Element;
export interface MatchRouteOptions {
    pending?: boolean;
    caseSensitive?: boolean;
    includeSearch?: boolean;
    fuzzy?: boolean;
}
export type UseMatchRouteOptions<TRouter extends AnyRouter = RegisteredRouter, TFrom extends RoutePaths<TRouter['routeTree']> = RoutePaths<TRouter['routeTree']>, TTo extends string = '', TMaskFrom extends RoutePaths<TRouter['routeTree']> = TFrom, TMaskTo extends string = '', TOptions extends ToOptions<TRouter, TFrom, TTo, TMaskFrom, TMaskTo> = ToOptions<TRouter, TFrom, TTo, TMaskFrom, TMaskTo>, TRelaxedOptions = Omit<TOptions, 'search' | 'params'> & DeepPartial<Pick<TOptions, 'search' | 'params'>>> = TRelaxedOptions & MatchRouteOptions;
export declare function useMatchRoute<TRouter extends AnyRouter = RegisteredRouter>(): <TFrom extends RoutePaths<TRouter["routeTree"]> | string = string, TTo extends string = "", TMaskFrom extends RoutePaths<TRouter["routeTree"]> | string = TFrom, TMaskTo extends string = "", TResolved extends string = ResolveRelativePath<TFrom, NoInfer<TTo>>>(opts: UseMatchRouteOptions<TRouter, TFrom, TTo, TMaskFrom, TMaskTo>) => false | RouteByPath<TRouter["routeTree"], TResolved>["types"]["allParams"];
export type MakeMatchRouteOptions<TRouter extends AnyRouter = RegisteredRouter, TFrom extends RoutePaths<TRouter['routeTree']> = RoutePaths<TRouter['routeTree']>, TTo extends string = '', TMaskFrom extends RoutePaths<TRouter['routeTree']> = TFrom, TMaskTo extends string = ''> = UseMatchRouteOptions<TRouter, TFrom, TTo, TMaskFrom, TMaskTo> & {
    children?: ((params?: RouteByPath<TRouter['routeTree'], ResolveRelativePath<TFrom, NoInfer<TTo>>>['types']['allParams']) => ReactNode) | React.ReactNode;
};
export declare function MatchRoute<TRouter extends AnyRouter = RegisteredRouter, TFrom extends RoutePaths<TRouter['routeTree']> = RoutePaths<TRouter['routeTree']>, TTo extends string = '', TMaskFrom extends RoutePaths<TRouter['routeTree']> = TFrom, TMaskTo extends string = ''>(props: MakeMatchRouteOptions<TRouter, TFrom, TTo, TMaskFrom, TMaskTo>): any;
export declare function useMatches<TRouteTree extends AnyRoute = RegisteredRouter['routeTree'], TRouteId extends RouteIds<TRouteTree> = ParseRoute<TRouteTree>['id'], TRouteMatch = MakeRouteMatch<TRouteTree, TRouteId>, T = Array<TRouteMatch>>(opts?: {
    select?: (matches: Array<TRouteMatch>) => T;
}): T;
export declare function useParentMatches<TRouteTree extends AnyRoute = RegisteredRouter['routeTree'], TRouteId extends RouteIds<TRouteTree> = ParseRoute<TRouteTree>['id'], TRouteMatch = MakeRouteMatch<TRouteTree, TRouteId>, T = Array<TRouteMatch>>(opts?: {
    select?: (matches: Array<TRouteMatch>) => T;
}): T;
export declare function useChildMatches<TRouteTree extends AnyRoute = RegisteredRouter['routeTree'], TRouteId extends RouteIds<TRouteTree> = ParseRoute<TRouteTree>['id'], TRouteMatch = MakeRouteMatch<TRouteTree, TRouteId>, T = Array<TRouteMatch>>(opts?: {
    select?: (matches: Array<TRouteMatch>) => T;
}): T;
