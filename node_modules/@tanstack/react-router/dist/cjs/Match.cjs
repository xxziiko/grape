"use client";
"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const jsxRuntime = require("react/jsx-runtime");
const React = require("react");
const invariant = require("tiny-invariant");
const warning = require("tiny-warning");
const CatchBoundary = require("./CatchBoundary.cjs");
const useRouterState = require("./useRouterState.cjs");
const useRouter = require("./useRouter.cjs");
const utils = require("./utils.cjs");
const notFound = require("./not-found.cjs");
const redirects = require("./redirects.cjs");
const matchContext = require("./matchContext.cjs");
const isServerSideError = require("./isServerSideError.cjs");
const SafeFragment = require("./SafeFragment.cjs");
const renderRouteNotFound = require("./renderRouteNotFound.cjs");
const root = require("./root.cjs");
function _interopNamespaceDefault(e) {
  const n = Object.create(null, { [Symbol.toStringTag]: { value: "Module" } });
  if (e) {
    for (const k in e) {
      if (k !== "default") {
        const d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: () => e[k]
        });
      }
    }
  }
  n.default = e;
  return Object.freeze(n);
}
const React__namespace = /* @__PURE__ */ _interopNamespaceDefault(React);
function Match({ matchId }) {
  var _a, _b;
  const router = useRouter.useRouter();
  const routeId = useRouterState.useRouterState({
    select: (s) => {
      var _a2;
      return (_a2 = s.matches.find((d) => d.id === matchId)) == null ? void 0 : _a2.routeId;
    }
  });
  invariant(
    routeId,
    `Could not find routeId for matchId "${matchId}". Please file an issue!`
  );
  const route = router.routesById[routeId];
  const PendingComponent = route.options.pendingComponent ?? router.options.defaultPendingComponent;
  const pendingElement = PendingComponent ? /* @__PURE__ */ jsxRuntime.jsx(PendingComponent, {}) : null;
  const routeErrorComponent = route.options.errorComponent ?? router.options.defaultErrorComponent;
  const routeOnCatch = route.options.onCatch ?? router.options.defaultOnCatch;
  const routeNotFoundComponent = route.isRoot ? (
    // If it's the root route, use the globalNotFound option, with fallback to the notFoundRoute's component
    route.options.notFoundComponent ?? ((_a = router.options.notFoundRoute) == null ? void 0 : _a.options.component)
  ) : route.options.notFoundComponent;
  const ResolvedSuspenseBoundary = (
    // If we're on the root route, allow forcefully wrapping in suspense
    (!route.isRoot || route.options.wrapInSuspense) && (route.options.wrapInSuspense ?? PendingComponent ?? ((_b = route.options.errorComponent) == null ? void 0 : _b.preload)) ? React__namespace.Suspense : SafeFragment.SafeFragment
  );
  const ResolvedCatchBoundary = routeErrorComponent ? CatchBoundary.CatchBoundary : SafeFragment.SafeFragment;
  const ResolvedNotFoundBoundary = routeNotFoundComponent ? notFound.CatchNotFound : SafeFragment.SafeFragment;
  const resetKey = useRouterState.useRouterState({
    select: (s) => s.loadedAt
  });
  return /* @__PURE__ */ jsxRuntime.jsx(matchContext.matchContext.Provider, { value: matchId, children: /* @__PURE__ */ jsxRuntime.jsx(ResolvedSuspenseBoundary, { fallback: pendingElement, children: /* @__PURE__ */ jsxRuntime.jsx(
    ResolvedCatchBoundary,
    {
      getResetKey: () => resetKey,
      errorComponent: routeErrorComponent || CatchBoundary.ErrorComponent,
      onCatch: (error, errorInfo) => {
        if (notFound.isNotFound(error)) throw error;
        warning(false, `Error in route match: ${matchId}`);
        routeOnCatch == null ? void 0 : routeOnCatch(error, errorInfo);
      },
      children: /* @__PURE__ */ jsxRuntime.jsx(
        ResolvedNotFoundBoundary,
        {
          fallback: (error) => {
            if (!routeNotFoundComponent || error.routeId && error.routeId !== routeId || !error.routeId && !route.isRoot)
              throw error;
            return React__namespace.createElement(routeNotFoundComponent, error);
          },
          children: /* @__PURE__ */ jsxRuntime.jsx(MatchInner, { matchId })
        }
      )
    }
  ) }) });
}
function MatchInner({ matchId }) {
  var _a, _b;
  const router = useRouter.useRouter();
  const routeId = useRouterState.useRouterState({
    select: (s) => {
      var _a2;
      return (_a2 = s.matches.find((d) => d.id === matchId)) == null ? void 0 : _a2.routeId;
    }
  });
  const route = router.routesById[routeId];
  const matchIndex = useRouterState.useRouterState({
    select: (s) => {
      return s.matches.findIndex((d) => d.id === matchId);
    }
  });
  const match = useRouterState.useRouterState({
    select: (s) => {
      const match2 = s.matches[matchIndex];
      return utils.pick(match2, [
        "id",
        "status",
        "error",
        "loadPromise",
        "minPendingPromise"
      ]);
    }
  });
  const RouteErrorComponent = (route.options.errorComponent ?? router.options.defaultErrorComponent) || CatchBoundary.ErrorComponent;
  if (match.status === "notFound") {
    let error;
    if (isServerSideError.isServerSideError(match.error)) {
      const deserializeError = ((_a = router.options.errorSerializer) == null ? void 0 : _a.deserialize) ?? isServerSideError.defaultDeserializeError;
      error = deserializeError(match.error.data);
    } else {
      error = match.error;
    }
    invariant(notFound.isNotFound(error), "Expected a notFound error");
    return renderRouteNotFound.renderRouteNotFound(router, route, error);
  }
  if (match.status === "redirected") {
    invariant(redirects.isRedirect(match.error), "Expected a redirect error");
    throw match.loadPromise;
  }
  if (match.status === "error") {
    if (router.isServer) {
      return /* @__PURE__ */ jsxRuntime.jsx(
        RouteErrorComponent,
        {
          error: match.error,
          info: {
            componentStack: ""
          }
        }
      );
    }
    if (isServerSideError.isServerSideError(match.error)) {
      const deserializeError = ((_b = router.options.errorSerializer) == null ? void 0 : _b.deserialize) ?? isServerSideError.defaultDeserializeError;
      throw deserializeError(match.error.data);
    } else {
      throw match.error;
    }
  }
  if (match.status === "pending") {
    const pendingMinMs = route.options.pendingMinMs ?? router.options.defaultPendingMinMs;
    if (pendingMinMs && !match.minPendingPromise) {
      if (!router.isServer) {
        const minPendingPromise = utils.createControlledPromise();
        Promise.resolve().then(() => {
          router.updateMatch(match.id, (prev) => ({
            ...prev,
            minPendingPromise
          }));
        });
        setTimeout(() => {
          minPendingPromise.resolve();
          router.updateMatch(match.id, (prev) => ({
            ...prev,
            minPendingPromise: void 0
          }));
        }, pendingMinMs);
      }
    }
    throw match.loadPromise;
  }
  const Comp = route.options.component ?? router.options.defaultComponent;
  const out = Comp ? /* @__PURE__ */ jsxRuntime.jsx(Comp, {}) : /* @__PURE__ */ jsxRuntime.jsx(Outlet, {});
  return /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
    out,
    router.AfterEachMatch ? /* @__PURE__ */ jsxRuntime.jsx(router.AfterEachMatch, { match, matchIndex }) : null
  ] });
}
const Outlet = React__namespace.memo(function Outlet2() {
  const router = useRouter.useRouter();
  const matchId = React__namespace.useContext(matchContext.matchContext);
  const routeId = useRouterState.useRouterState({
    select: (s) => {
      var _a;
      return (_a = s.matches.find((d) => d.id === matchId)) == null ? void 0 : _a.routeId;
    }
  });
  const route = router.routesById[routeId];
  const { parentGlobalNotFound } = useRouterState.useRouterState({
    select: (s) => {
      const matches = s.matches;
      const parentMatch = matches.find((d) => d.id === matchId);
      invariant(
        parentMatch,
        `Could not find parent match for matchId "${matchId}"`
      );
      return {
        parentGlobalNotFound: parentMatch.globalNotFound
      };
    }
  });
  const childMatchId = useRouterState.useRouterState({
    select: (s) => {
      var _a;
      const matches = s.matches;
      const index = matches.findIndex((d) => d.id === matchId);
      return (_a = matches[index + 1]) == null ? void 0 : _a.id;
    }
  });
  if (parentGlobalNotFound) {
    return renderRouteNotFound.renderRouteNotFound(router, route, void 0);
  }
  if (!childMatchId) {
    return null;
  }
  const nextMatch = /* @__PURE__ */ jsxRuntime.jsx(Match, { matchId: childMatchId });
  const pendingElement = router.options.defaultPendingComponent ? /* @__PURE__ */ jsxRuntime.jsx(router.options.defaultPendingComponent, {}) : null;
  if (matchId === root.rootRouteId) {
    return /* @__PURE__ */ jsxRuntime.jsx(React__namespace.Suspense, { fallback: pendingElement, children: nextMatch });
  }
  return nextMatch;
});
exports.Match = Match;
exports.Outlet = Outlet;
//# sourceMappingURL=Match.cjs.map
