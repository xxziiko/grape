{"version":3,"file":"router.cjs","sources":["../../src/router.ts"],"sourcesContent":["import { createBrowserHistory, createMemoryHistory } from '@tanstack/history'\nimport { Store } from '@tanstack/react-store'\nimport invariant from 'tiny-invariant'\nimport warning from 'tiny-warning'\nimport { rootRouteId } from './root'\nimport { defaultParseSearch, defaultStringifySearch } from './searchParams'\nimport {\n  createControlledPromise,\n  deepEqual,\n  functionalUpdate,\n  last,\n  pick,\n  replaceEqualDeep,\n} from './utils'\nimport {\n  cleanPath,\n  interpolatePath,\n  joinPaths,\n  matchPathname,\n  parsePathname,\n  resolvePath,\n  trimPath,\n  trimPathLeft,\n  trimPathRight,\n} from './path'\nimport { isRedirect, isResolvedRedirect } from './redirects'\nimport { isNotFound } from './not-found'\nimport type * as React from 'react'\nimport type { Manifest } from './manifest'\nimport type {\n  HistoryLocation,\n  HistoryState,\n  RouterHistory,\n} from '@tanstack/history'\n\nimport type {\n  AnyContext,\n  AnyRoute,\n  AnyRouteWithContext,\n  AnySearchSchema,\n  ErrorRouteComponent,\n  LoaderFnContext,\n  NotFoundRouteComponent,\n  RootRoute,\n  RouteComponent,\n  RouteMask,\n} from './route'\nimport type {\n  FullSearchSchema,\n  RouteById,\n  RoutePaths,\n  RoutesById,\n  RoutesByPath,\n} from './routeInfo'\nimport type {\n  ControlledPromise,\n  NonNullableUpdater,\n  PickAsRequired,\n  Updater,\n} from './utils'\nimport type {\n  AnyRouteMatch,\n  MakeRouteMatch,\n  MatchRouteOptions,\n} from './Matches'\nimport type { ParsedLocation } from './location'\nimport type { SearchParser, SearchSerializer } from './searchParams'\nimport type {\n  BuildLocationFn,\n  CommitLocationOptions,\n  NavigateFn,\n} from './RouterProvider'\n\nimport type { AnyRedirect, ResolvedRedirect } from './redirects'\n\nimport type { NotFoundError } from './not-found'\nimport type { NavigateOptions, ResolveRelativePath, ToOptions } from './link'\nimport type { NoInfer } from '@tanstack/react-store'\nimport type { DeferredPromiseState } from './defer'\n\n//\n\ndeclare global {\n  interface Window {\n    __TSR__?: {\n      matches: Array<any>\n      streamedValues: Record<\n        string,\n        {\n          value: any\n          parsed: any\n        }\n      >\n      cleanScripts: () => void\n      dehydrated?: any\n    }\n    __TSR_ROUTER_CONTEXT__?: React.Context<Router<any, any>>\n  }\n}\n\nexport interface Register {\n  // router: Router\n}\n\nexport type AnyRouter = Router<any, any, any, any>\n\nexport type AnyRouterWithContext<TContext> = Router<\n  AnyRouteWithContext<TContext>,\n  any,\n  any,\n  any\n>\n\nexport type RegisteredRouter = Register extends {\n  router: infer TRouter extends AnyRouter\n}\n  ? TRouter\n  : AnyRouter\n\nexport type HydrationCtx = {\n  router: DehydratedRouter\n  payload: Record<string, any>\n}\n\nexport type InferRouterContext<TRouteTree extends AnyRoute> =\n  TRouteTree extends RootRoute<\n    any,\n    any,\n    any,\n    any,\n    any,\n    infer TRouterContext extends AnyContext,\n    any,\n    any,\n    any,\n    any\n  >\n    ? TRouterContext\n    : AnyContext\n\nexport type RouterContextOptions<TRouteTree extends AnyRoute> =\n  AnyContext extends InferRouterContext<TRouteTree>\n    ? {\n        context?: InferRouterContext<TRouteTree>\n      }\n    : {\n        context: InferRouterContext<TRouteTree>\n      }\n\nexport type TrailingSlashOption = 'always' | 'never' | 'preserve'\n\nexport interface RouterOptions<\n  TRouteTree extends AnyRoute,\n  TTrailingSlashOption extends TrailingSlashOption,\n  TDehydrated extends Record<string, any> = Record<string, any>,\n  TSerializedError extends Record<string, any> = Record<string, any>,\n> {\n  /**\n   * The history object that will be used to manage the browser history.\n   * If not provided, a new createBrowserHistory instance will be created and used.\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#history-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/history-types)\n   */\n  history?: RouterHistory\n  /**\n   * A function that will be used to stringify search params when generating links.\n   * Defaults to `defaultStringifySearch`.\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#stringifysearch-method)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/custom-search-param-serialization)\n   */\n  stringifySearch?: SearchSerializer\n  /**\n   * A function that will be used to parse search params when parsing the current location.\n   * Defaults to `defaultParseSearch`.\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#parsesearch-method)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/custom-search-param-serialization)\n   */\n  parseSearch?: SearchParser\n  /**\n   * Defaults to `false`\n   * If `false`, routes will not be preloaded by default in any way.\n   * If `'intent'`, routes will be preloaded by default when the user hovers over a link or a `touchstart` event is detected on a `<Link>`.\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaultpreload-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/preloading)\n   */\n  defaultPreload?: false | 'intent'\n  /**\n   * Defaults to 50\n   * The delay in milliseconds that a route must be hovered over or touched before it is preloaded.\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaultpreloaddelay-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/preloading#preload-delay)\n   */\n  defaultPreloadDelay?: number\n  /**\n   * Defaults to `Outlet`\n   * The default `component` a route should use if no component is provided.\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaultcomponent-property)\n   */\n  defaultComponent?: RouteComponent\n  /**\n   * Defaults to `ErrorComponent`\n   * The default `errorComponent` a route should use if no error component is provided.\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaulterrorcomponent-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/data-loading#handling-errors-with-routeoptionserrorcomponent)\n   */\n  defaultErrorComponent?: ErrorRouteComponent\n  /**\n   * The default `pendingComponent` a route should use if no pending component is provided.\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaultpendingcomponent-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/data-loading#showing-a-pending-component)\n   */\n  defaultPendingComponent?: RouteComponent\n  /**\n   * Defaults to `1000`\n   * The default `pendingMs` a route should use if no pendingMs is provided.\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaultpendingms-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/data-loading#avoiding-pending-component-flash)\n   */\n  defaultPendingMs?: number\n  /**\n   * Defaults to `500`\n   * The default `pendingMinMs` a route should use if no pendingMinMs is provided.\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaultpendingminms-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/data-loading#avoiding-pending-component-flash)\n   */\n  defaultPendingMinMs?: number\n  /**\n   * Defaults to `0`\n   * The default `staleTime` a route should use if no staleTime is\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaultstaletime-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/data-loading#key-options)\n   */\n  defaultStaleTime?: number\n  /**\n   * Defaults to `30_000` ms (30 seconds)\n   * The default `preloadStaleTime` a route should use if no preloadStaleTime is provided.\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaultpreloadstaletime-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/preloading)\n   */\n  defaultPreloadStaleTime?: number\n  /**\n   * Defaults to `routerOptions.defaultGcTime`, which defaults to 30 minutes.\n   * The default `defaultPreloadGcTime` a route should use if no preloadGcTime is provided.\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaultpreloadgctime-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/preloading)\n   */\n  defaultPreloadGcTime?: number\n  /**\n   * The default `onCatch` handler for errors caught by the Router ErrorBoundary\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaultoncatch-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/data-loading#handling-errors-with-routeoptionsoncatch)\n   */\n  defaultOnCatch?: (error: Error, errorInfo: React.ErrorInfo) => void\n  defaultViewTransition?: boolean\n  /**\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/not-found-errors#the-notfoundmode-option)\n   */\n  notFoundMode?: 'root' | 'fuzzy'\n  /**\n   * Defaults to 30 minutes.\n   * The default `gcTime` a route should use if no\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaultgctime-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/data-loading#key-options)\n   */\n  defaultGcTime?: number\n  /**\n   * Defaults to `false`\n   * If `true`, all routes will be matched as case-sensitive.\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#casesensitive-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/route-trees#case-sensitivity)\n   */\n  caseSensitive?: boolean\n  /**\n   * Required\n   * The route tree that will be used to configure the router instance.\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#routetree-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/route-trees)\n   */\n  routeTree?: TRouteTree\n  /**\n   * Defaults to `/`\n   * The basepath for then entire router. This is useful for mounting a router instance at a subpath.\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#basepath-property)\n   */\n  basepath?: string\n  /**\n   * Optional or required if the root route was created with [`createRootRouteWithContext()`](https://tanstack.com/router/latest/docs/framework/react/api/router/createRootRouteWithContextFunction).\n   * The root context that will be provided to all routes in the route tree.\n   * This can be used to provide a context to all routes in the tree without having to provide it to each route individually.\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#context-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/router-context)\n   */\n  context?: InferRouterContext<TRouteTree>\n  /**\n   * A function that will be called when the router is dehydrated.\n   * The return value of this function will be serialized and stored in the router's dehydrated state.\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#dehydrate-method)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/external-data-loading#critical-dehydrationhydration)\n   */\n  dehydrate?: () => TDehydrated\n  /**\n   * A function that will be called when the router is hydrated.\n   * The return value of this function will be serialized and stored in the router's dehydrated state.\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#hydrate-method)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/external-data-loading#critical-dehydrationhydration)\n   */\n  hydrate?: (dehydrated: TDehydrated) => void\n  /**\n   * An array of route masks that will be used to mask routes in the route tree.\n   * Route masking is when you display a route at a different path than the one it is configured to match, like a modal popup that when shared will unmask to the modal's content instead of the modal's context.\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#routemasks-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/route-masking)\n   */\n  routeMasks?: Array<RouteMask<TRouteTree>>\n  /**\n   * Defaults to `false`\n   * If `true`, route masks will, by default, be removed when the page is reloaded.\n   * This can be overridden on a per-mask basis by setting the `unmaskOnReload` option on the mask, or on a per-navigation basis by setting the `unmaskOnReload` option in the `Navigate` options.\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#unmaskonreload-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/route-masking#unmasking-on-page-reload)\n   */\n  unmaskOnReload?: boolean\n  /**\n   * A component that will be used to wrap the entire router.\n   * This is useful for providing a context to the entire router.\n   * Only non-DOM-rendering components like providers should be used, anything else will cause a hydration error.\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#wrap-property)\n   */\n  Wrap?: (props: { children: any }) => React.JSX.Element\n  /**\n   * A component that will be used to wrap the inner contents of the router.\n   * This is useful for providing a context to the inner contents of the router where you also need access to the router context and hooks.\n   * Only non-DOM-rendering components like providers should be used, anything else will cause a hydration error.\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#innerwrap-property)\n   */\n  InnerWrap?: (props: { children: any }) => React.JSX.Element\n  /**\n   * @deprecated\n   * Use `notFoundComponent` instead.\n   * See https://tanstack.com/router/v1/docs/guide/not-found-errors#migrating-from-notfoundroute for more info.\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#notfoundroute-property)\n   */\n  notFoundRoute?: AnyRoute\n  /**\n   * Defaults to `NotFound`\n   * The default `notFoundComponent` a route should use if no notFound component is provided.\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaultnotfoundcomponent-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/not-found-errors#default-router-wide-not-found-handling)\n   */\n  defaultNotFoundComponent?: NotFoundRouteComponent\n  /**\n   * The transformer that will be used when sending data between the server and the client during SSR.\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#transformer-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/ssr#data-transformers)\n   */\n  transformer?: RouterTransformer\n  /**\n   * The serializer object that will be used to determine how errors are serialized and deserialized between the server and the client.\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#errorserializer-property)\n   */\n  errorSerializer?: RouterErrorSerializer<TSerializedError>\n  /**\n   * Defaults to `never`\n   * Configures how trailing slashes are treated.\n   * `'always'` will add a trailing slash if not present, `'never'` will remove the trailing slash if present and `'preserve'` will not modify the trailing slash.\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#trailingslash-property)\n   */\n  trailingSlash?: TTrailingSlashOption\n  /**\n   * Defaults to `typeof document !== 'undefined'`\n   * While usually automatic, sometimes it can be useful to force the router into a server-side state, e.g. when using the router in a non-browser environment that has access to a global.document object.\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#isserver property)\n   */\n  isServer?: boolean\n}\n\nexport interface RouterTransformer {\n  stringify: (obj: unknown) => string\n  parse: (str: string) => unknown\n}\nexport interface RouterErrorSerializer<TSerializedError> {\n  serialize: (err: unknown) => TSerializedError\n  deserialize: (err: TSerializedError) => unknown\n}\n\nexport interface RouterState<\n  TRouteTree extends AnyRoute = AnyRoute,\n  TRouteMatch = MakeRouteMatch<TRouteTree>,\n> {\n  status: 'pending' | 'idle'\n  loadedAt: number\n  isLoading: boolean\n  isTransitioning: boolean\n  matches: Array<TRouteMatch>\n  pendingMatches?: Array<TRouteMatch>\n  cachedMatches: Array<TRouteMatch>\n  location: ParsedLocation<FullSearchSchema<TRouteTree>>\n  resolvedLocation: ParsedLocation<FullSearchSchema<TRouteTree>>\n  statusCode: number\n  redirect?: ResolvedRedirect\n}\n\nexport type ListenerFn<TEvent extends RouterEvent> = (event: TEvent) => void\n\nexport interface BuildNextOptions {\n  to?: string | number | null\n  params?: true | Updater<unknown>\n  search?: true | Updater<unknown>\n  hash?: true | Updater<string>\n  state?: true | NonNullableUpdater<HistoryState>\n  mask?: {\n    to?: string | number | null\n    params?: true | Updater<unknown>\n    search?: true | Updater<unknown>\n    hash?: true | Updater<string>\n    state?: true | NonNullableUpdater<HistoryState>\n    unmaskOnReload?: boolean\n  }\n  from?: string\n  fromSearch?: unknown\n  _fromLocation?: ParsedLocation\n}\n\nexport interface DehydratedRouterState {\n  dehydratedMatches: Array<DehydratedRouteMatch>\n}\n\nexport type DehydratedRouteMatch = Pick<\n  MakeRouteMatch,\n  'id' | 'status' | 'updatedAt' | 'loaderData'\n>\n\nexport interface DehydratedRouter {\n  state: DehydratedRouterState\n  manifest?: Manifest\n}\n\nexport type RouterConstructorOptions<\n  TRouteTree extends AnyRoute,\n  TTrailingSlashOption extends TrailingSlashOption,\n  TDehydrated extends Record<string, any>,\n  TSerializedError extends Record<string, any>,\n> = Omit<\n  RouterOptions<\n    TRouteTree,\n    TTrailingSlashOption,\n    TDehydrated,\n    TSerializedError\n  >,\n  'context'\n> &\n  RouterContextOptions<TRouteTree>\n\nexport const componentTypes = [\n  'component',\n  'errorComponent',\n  'pendingComponent',\n  'notFoundComponent',\n] as const\n\nexport type RouterEvents = {\n  onBeforeNavigate: {\n    type: 'onBeforeNavigate'\n    fromLocation: ParsedLocation\n    toLocation: ParsedLocation\n    pathChanged: boolean\n  }\n  onBeforeLoad: {\n    type: 'onBeforeLoad'\n    fromLocation: ParsedLocation\n    toLocation: ParsedLocation\n    pathChanged: boolean\n  }\n  onLoad: {\n    type: 'onLoad'\n    fromLocation: ParsedLocation\n    toLocation: ParsedLocation\n    pathChanged: boolean\n  }\n  onResolved: {\n    type: 'onResolved'\n    fromLocation: ParsedLocation\n    toLocation: ParsedLocation\n    pathChanged: boolean\n  }\n}\n\nexport type RouterEvent = RouterEvents[keyof RouterEvents]\n\nexport type RouterListener<TRouterEvent extends RouterEvent> = {\n  eventType: TRouterEvent['type']\n  fn: ListenerFn<TRouterEvent>\n}\n\nexport function createRouter<\n  TRouteTree extends AnyRoute,\n  TTrailingSlashOption extends TrailingSlashOption,\n  TDehydrated extends Record<string, any> = Record<string, any>,\n  TSerializedError extends Record<string, any> = Record<string, any>,\n>(\n  options: RouterConstructorOptions<\n    TRouteTree,\n    TTrailingSlashOption,\n    TDehydrated,\n    TSerializedError\n  >,\n) {\n  return new Router<\n    TRouteTree,\n    TTrailingSlashOption,\n    TDehydrated,\n    TSerializedError\n  >(options)\n}\n\nexport class Router<\n  in out TRouteTree extends AnyRoute,\n  in out TTrailingSlashOption extends TrailingSlashOption,\n  in out TDehydrated extends Record<string, any> = Record<string, any>,\n  in out TSerializedError extends Record<string, any> = Record<string, any>,\n> {\n  // Option-independent properties\n  tempLocationKey: string | undefined = `${Math.round(\n    Math.random() * 10000000,\n  )}`\n  resetNextScroll = true\n  shouldViewTransition?: boolean = undefined\n  subscribers = new Set<RouterListener<RouterEvent>>()\n  dehydratedData?: TDehydrated\n  viewTransitionPromise?: ControlledPromise<true>\n  manifest?: Manifest\n  AfterEachMatch?: (props: {\n    match: Pick<\n      AnyRouteMatch,\n      'id' | 'status' | 'error' | 'loadPromise' | 'minPendingPromise'\n    >\n    matchIndex: number\n  }) => any\n  serializeLoaderData?: (\n    data: any,\n    ctx: {\n      router: AnyRouter\n      match: AnyRouteMatch\n    },\n  ) => any\n  serializer?: (data: any) => string\n\n  // Must build in constructor\n  __store!: Store<RouterState<TRouteTree>>\n  options!: PickAsRequired<\n    Omit<\n      RouterOptions<\n        TRouteTree,\n        TTrailingSlashOption,\n        TDehydrated,\n        TSerializedError\n      >,\n      'transformer'\n    > & {\n      transformer: RouterTransformer\n    },\n    'stringifySearch' | 'parseSearch' | 'context'\n  >\n  history!: RouterHistory\n  latestLocation!: ParsedLocation<FullSearchSchema<TRouteTree>>\n  basepath!: string\n  routeTree!: TRouteTree\n  routesById!: RoutesById<TRouteTree>\n  routesByPath!: RoutesByPath<TRouteTree>\n  flatRoutes!: Array<AnyRoute>\n  isServer!: boolean\n\n  /**\n   * @deprecated Use the `createRouter` function instead\n   */\n  constructor(\n    options: RouterConstructorOptions<\n      TRouteTree,\n      TTrailingSlashOption,\n      TDehydrated,\n      TSerializedError\n    >,\n  ) {\n    this.update({\n      defaultPreloadDelay: 50,\n      defaultPendingMs: 1000,\n      defaultPendingMinMs: 500,\n      context: undefined!,\n      ...options,\n      stringifySearch: options.stringifySearch ?? defaultStringifySearch,\n      parseSearch: options.parseSearch ?? defaultParseSearch,\n    })\n\n    if (typeof document !== 'undefined') {\n      ;(window as any).__TSR__ROUTER__ = this\n    }\n  }\n\n  // These are default implementations that can optionally be overridden\n  // by the router provider once rendered. We provide these so that the\n  // router can be used in a non-react environment if necessary\n  startReactTransition: (fn: () => void) => void = (fn) => fn()\n\n  update = (\n    newOptions: RouterConstructorOptions<\n      TRouteTree,\n      TTrailingSlashOption,\n      TDehydrated,\n      TSerializedError\n    >,\n  ) => {\n    if (newOptions.notFoundRoute) {\n      console.warn(\n        'The notFoundRoute API is deprecated and will be removed in the next major version. See https://tanstack.com/router/v1/docs/guide/not-found-errors#migrating-from-notfoundroute for more info.',\n      )\n    }\n\n    const previousOptions = this.options\n    this.options = {\n      ...this.options,\n      ...newOptions,\n    }\n\n    this.isServer = this.options.isServer ?? typeof document === 'undefined'\n\n    if (\n      !this.basepath ||\n      (newOptions.basepath && newOptions.basepath !== previousOptions.basepath)\n    ) {\n      if (\n        newOptions.basepath === undefined ||\n        newOptions.basepath === '' ||\n        newOptions.basepath === '/'\n      ) {\n        this.basepath = '/'\n      } else {\n        this.basepath = `/${trimPath(newOptions.basepath)}`\n      }\n    }\n\n    if (\n      // eslint-disable-next-line ts/no-unnecessary-condition\n      !this.history ||\n      (this.options.history && this.options.history !== this.history)\n    ) {\n      this.history =\n        this.options.history ??\n        (this.isServer\n          ? createMemoryHistory({\n              initialEntries: [this.basepath || '/'],\n            })\n          : createBrowserHistory())\n      this.latestLocation = this.parseLocation()\n    }\n\n    if (this.options.routeTree !== this.routeTree) {\n      this.routeTree = this.options.routeTree as TRouteTree\n      this.buildRouteTree()\n    }\n\n    // eslint-disable-next-line ts/no-unnecessary-condition\n    if (!this.__store) {\n      this.__store = new Store(getInitialRouterState(this.latestLocation), {\n        onUpdate: () => {\n          this.__store.state = {\n            ...this.state,\n            cachedMatches: this.state.cachedMatches.filter(\n              (d) => !['redirected'].includes(d.status),\n            ),\n          }\n        },\n      })\n    }\n  }\n\n  get state() {\n    return this.__store.state\n  }\n\n  buildRouteTree = () => {\n    this.routesById = {} as RoutesById<TRouteTree>\n    this.routesByPath = {} as RoutesByPath<TRouteTree>\n\n    const notFoundRoute = this.options.notFoundRoute\n    if (notFoundRoute) {\n      notFoundRoute.init({ originalIndex: 99999999999 })\n      ;(this.routesById as any)[notFoundRoute.id] = notFoundRoute\n    }\n\n    const recurseRoutes = (childRoutes: Array<AnyRoute>) => {\n      childRoutes.forEach((childRoute, i) => {\n        childRoute.init({ originalIndex: i })\n\n        const existingRoute = (this.routesById as any)[childRoute.id]\n\n        invariant(\n          !existingRoute,\n          `Duplicate routes found with id: ${String(childRoute.id)}`,\n        )\n        ;(this.routesById as any)[childRoute.id] = childRoute\n\n        if (!childRoute.isRoot && childRoute.path) {\n          const trimmedFullPath = trimPathRight(childRoute.fullPath)\n          if (\n            !(this.routesByPath as any)[trimmedFullPath] ||\n            childRoute.fullPath.endsWith('/')\n          ) {\n            ;(this.routesByPath as any)[trimmedFullPath] = childRoute\n          }\n        }\n\n        const children = childRoute.children\n\n        if (children?.length) {\n          recurseRoutes(children)\n        }\n      })\n    }\n\n    recurseRoutes([this.routeTree])\n\n    const scoredRoutes: Array<{\n      child: AnyRoute\n      trimmed: string\n      parsed: ReturnType<typeof parsePathname>\n      index: number\n      scores: Array<number>\n    }> = []\n\n    const routes: Array<AnyRoute> = Object.values(this.routesById)\n\n    routes.forEach((d, i) => {\n      if (d.isRoot || !d.path) {\n        return\n      }\n\n      const trimmed = trimPathLeft(d.fullPath)\n      const parsed = parsePathname(trimmed)\n\n      while (parsed.length > 1 && parsed[0]?.value === '/') {\n        parsed.shift()\n      }\n\n      const scores = parsed.map((segment) => {\n        if (segment.value === '/') {\n          return 0.75\n        }\n\n        if (segment.type === 'param') {\n          return 0.5\n        }\n\n        if (segment.type === 'wildcard') {\n          return 0.25\n        }\n\n        return 1\n      })\n\n      scoredRoutes.push({ child: d, trimmed, parsed, index: i, scores })\n    })\n\n    this.flatRoutes = scoredRoutes\n      .sort((a, b) => {\n        const minLength = Math.min(a.scores.length, b.scores.length)\n\n        // Sort by min available score\n        for (let i = 0; i < minLength; i++) {\n          if (a.scores[i] !== b.scores[i]) {\n            return b.scores[i]! - a.scores[i]!\n          }\n        }\n\n        // Sort by length of score\n        if (a.scores.length !== b.scores.length) {\n          return b.scores.length - a.scores.length\n        }\n\n        // Sort by min available parsed value\n        for (let i = 0; i < minLength; i++) {\n          if (a.parsed[i]!.value !== b.parsed[i]!.value) {\n            return a.parsed[i]!.value > b.parsed[i]!.value ? 1 : -1\n          }\n        }\n\n        // Sort by original index\n        return a.index - b.index\n      })\n      .map((d, i) => {\n        d.child.rank = i\n        return d.child\n      })\n  }\n\n  subscribe = <TType extends keyof RouterEvents>(\n    eventType: TType,\n    fn: ListenerFn<RouterEvents[TType]>,\n  ) => {\n    const listener: RouterListener<any> = {\n      eventType,\n      fn,\n    }\n\n    this.subscribers.add(listener)\n\n    return () => {\n      this.subscribers.delete(listener)\n    }\n  }\n\n  emit = (routerEvent: RouterEvent) => {\n    this.subscribers.forEach((listener) => {\n      if (listener.eventType === routerEvent.type) {\n        listener.fn(routerEvent)\n      }\n    })\n  }\n\n  parseLocation = (\n    previousLocation?: ParsedLocation<FullSearchSchema<TRouteTree>>,\n  ): ParsedLocation<FullSearchSchema<TRouteTree>> => {\n    const parse = ({\n      pathname,\n      search,\n      hash,\n      state,\n    }: HistoryLocation): ParsedLocation<FullSearchSchema<TRouteTree>> => {\n      const parsedSearch = this.options.parseSearch(search)\n      const searchStr = this.options.stringifySearch(parsedSearch)\n\n      return {\n        pathname,\n        searchStr,\n        search: replaceEqualDeep(previousLocation?.search, parsedSearch) as any,\n        hash: hash.split('#').reverse()[0] ?? '',\n        href: `${pathname}${searchStr}${hash}`,\n        state: replaceEqualDeep(previousLocation?.state, state),\n      }\n    }\n\n    const location = parse(this.history.location)\n\n    const { __tempLocation, __tempKey } = location.state\n\n    if (__tempLocation && (!__tempKey || __tempKey === this.tempLocationKey)) {\n      // Sync up the location keys\n      const parsedTempLocation = parse(__tempLocation) as any\n      parsedTempLocation.state.key = location.state.key\n\n      delete parsedTempLocation.state.__tempLocation\n\n      return {\n        ...parsedTempLocation,\n        maskedLocation: location,\n      }\n    }\n\n    return location\n  }\n\n  resolvePathWithBase = (from: string, path: string) => {\n    const resolvedPath = resolvePath({\n      basepath: this.basepath,\n      base: from,\n      to: cleanPath(path),\n      trailingSlash: this.options.trailingSlash,\n    })\n    return resolvedPath\n  }\n\n  get looseRoutesById() {\n    return this.routesById as Record<string, AnyRoute>\n  }\n\n  matchRoutes = (\n    pathname: string,\n    locationSearch: AnySearchSchema,\n    opts?: { preload?: boolean; throwOnError?: boolean },\n  ): Array<AnyRouteMatch> => {\n    let routeParams: Record<string, string> = {}\n\n    const foundRoute = this.flatRoutes.find((route) => {\n      const matchedParams = matchPathname(\n        this.basepath,\n        trimPathRight(pathname),\n        {\n          to: route.fullPath,\n          caseSensitive:\n            route.options.caseSensitive ?? this.options.caseSensitive,\n          fuzzy: true,\n        },\n      )\n\n      if (matchedParams) {\n        routeParams = matchedParams\n        return true\n      }\n\n      return false\n    })\n\n    let routeCursor: AnyRoute =\n      foundRoute || (this.routesById as any)[rootRouteId]\n\n    const matchedRoutes: Array<AnyRoute> = [routeCursor]\n\n    let isGlobalNotFound = false\n\n    // Check to see if the route needs a 404 entry\n    if (\n      // If we found a route, and it's not an index route and we have left over path\n      foundRoute\n        ? foundRoute.path !== '/' && routeParams['**']\n        : // Or if we didn't find a route and we have left over path\n          trimPathRight(pathname)\n    ) {\n      // If the user has defined an (old) 404 route, use it\n      if (this.options.notFoundRoute) {\n        matchedRoutes.push(this.options.notFoundRoute)\n      } else {\n        // If there is no routes found during path matching\n        isGlobalNotFound = true\n      }\n    }\n\n    while (routeCursor.parentRoute) {\n      routeCursor = routeCursor.parentRoute\n      matchedRoutes.unshift(routeCursor)\n    }\n\n    const globalNotFoundRouteId = (() => {\n      if (!isGlobalNotFound) {\n        return undefined\n      }\n\n      if (this.options.notFoundMode !== 'root') {\n        for (let i = matchedRoutes.length - 1; i >= 0; i--) {\n          const route = matchedRoutes[i]!\n          if (route.children) {\n            return route.id\n          }\n        }\n      }\n\n      return rootRouteId\n    })()\n\n    // Existing matches are matches that are already loaded along with\n    // pending matches that are still loading\n\n    const parseErrors = matchedRoutes.map((route) => {\n      let parsedParamsError\n\n      const parseParams =\n        route.options.params?.parse ?? route.options.parseParams\n\n      if (parseParams) {\n        try {\n          const parsedParams = parseParams(routeParams)\n          // Add the parsed params to the accumulated params bag\n          Object.assign(routeParams, parsedParams)\n        } catch (err: any) {\n          parsedParamsError = new PathParamError(err.message, {\n            cause: err,\n          })\n\n          if (opts?.throwOnError) {\n            throw parsedParamsError\n          }\n\n          return parsedParamsError\n        }\n      }\n\n      return\n    })\n\n    const matches: Array<AnyRouteMatch> = []\n\n    matchedRoutes.forEach((route, index) => {\n      // Take each matched route and resolve + validate its search params\n      // This has to happen serially because each route's search params\n      // can depend on the parent route's search params\n      // It must also happen before we create the match so that we can\n      // pass the search params to the route's potential key function\n      // which is used to uniquely identify the route match in state\n\n      const parentMatch = matches[index - 1]\n\n      const [preMatchSearch, searchError]: [Record<string, any>, any] = (() => {\n        // Validate the search params and stabilize them\n        const parentSearch = parentMatch?.search ?? locationSearch\n\n        try {\n          const validator =\n            typeof route.options.validateSearch === 'object'\n              ? route.options.validateSearch.parse\n              : route.options.validateSearch\n\n          const search = validator?.(parentSearch) ?? {}\n\n          return [\n            {\n              ...parentSearch,\n              ...search,\n            },\n            undefined,\n          ]\n        } catch (err: any) {\n          const searchParamError = new SearchParamError(err.message, {\n            cause: err,\n          })\n\n          if (opts?.throwOnError) {\n            throw searchParamError\n          }\n\n          return [parentSearch, searchParamError]\n        }\n      })()\n\n      // This is where we need to call route.options.loaderDeps() to get any additional\n      // deps that the route's loader function might need to run. We need to do this\n      // before we create the match so that we can pass the deps to the route's\n      // potential key function which is used to uniquely identify the route match in state\n\n      const loaderDeps =\n        route.options.loaderDeps?.({\n          search: preMatchSearch,\n        }) ?? ''\n\n      const loaderDepsHash = loaderDeps ? JSON.stringify(loaderDeps) : ''\n\n      const interpolatedPath = interpolatePath({\n        path: route.fullPath,\n        params: routeParams,\n      })\n\n      const matchId =\n        interpolatePath({\n          path: route.id,\n          params: routeParams,\n          leaveWildcards: true,\n        }) + loaderDepsHash\n\n      // Waste not, want not. If we already have a match for this route,\n      // reuse it. This is important for layout routes, which might stick\n      // around between navigation actions that only change leaf routes.\n      const existingMatch = this.getMatch(matchId)\n\n      const cause = this.state.matches.find((d) => d.id === matchId)\n        ? 'stay'\n        : 'enter'\n\n      let match: AnyRouteMatch\n\n      if (existingMatch) {\n        match = {\n          ...existingMatch,\n          cause,\n          params: routeParams,\n        }\n      } else {\n        const status =\n          route.options.loader || route.options.beforeLoad || route.lazyFn\n            ? 'pending'\n            : 'success'\n\n        match = {\n          id: matchId,\n          index,\n          routeId: route.id,\n          params: routeParams,\n          pathname: joinPaths([this.basepath, interpolatedPath]),\n          updatedAt: Date.now(),\n          search: {} as any,\n          searchError: undefined,\n          status,\n          isFetching: false,\n          error: undefined,\n          paramsError: parseErrors[index],\n          routeContext: undefined!,\n          context: undefined!,\n          abortController: new AbortController(),\n          fetchCount: 0,\n          cause,\n          loaderDeps,\n          invalid: false,\n          preload: false,\n          links: route.options.links?.(),\n          scripts: route.options.scripts?.(),\n          staticData: route.options.staticData || {},\n          loadPromise: createControlledPromise(),\n        }\n      }\n\n      // If it's already a success, update the meta and headers\n      // These may get updated again if the match is refreshed\n      // due to being stale\n      if (match.status === 'success') {\n        match.meta = route.options.meta?.({\n          matches,\n          match,\n          params: match.params,\n          loaderData: match.loaderData,\n        })\n\n        match.headers = route.options.headers?.({\n          loaderData: match.loaderData,\n        })\n      }\n\n      if (!opts?.preload) {\n        // If we have a global not found, mark the right match as global not found\n        match.globalNotFound = globalNotFoundRouteId === route.id\n      }\n\n      // Regardless of whether we're reusing an existing match or creating\n      // a new one, we need to update the match's search params\n      match.search = replaceEqualDeep(match.search, preMatchSearch)\n      // And also update the searchError if there is one\n      match.searchError = searchError\n\n      matches.push(match)\n    })\n\n    return matches as any\n  }\n\n  cancelMatch = (id: string) => {\n    const match = this.getMatch(id)\n\n    if (!match) return\n\n    match.abortController.abort()\n    clearTimeout(match.pendingTimeout)\n  }\n\n  cancelMatches = () => {\n    this.state.pendingMatches?.forEach((match) => {\n      this.cancelMatch(match.id)\n    })\n  }\n\n  buildLocation: BuildLocationFn = (opts) => {\n    const build = (\n      dest: BuildNextOptions & {\n        unmaskOnReload?: boolean\n      } = {},\n      matches?: Array<MakeRouteMatch<TRouteTree>>,\n    ): ParsedLocation => {\n      const fromMatches =\n        dest._fromLocation != null\n          ? this.matchRoutes(\n              dest._fromLocation.pathname,\n              dest.fromSearch || dest._fromLocation.search,\n            )\n          : this.state.matches\n\n      const fromMatch =\n        dest.from != null\n          ? fromMatches.find((d) =>\n              matchPathname(this.basepath, trimPathRight(d.pathname), {\n                to: dest.from,\n                caseSensitive: false,\n                fuzzy: false,\n              }),\n            )\n          : undefined\n\n      const fromPath = fromMatch?.pathname || this.latestLocation.pathname\n\n      invariant(\n        dest.from == null || fromMatch != null,\n        'Could not find match for from: ' + dest.from,\n      )\n\n      const fromSearch = last(fromMatches)?.search || this.latestLocation.search\n\n      const stayingMatches = matches?.filter((d) =>\n        fromMatches.find((e) => e.routeId === d.routeId),\n      )\n\n      const fromRouteByFromPathRouteId =\n        this.routesById[\n          stayingMatches?.find((d) => d.pathname === fromPath)?.routeId\n        ]\n\n      let pathname = dest.to\n        ? this.resolvePathWithBase(fromPath, `${dest.to}`)\n        : this.resolvePathWithBase(\n            fromPath,\n            fromRouteByFromPathRouteId?.to ?? fromPath,\n          )\n\n      const prevParams = { ...last(fromMatches)?.params }\n\n      let nextParams =\n        (dest.params ?? true) === true\n          ? prevParams\n          : { ...prevParams, ...functionalUpdate(dest.params, prevParams) }\n\n      if (Object.keys(nextParams).length > 0) {\n        matches\n          ?.map((d) => {\n            const route = this.looseRoutesById[d.routeId]\n            return (\n              route?.options.params?.stringify ?? route!.options.stringifyParams\n            )\n          })\n          .filter(Boolean)\n          .forEach((fn) => {\n            nextParams = { ...nextParams!, ...fn!(nextParams) }\n          })\n      }\n\n      pathname = interpolatePath({\n        path: pathname,\n        params: nextParams ?? {},\n        leaveWildcards: false,\n        leaveParams: opts.leaveParams,\n      })\n\n      const preSearchFilters =\n        stayingMatches\n          ?.map(\n            (match) =>\n              this.looseRoutesById[match.routeId]!.options.preSearchFilters ??\n              [],\n          )\n          .flat()\n          .filter(Boolean) ?? []\n\n      const postSearchFilters =\n        stayingMatches\n          ?.map(\n            (match) =>\n              this.looseRoutesById[match.routeId]!.options.postSearchFilters ??\n              [],\n          )\n          .flat()\n          .filter(Boolean) ?? []\n\n      // Pre filters first\n      const preFilteredSearch = preSearchFilters.length\n        ? preSearchFilters.reduce((prev, next) => next(prev), fromSearch)\n        : fromSearch\n\n      // Then the link/navigate function\n      const destSearch =\n        dest.search === true\n          ? preFilteredSearch // Preserve resolvedFrom true\n          : dest.search\n            ? functionalUpdate(dest.search, preFilteredSearch) // Updater\n            : preSearchFilters.length\n              ? preFilteredSearch // Preserve resolvedFrom filters\n              : {}\n\n      // Then post filters\n      const postFilteredSearch = postSearchFilters.length\n        ? postSearchFilters.reduce((prev, next) => next(prev), destSearch)\n        : destSearch\n\n      const search = replaceEqualDeep(fromSearch, postFilteredSearch)\n\n      const searchStr = this.options.stringifySearch(search)\n\n      const hash =\n        dest.hash === true\n          ? this.latestLocation.hash\n          : dest.hash\n            ? functionalUpdate(dest.hash, this.latestLocation.hash)\n            : undefined\n\n      const hashStr = hash ? `#${hash}` : ''\n\n      let nextState =\n        dest.state === true\n          ? this.latestLocation.state\n          : dest.state\n            ? functionalUpdate(dest.state, this.latestLocation.state)\n            : {}\n\n      nextState = replaceEqualDeep(this.latestLocation.state, nextState)\n\n      return {\n        pathname,\n        search,\n        searchStr,\n        state: nextState as any,\n        hash: hash ?? '',\n        href: `${pathname}${searchStr}${hashStr}`,\n        unmaskOnReload: dest.unmaskOnReload,\n      }\n    }\n\n    const buildWithMatches = (\n      dest: BuildNextOptions = {},\n      maskedDest?: BuildNextOptions,\n    ) => {\n      const next = build(dest)\n      let maskedNext = maskedDest ? build(maskedDest) : undefined\n\n      if (!maskedNext) {\n        let params = {}\n\n        const foundMask = this.options.routeMasks?.find((d) => {\n          const match = matchPathname(this.basepath, next.pathname, {\n            to: d.from,\n            caseSensitive: false,\n            fuzzy: false,\n          })\n\n          if (match) {\n            params = match\n            return true\n          }\n\n          return false\n        })\n\n        if (foundMask) {\n          const { from, ...maskProps } = foundMask\n          maskedDest = {\n            ...pick(opts, ['from']),\n            ...maskProps,\n            params,\n          }\n          maskedNext = build(maskedDest)\n        }\n      }\n\n      const nextMatches = this.matchRoutes(next.pathname, next.search)\n      const maskedMatches = maskedNext\n        ? this.matchRoutes(maskedNext.pathname, maskedNext.search)\n        : undefined\n      const maskedFinal = maskedNext\n        ? build(maskedDest, maskedMatches)\n        : undefined\n\n      const final = build(dest, nextMatches)\n\n      if (maskedFinal) {\n        final.maskedLocation = maskedFinal\n      }\n\n      return final\n    }\n\n    if (opts.mask) {\n      return buildWithMatches(opts, {\n        ...pick(opts, ['from']),\n        ...opts.mask,\n      })\n    }\n\n    return buildWithMatches(opts)\n  }\n\n  commitLocationPromise: undefined | ControlledPromise<void>\n\n  commitLocation = ({\n    viewTransition,\n    ignoreBlocker,\n    ...next\n  }: ParsedLocation & CommitLocationOptions): Promise<void> => {\n    const isSameState = () => {\n      // `state.key` is ignored but may still be provided when navigating,\n      // temporarily add the previous key to the next state so it doesn't affect\n      // the comparison\n\n      next.state.key = this.latestLocation.state.key\n      const isEqual = deepEqual(next.state, this.latestLocation.state)\n      delete next.state.key\n      return isEqual\n    }\n\n    const isSameUrl = this.latestLocation.href === next.href\n\n    const previousCommitPromise = this.commitLocationPromise\n    this.commitLocationPromise = createControlledPromise<void>(() => {\n      previousCommitPromise?.resolve()\n    })\n\n    // Don't commit to history if nothing changed\n    if (isSameUrl && isSameState()) {\n      this.load()\n    } else {\n      // eslint-disable-next-line prefer-const\n      let { maskedLocation, ...nextHistory } = next\n\n      if (maskedLocation) {\n        nextHistory = {\n          ...maskedLocation,\n          state: {\n            ...maskedLocation.state,\n            __tempKey: undefined,\n            __tempLocation: {\n              ...nextHistory,\n              search: nextHistory.searchStr,\n              state: {\n                ...nextHistory.state,\n                __tempKey: undefined!,\n                __tempLocation: undefined!,\n                key: undefined!,\n              },\n            },\n          },\n        }\n\n        if (\n          nextHistory.unmaskOnReload ??\n          this.options.unmaskOnReload ??\n          false\n        ) {\n          nextHistory.state.__tempKey = this.tempLocationKey\n        }\n      }\n\n      this.shouldViewTransition = viewTransition\n\n      this.history[next.replace ? 'replace' : 'push'](\n        nextHistory.href,\n        nextHistory.state,\n        { ignoreBlocker },\n      )\n    }\n\n    this.resetNextScroll = next.resetScroll ?? true\n\n    if (!this.history.subscribers.size) {\n      this.load()\n    }\n\n    return this.commitLocationPromise\n  }\n\n  buildAndCommitLocation = ({\n    replace,\n    resetScroll,\n    viewTransition,\n    ignoreBlocker,\n    ...rest\n  }: BuildNextOptions & CommitLocationOptions = {}) => {\n    const location = this.buildLocation(rest as any)\n    return this.commitLocation({\n      ...location,\n      viewTransition,\n      replace,\n      resetScroll,\n      ignoreBlocker,\n    })\n  }\n\n  navigate: NavigateFn = ({ from, to, __isRedirect, ...rest }) => {\n    // If this link simply reloads the current route,\n    // make sure it has a new key so it will trigger a data refresh\n\n    // If this `to` is a valid external URL, return\n    // null for LinkUtils\n    const toString = String(to)\n    // const fromString = from !== undefined ? String(from) : from\n    let isExternal\n\n    try {\n      new URL(`${toString}`)\n      isExternal = true\n    } catch (e) {}\n\n    invariant(\n      !isExternal,\n      'Attempting to navigate to external url with router.navigate!',\n    )\n\n    return this.buildAndCommitLocation({\n      ...rest,\n      from,\n      to,\n      // to: toString,\n    })\n  }\n\n  latestLoadPromise: undefined | Promise<void>\n\n  load = async (): Promise<void> => {\n    this.latestLocation = this.parseLocation(this.latestLocation)\n\n    this.__store.setState((s) => ({\n      ...s,\n      loadedAt: Date.now(),\n    }))\n\n    let redirect: ResolvedRedirect | undefined\n    let notFound: NotFoundError | undefined\n\n    const loadPromise = new Promise<void>((resolve) => {\n      this.startReactTransition(async () => {\n        try {\n          const next = this.latestLocation\n          const prevLocation = this.state.resolvedLocation\n          const pathDidChange = prevLocation.href !== next.href\n\n          // Cancel any pending matches\n          this.cancelMatches()\n\n          let pendingMatches!: Array<AnyRouteMatch>\n\n          this.__store.batch(() => {\n            // this call breaks a route context of destination route after a redirect\n            // we should be fine not eagerly calling this since we call it later\n            // this.cleanCache()\n\n            // Match the routes\n            pendingMatches = this.matchRoutes(next.pathname, next.search)\n\n            // Ingest the new matches\n            this.__store.setState((s) => ({\n              ...s,\n              status: 'pending',\n              isLoading: true,\n              location: next,\n              pendingMatches,\n              // If a cached moved to pendingMatches, remove it from cachedMatches\n              cachedMatches: s.cachedMatches.filter((d) => {\n                return !pendingMatches.find((e) => e.id === d.id)\n              }),\n            }))\n          })\n\n          if (!this.state.redirect) {\n            this.emit({\n              type: 'onBeforeNavigate',\n              fromLocation: prevLocation,\n              toLocation: next,\n              pathChanged: pathDidChange,\n            })\n          }\n\n          this.emit({\n            type: 'onBeforeLoad',\n            fromLocation: prevLocation,\n            toLocation: next,\n            pathChanged: pathDidChange,\n          })\n\n          await this.loadMatches({\n            matches: pendingMatches,\n            location: next,\n            // eslint-disable-next-line ts/require-await\n            onReady: async () => {\n              // eslint-disable-next-line ts/require-await\n              this.startViewTransition(async () => {\n                // this.viewTransitionPromise = createControlledPromise<true>()\n\n                // Commit the pending matches. If a previous match was\n                // removed, place it in the cachedMatches\n                let exitingMatches!: Array<AnyRouteMatch>\n                let enteringMatches!: Array<AnyRouteMatch>\n                let stayingMatches!: Array<AnyRouteMatch>\n\n                this.__store.batch(() => {\n                  this.__store.setState((s) => {\n                    const previousMatches = s.matches\n                    const newMatches = s.pendingMatches || s.matches\n\n                    exitingMatches = previousMatches.filter(\n                      (match) => !newMatches.find((d) => d.id === match.id),\n                    )\n                    enteringMatches = newMatches.filter(\n                      (match) =>\n                        !previousMatches.find((d) => d.id === match.id),\n                    )\n                    stayingMatches = previousMatches.filter((match) =>\n                      newMatches.find((d) => d.id === match.id),\n                    )\n\n                    return {\n                      ...s,\n                      isLoading: false,\n                      matches: newMatches,\n                      pendingMatches: undefined,\n                      cachedMatches: [\n                        ...s.cachedMatches,\n                        ...exitingMatches.filter((d) => d.status !== 'error'),\n                      ],\n                    }\n                  })\n                  this.cleanCache()\n                })\n\n                //\n                ;(\n                  [\n                    [exitingMatches, 'onLeave'],\n                    [enteringMatches, 'onEnter'],\n                    [stayingMatches, 'onStay'],\n                  ] as const\n                ).forEach(([matches, hook]) => {\n                  matches.forEach((match) => {\n                    this.looseRoutesById[match.routeId]!.options[hook]?.(match)\n                  })\n                })\n              })\n            },\n          })\n        } catch (err) {\n          if (isResolvedRedirect(err)) {\n            redirect = err\n            if (!this.isServer) {\n              this.navigate({ ...err, replace: true, __isRedirect: true })\n            }\n          } else if (isNotFound(err)) {\n            notFound = err\n          }\n\n          this.__store.setState((s) => ({\n            ...s,\n            statusCode: redirect\n              ? redirect.statusCode\n              : notFound\n                ? 404\n                : s.matches.some((d) => d.status === 'error')\n                  ? 500\n                  : 200,\n            redirect,\n          }))\n        }\n\n        if (this.latestLoadPromise === loadPromise) {\n          this.commitLocationPromise?.resolve()\n          this.latestLoadPromise = undefined\n          this.commitLocationPromise = undefined\n        }\n        resolve()\n      })\n    })\n\n    this.latestLoadPromise = loadPromise\n\n    await loadPromise\n\n    while (\n      (this.latestLoadPromise as any) &&\n      loadPromise !== this.latestLoadPromise\n    ) {\n      await this.latestLoadPromise\n    }\n  }\n\n  startViewTransition = (fn: () => Promise<void>) => {\n    // Determine if we should start a view transition from the navigation\n    // or from the router default\n    const shouldViewTransition =\n      this.shouldViewTransition ?? this.options.defaultViewTransition\n\n    // Reset the view transition flag\n    delete this.shouldViewTransition\n    // Attempt to start a view transition (or just apply the changes if we can't)\n    ;(shouldViewTransition && typeof document !== 'undefined'\n      ? document\n      : undefined\n    )\n      // @ts-expect-error\n      ?.startViewTransition?.(fn) || fn()\n  }\n\n  updateMatch = (\n    id: string,\n    updater: (match: AnyRouteMatch) => AnyRouteMatch,\n  ) => {\n    let updated!: AnyRouteMatch\n    const isPending = this.state.pendingMatches?.find((d) => d.id === id)\n    const isMatched = this.state.matches.find((d) => d.id === id)\n\n    const matchesKey = isPending\n      ? 'pendingMatches'\n      : isMatched\n        ? 'matches'\n        : 'cachedMatches'\n\n    this.__store.setState((s) => ({\n      ...s,\n      [matchesKey]: s[matchesKey]?.map((d) =>\n        d.id === id ? (updated = updater(d)) : d,\n      ),\n    }))\n\n    return updated\n  }\n\n  getMatch = (matchId: string) => {\n    return [\n      ...this.state.cachedMatches,\n      ...(this.state.pendingMatches ?? []),\n      ...this.state.matches,\n    ].find((d) => d.id === matchId)\n  }\n\n  loadMatches = async ({\n    location,\n    matches,\n    preload,\n    onReady,\n    updateMatch = this.updateMatch,\n  }: {\n    location: ParsedLocation\n    matches: Array<AnyRouteMatch>\n    preload?: boolean\n    onReady?: () => Promise<void>\n    updateMatch?: (\n      id: string,\n      updater: (match: AnyRouteMatch) => AnyRouteMatch,\n    ) => void\n    getMatch?: (matchId: string) => AnyRouteMatch | undefined\n  }): Promise<Array<MakeRouteMatch>> => {\n    let firstBadMatchIndex: number | undefined\n    let rendered = false\n\n    const triggerOnReady = async () => {\n      if (!rendered) {\n        rendered = true\n        await onReady?.()\n      }\n    }\n\n    if (!this.isServer && !this.state.matches.length) {\n      triggerOnReady()\n    }\n\n    const handleRedirectAndNotFound = (match: AnyRouteMatch, err: any) => {\n      if (isResolvedRedirect(err)) throw err\n\n      if (isRedirect(err) || isNotFound(err)) {\n        updateMatch(match.id, (prev) => ({\n          ...prev,\n          status: isRedirect(err)\n            ? 'redirected'\n            : isNotFound(err)\n              ? 'notFound'\n              : 'error',\n          isFetching: false,\n          error: err,\n          beforeLoadPromise: undefined,\n          loaderPromise: undefined,\n        }))\n\n        if (!(err as any).routeId) {\n          ;(err as any).routeId = match.routeId\n        }\n\n        match.beforeLoadPromise?.resolve()\n        match.loaderPromise?.resolve()\n        match.loadPromise?.resolve()\n\n        if (isRedirect(err)) {\n          rendered = true\n          err = this.resolveRedirect({ ...err, _fromLocation: location })\n          throw err\n        } else if (isNotFound(err)) {\n          this._handleNotFound(matches, err, {\n            updateMatch,\n          })\n          throw err\n        }\n      }\n    }\n\n    try {\n      await new Promise<void>((resolveAll, rejectAll) => {\n        ;(async () => {\n          try {\n            const handleSerialError = (\n              index: number,\n              err: any,\n              routerCode: string,\n            ) => {\n              const { id: matchId, routeId } = matches[index]!\n              const route = this.looseRoutesById[routeId]!\n\n              // Much like suspense, we use a promise here to know if\n              // we've been outdated by a new loadMatches call and\n              // should abort the current async operation\n              if (err instanceof Promise) {\n                throw err\n              }\n\n              err.routerCode = routerCode\n              firstBadMatchIndex = firstBadMatchIndex ?? index\n              handleRedirectAndNotFound(this.getMatch(matchId)!, err)\n\n              try {\n                route.options.onError?.(err)\n              } catch (errorHandlerErr) {\n                err = errorHandlerErr\n                handleRedirectAndNotFound(this.getMatch(matchId)!, err)\n              }\n\n              updateMatch(matchId, (prev) => {\n                prev.beforeLoadPromise?.resolve()\n\n                return {\n                  ...prev,\n                  error: err,\n                  status: 'error',\n                  isFetching: false,\n                  updatedAt: Date.now(),\n                  abortController: new AbortController(),\n                  beforeLoadPromise: undefined,\n                }\n              })\n            }\n\n            for (const [index, { id: matchId, routeId }] of matches.entries()) {\n              const existingMatch = this.getMatch(matchId)!\n\n              if (\n                // If we are in the middle of a load, either of these will be present\n                // (not to be confused with `loadPromise`, which is always defined)\n                existingMatch.beforeLoadPromise ||\n                existingMatch.loaderPromise\n              ) {\n                // Wait for the beforeLoad to resolve before we continue\n                await existingMatch.beforeLoadPromise\n              } else {\n                // If we are not in the middle of a load, start it\n                try {\n                  updateMatch(matchId, (prev) => ({\n                    ...prev,\n                    loadPromise: createControlledPromise<void>(() => {\n                      prev.loadPromise?.resolve()\n                    }),\n                    beforeLoadPromise: createControlledPromise<void>(),\n                  }))\n\n                  const route = this.looseRoutesById[routeId]!\n                  const abortController = new AbortController()\n\n                  const parentMatchId = matches[index - 1]?.id\n\n                  const getParentContext = () => {\n                    if (!parentMatchId) {\n                      return (this.options.context as any) ?? {}\n                    }\n\n                    return (\n                      this.getMatch(parentMatchId)!.context ??\n                      this.options.context ??\n                      {}\n                    )\n                  }\n\n                  const pendingMs =\n                    route.options.pendingMs ?? this.options.defaultPendingMs\n\n                  const shouldPending = !!(\n                    onReady &&\n                    !this.isServer &&\n                    !preload &&\n                    (route.options.loader || route.options.beforeLoad) &&\n                    typeof pendingMs === 'number' &&\n                    pendingMs !== Infinity &&\n                    (route.options.pendingComponent ??\n                      this.options.defaultPendingComponent)\n                  )\n\n                  let pendingTimeout: ReturnType<typeof setTimeout>\n\n                  if (shouldPending) {\n                    // If we might show a pending component, we need to wait for the\n                    // pending promise to resolve before we start showing that state\n                    pendingTimeout = setTimeout(() => {\n                      try {\n                        // Update the match and prematurely resolve the loadMatches promise so that\n                        // the pending component can start rendering\n                        triggerOnReady()\n                      } catch {}\n                    }, pendingMs)\n                  }\n\n                  const { paramsError, searchError } = this.getMatch(matchId)!\n\n                  if (paramsError) {\n                    handleSerialError(index, paramsError, 'PARSE_PARAMS')\n                  }\n\n                  if (searchError) {\n                    handleSerialError(index, searchError, 'VALIDATE_SEARCH')\n                  }\n\n                  const parentContext = getParentContext()\n\n                  updateMatch(matchId, (prev) => ({\n                    ...prev,\n                    isFetching: 'beforeLoad',\n                    fetchCount: prev.fetchCount + 1,\n                    routeContext: replaceEqualDeep(\n                      prev.routeContext,\n                      parentContext,\n                    ),\n                    context: replaceEqualDeep(prev.context, parentContext),\n                    abortController,\n                    pendingTimeout,\n                  }))\n\n                  const { search, params, routeContext, cause } =\n                    this.getMatch(matchId)!\n\n                  const beforeLoadFnContext = {\n                    search,\n                    abortController,\n                    params,\n                    preload: !!preload,\n                    context: routeContext,\n                    location,\n                    navigate: (opts: any) =>\n                      this.navigate({ ...opts, _fromLocation: location }),\n                    buildLocation: this.buildLocation,\n                    cause: preload ? 'preload' : cause,\n                  }\n\n                  const beforeLoadContext =\n                    (await route.options.beforeLoad?.(beforeLoadFnContext)) ??\n                    {}\n\n                  if (\n                    isRedirect(beforeLoadContext) ||\n                    isNotFound(beforeLoadContext)\n                  ) {\n                    handleSerialError(index, beforeLoadContext, 'BEFORE_LOAD')\n                  }\n\n                  updateMatch(matchId, (prev) => {\n                    const routeContext = {\n                      ...prev.routeContext,\n                      ...beforeLoadContext,\n                    }\n\n                    return {\n                      ...prev,\n                      routeContext: replaceEqualDeep(\n                        prev.routeContext,\n                        routeContext,\n                      ),\n                      context: replaceEqualDeep(prev.context, routeContext),\n                      abortController,\n                    }\n                  })\n                } catch (err) {\n                  handleSerialError(index, err, 'BEFORE_LOAD')\n                }\n\n                updateMatch(matchId, (prev) => {\n                  prev.beforeLoadPromise?.resolve()\n\n                  return {\n                    ...prev,\n                    beforeLoadPromise: undefined,\n                    isFetching: false,\n                  }\n                })\n              }\n            }\n\n            const validResolvedMatches = matches.slice(0, firstBadMatchIndex)\n            const matchPromises: Array<Promise<any>> = []\n\n            validResolvedMatches.forEach(({ id: matchId, routeId }, index) => {\n              matchPromises.push(\n                (async () => {\n                  const { loaderPromise: prevLoaderPromise } =\n                    this.getMatch(matchId)!\n\n                  if (prevLoaderPromise) {\n                    await prevLoaderPromise\n                  } else {\n                    const parentMatchPromise = matchPromises[index - 1]\n                    const route = this.looseRoutesById[routeId]!\n\n                    const getLoaderContext = (): LoaderFnContext => {\n                      const {\n                        params,\n                        loaderDeps,\n                        abortController,\n                        context,\n                        cause,\n                      } = this.getMatch(matchId)!\n\n                      return {\n                        params,\n                        deps: loaderDeps,\n                        preload: !!preload,\n                        parentMatchPromise,\n                        abortController: abortController,\n                        context,\n                        location,\n                        navigate: (opts) =>\n                          this.navigate({ ...opts, _fromLocation: location }),\n                        cause: preload ? 'preload' : cause,\n                        route,\n                      }\n                    }\n\n                    // This is where all of the stale-while-revalidate magic happens\n                    const age = Date.now() - this.getMatch(matchId)!.updatedAt\n\n                    const staleAge = preload\n                      ? (route.options.preloadStaleTime ??\n                        this.options.defaultPreloadStaleTime ??\n                        30_000) // 30 seconds for preloads by default\n                      : (route.options.staleTime ??\n                        this.options.defaultStaleTime ??\n                        0)\n\n                    const shouldReloadOption = route.options.shouldReload\n\n                    // Default to reloading the route all the time\n                    // Allow shouldReload to get the last say,\n                    // if provided.\n                    const shouldReload =\n                      typeof shouldReloadOption === 'function'\n                        ? shouldReloadOption(getLoaderContext())\n                        : shouldReloadOption\n\n                    updateMatch(matchId, (prev) => ({\n                      ...prev,\n                      loaderPromise: createControlledPromise<void>(),\n                      preload:\n                        !!preload &&\n                        !this.state.matches.find((d) => d.id === matchId),\n                    }))\n\n                    const runLoader = async () => {\n                      try {\n                        // If the Matches component rendered\n                        // the pending component and needs to show it for\n                        // a minimum duration, we''ll wait for it to resolve\n                        // before committing to the match and resolving\n                        // the loadPromise\n                        const potentialPendingMinPromise = async () => {\n                          const latestMatch = this.getMatch(matchId)!\n\n                          if (latestMatch.minPendingPromise) {\n                            await latestMatch.minPendingPromise\n                          }\n                        }\n\n                        // Actually run the loader and handle the result\n                        try {\n                          route._lazyPromise =\n                            route._lazyPromise ||\n                            (route.lazyFn\n                              ? route.lazyFn().then((lazyRoute) => {\n                                  Object.assign(\n                                    route.options,\n                                    lazyRoute.options,\n                                  )\n                                })\n                              : Promise.resolve())\n\n                          // If for some reason lazy resolves more lazy components...\n                          // We'll wait for that before pre attempt to preload any\n                          // components themselves.\n                          const componentsPromise =\n                            this.getMatch(matchId)!.componentsPromise ||\n                            route._lazyPromise.then(() =>\n                              Promise.all(\n                                componentTypes.map(async (type) => {\n                                  const component = route.options[type]\n\n                                  if ((component as any)?.preload) {\n                                    await (component as any).preload()\n                                  }\n                                }),\n                              ),\n                            )\n\n                          // Otherwise, load the route\n                          updateMatch(matchId, (prev) => ({\n                            ...prev,\n                            isFetching: 'loader',\n                            componentsPromise,\n                          }))\n\n                          // Lazy option can modify the route options,\n                          // so we need to wait for it to resolve before\n                          // we can use the options\n                          await route._lazyPromise\n\n                          // Kick off the loader!\n                          let loaderData =\n                            await route.options.loader?.(getLoaderContext())\n\n                          if (this.serializeLoaderData) {\n                            loaderData = this.serializeLoaderData(loaderData, {\n                              router: this,\n                              match: this.getMatch(matchId)!,\n                            })\n                          }\n\n                          handleRedirectAndNotFound(\n                            this.getMatch(matchId)!,\n                            loaderData,\n                          )\n\n                          await potentialPendingMinPromise()\n\n                          const meta = route.options.meta?.({\n                            matches,\n                            match: this.getMatch(matchId)!,\n                            params: this.getMatch(matchId)!.params,\n                            loaderData,\n                          })\n\n                          const headers = route.options.headers?.({\n                            loaderData,\n                          })\n\n                          updateMatch(matchId, (prev) => ({\n                            ...prev,\n                            error: undefined,\n                            status: 'success',\n                            isFetching: false,\n                            updatedAt: Date.now(),\n                            loaderData,\n                            meta,\n                            headers,\n                          }))\n                        } catch (e) {\n                          let error = e\n\n                          await potentialPendingMinPromise()\n\n                          handleRedirectAndNotFound(this.getMatch(matchId)!, e)\n\n                          try {\n                            route.options.onError?.(e)\n                          } catch (onErrorError) {\n                            error = onErrorError\n                            handleRedirectAndNotFound(\n                              this.getMatch(matchId)!,\n                              onErrorError,\n                            )\n                          }\n\n                          updateMatch(matchId, (prev) => ({\n                            ...prev,\n                            error,\n                            status: 'error',\n                            isFetching: false,\n                          }))\n                        }\n\n                        // Last but not least, wait for the the component\n                        // to be preloaded before we resolve the match\n                        await this.getMatch(matchId)!.componentsPromise\n                      } catch (err) {\n                        handleRedirectAndNotFound(this.getMatch(matchId)!, err)\n                      }\n                    }\n\n                    // If the route is successful and still fresh, just resolve\n                    const { status, invalid } = this.getMatch(matchId)!\n\n                    if (\n                      status === 'success' &&\n                      (invalid || (shouldReload ?? age > staleAge))\n                    ) {\n                      ;(async () => {\n                        try {\n                          await runLoader()\n                        } catch (err) {}\n                      })()\n                    } else if (status !== 'success') {\n                      await runLoader()\n                    }\n\n                    const { loaderPromise, loadPromise } =\n                      this.getMatch(matchId)!\n\n                    loaderPromise?.resolve()\n                    loadPromise?.resolve()\n                  }\n\n                  updateMatch(matchId, (prev) => ({\n                    ...prev,\n                    isFetching: false,\n                    loaderPromise: undefined,\n                  }))\n                })(),\n              )\n            })\n\n            await Promise.all(matchPromises)\n\n            resolveAll()\n          } catch (err) {\n            rejectAll(err)\n          }\n        })()\n      })\n      await triggerOnReady()\n    } catch (err) {\n      if (isRedirect(err) || isNotFound(err)) {\n        if (isNotFound(err) && !preload) {\n          await triggerOnReady()\n        }\n        throw err\n      }\n    }\n\n    return matches\n  }\n\n  invalidate = () => {\n    const invalidate = (d: MakeRouteMatch<TRouteTree>) => ({\n      ...d,\n      invalid: true,\n      ...(d.status === 'error'\n        ? ({ status: 'pending', error: undefined } as const)\n        : {}),\n    })\n\n    this.__store.setState((s) => ({\n      ...s,\n      matches: s.matches.map(invalidate),\n      cachedMatches: s.cachedMatches.map(invalidate),\n      pendingMatches: s.pendingMatches?.map(invalidate),\n    }))\n\n    return this.load()\n  }\n\n  resolveRedirect = (err: AnyRedirect): ResolvedRedirect => {\n    const redirect = err as ResolvedRedirect\n\n    if (!redirect.href) {\n      redirect.href = this.buildLocation(redirect as any).href\n    }\n\n    return redirect\n  }\n\n  cleanCache = () => {\n    // This is where all of the garbage collection magic happens\n    this.__store.setState((s) => {\n      return {\n        ...s,\n        cachedMatches: s.cachedMatches.filter((d) => {\n          const route = this.looseRoutesById[d.routeId]!\n\n          if (!route.options.loader) {\n            return false\n          }\n\n          // If the route was preloaded, use the preloadGcTime\n          // otherwise, use the gcTime\n          const gcTime =\n            (d.preload\n              ? (route.options.preloadGcTime ??\n                this.options.defaultPreloadGcTime)\n              : (route.options.gcTime ?? this.options.defaultGcTime)) ??\n            5 * 60 * 1000\n\n          return d.status !== 'error' && Date.now() - d.updatedAt < gcTime\n        }),\n      }\n    })\n  }\n\n  preloadRoute = async <\n    TFrom extends RoutePaths<TRouteTree> | string = string,\n    TTo extends string = '',\n    TMaskFrom extends RoutePaths<TRouteTree> | string = TFrom,\n    TMaskTo extends string = '',\n  >(\n    opts: NavigateOptions<\n      Router<TRouteTree, TTrailingSlashOption, TDehydrated, TSerializedError>,\n      TFrom,\n      TTo,\n      TMaskFrom,\n      TMaskTo\n    >,\n  ): Promise<Array<AnyRouteMatch> | undefined> => {\n    const next = this.buildLocation(opts as any)\n\n    let matches = this.matchRoutes(next.pathname, next.search, {\n      throwOnError: true,\n      preload: true,\n    })\n\n    const loadedMatchIds = Object.fromEntries(\n      [\n        ...this.state.matches,\n        ...(this.state.pendingMatches ?? []),\n        ...this.state.cachedMatches,\n      ].map((d) => [d.id, true]),\n    )\n\n    this.__store.batch(() => {\n      matches.forEach((match) => {\n        if (!loadedMatchIds[match.id]) {\n          this.__store.setState((s) => ({\n            ...s,\n            cachedMatches: [...(s.cachedMatches as any), match],\n          }))\n        }\n      })\n    })\n\n    const activeMatchIds = new Set(\n      [...this.state.matches, ...(this.state.pendingMatches ?? [])].map(\n        (d) => d.id,\n      ),\n    )\n\n    try {\n      matches = await this.loadMatches({\n        matches,\n        location: next,\n        preload: true,\n        updateMatch: (id, updater) => {\n          if (activeMatchIds.has(id)) {\n            matches = matches.map((d) => (d.id === id ? updater(d) : d))\n          } else {\n            this.updateMatch(id, updater)\n          }\n        },\n      })\n\n      return matches\n    } catch (err) {\n      if (isRedirect(err)) {\n        return await this.preloadRoute({\n          ...(err as any),\n          _fromLocation: next,\n        })\n      }\n      // Preload errors are not fatal, but we should still log them\n      console.error(err)\n      return undefined\n    }\n  }\n\n  matchRoute = <\n    TFrom extends RoutePaths<TRouteTree> = '/',\n    TTo extends string = '',\n    TResolved = ResolveRelativePath<TFrom, NoInfer<TTo>>,\n  >(\n    location: ToOptions<\n      Router<TRouteTree, TTrailingSlashOption, TDehydrated, TSerializedError>,\n      TFrom,\n      TTo\n    >,\n    opts?: MatchRouteOptions,\n  ): false | RouteById<TRouteTree, TResolved>['types']['allParams'] => {\n    const matchLocation = {\n      ...location,\n      to: location.to\n        ? this.resolvePathWithBase((location.from || '') as string, location.to)\n        : undefined,\n      params: location.params || {},\n      leaveParams: true,\n    }\n    const next = this.buildLocation(matchLocation as any)\n\n    if (opts?.pending && this.state.status !== 'pending') {\n      return false\n    }\n\n    const pending =\n      opts?.pending === undefined ? !this.state.isLoading : opts.pending\n\n    const baseLocation = pending\n      ? this.latestLocation\n      : this.state.resolvedLocation\n\n    const match = matchPathname(this.basepath, baseLocation.pathname, {\n      ...opts,\n      to: next.pathname,\n    }) as any\n\n    if (!match) {\n      return false\n    }\n    if (location.params) {\n      if (!deepEqual(match, location.params, true)) {\n        return false\n      }\n    }\n\n    if (match && (opts?.includeSearch ?? true)) {\n      return deepEqual(baseLocation.search, next.search, true) ? match : false\n    }\n\n    return match\n  }\n\n  dehydrate = (): DehydratedRouter => {\n    const pickError =\n      this.options.errorSerializer?.serialize ?? defaultSerializeError\n\n    return {\n      state: {\n        dehydratedMatches: this.state.matches.map((d) => {\n          return {\n            ...pick(d, ['id', 'status', 'updatedAt']),\n            // If an error occurs server-side during SSRing,\n            // send a small subset of the error to the client\n            error: d.error\n              ? {\n                  data: pickError(d.error),\n                  __isServerError: true,\n                }\n              : undefined,\n            // NOTE: We don't send the loader data here, because\n            // there is a potential that it needs to be streamed.\n            // Instead, we render it next to the route match in the HTML\n            // which gives us the potential to stream it via suspense.\n          }\n        }),\n      },\n      manifest: this.manifest,\n    }\n  }\n\n  hydrate = () => {\n    // Client hydrates from window\n    let ctx: HydrationCtx | undefined\n\n    if (typeof document !== 'undefined') {\n      ctx = this.options.transformer.parse(window.__TSR__?.dehydrated) as any\n    }\n\n    invariant(\n      ctx,\n      'Expected to find a dehydrated data on window.__TSR__.dehydrated... but we did not. Please file an issue!',\n    )\n\n    this.dehydratedData = ctx.payload as any\n    this.options.hydrate?.(ctx.payload as any)\n    const dehydratedState = ctx.router.state\n\n    const matches = this.matchRoutes(\n      this.state.location.pathname,\n      this.state.location.search,\n    ).map((match) => {\n      const dehydratedMatch = dehydratedState.dehydratedMatches.find(\n        (d) => d.id === match.id,\n      )\n\n      invariant(\n        dehydratedMatch,\n        `Could not find a client-side match for dehydrated match with id: ${match.id}!`,\n      )\n\n      return {\n        ...match,\n        ...dehydratedMatch,\n      }\n    })\n\n    this.__store.setState((s) => {\n      return {\n        ...s,\n        matches: matches as any,\n      }\n    })\n\n    this.manifest = ctx.router.manifest\n  }\n\n  injectedHtml: Array<() => string> = []\n  injectHtml: (html: string) => void = (html) => {\n    const cb = () => {\n      this.injectedHtml = this.injectedHtml.filter((d) => d !== cb)\n      return html\n    }\n\n    this.injectedHtml.push(cb)\n  }\n  streamedKeys: Set<string> = new Set()\n\n  getStreamedValue = <T>(key: string): T | undefined => {\n    if (this.isServer) {\n      return undefined\n    }\n\n    const streamedValue = window.__TSR__?.streamedValues[key]\n\n    if (!streamedValue) {\n      return\n    }\n\n    if (!streamedValue.parsed) {\n      streamedValue.parsed = this.options.transformer.parse(streamedValue.value)\n    }\n\n    return streamedValue.parsed\n  }\n\n  streamValue = (key: string, value: any) => {\n    warning(\n      !this.streamedKeys.has(key),\n      'Key has already been streamed: ' + key,\n    )\n\n    this.streamedKeys.add(key)\n    const children = `__TSR__.streamedValues['${key}'] = { value: ${this.serializer?.(this.options.transformer.stringify(value))}}`\n\n    this.injectHtml(\n      `<script class='tsr-once'>${children}${\n        process.env.NODE_ENV === 'development'\n          ? `; console.info(\\`Injected From Server:\n        ${children}\\`)`\n          : ''\n      }; __TSR__.cleanScripts()</script>`,\n    )\n  }\n\n  _handleNotFound = (\n    matches: Array<AnyRouteMatch>,\n    err: NotFoundError,\n    {\n      updateMatch = this.updateMatch,\n    }: {\n      updateMatch?: (\n        id: string,\n        updater: (match: AnyRouteMatch) => AnyRouteMatch,\n      ) => void\n    } = {},\n  ) => {\n    const matchesByRouteId = Object.fromEntries(\n      matches.map((match) => [match.routeId, match]),\n    ) as Record<string, AnyRouteMatch>\n\n    // Start at the route that errored or default to the root route\n    let routeCursor =\n      (err.global\n        ? this.looseRoutesById[rootRouteId]\n        : this.looseRoutesById[err.routeId]) ||\n      this.looseRoutesById[rootRouteId]!\n\n    // Go up the tree until we find a route with a notFoundComponent or we hit the root\n    while (\n      !routeCursor.options.notFoundComponent &&\n      !this.options.defaultNotFoundComponent &&\n      routeCursor.id !== rootRouteId\n    ) {\n      routeCursor = routeCursor.parentRoute\n\n      invariant(\n        routeCursor,\n        'Found invalid route tree while trying to find not-found handler.',\n      )\n    }\n\n    const match = matchesByRouteId[routeCursor.id]\n\n    invariant(match, 'Could not find match for route: ' + routeCursor.id)\n\n    // Assign the error to the match\n\n    updateMatch(match.id, (prev) => ({\n      ...prev,\n      status: 'notFound',\n      error: err,\n      isFetching: false,\n    }))\n\n    if ((err as any).routerCode === 'BEFORE_LOAD' && routeCursor.parentRoute) {\n      err.routeId = routeCursor.parentRoute.id\n      this._handleNotFound(matches, err, {\n        updateMatch,\n      })\n    }\n  }\n\n  hasNotFoundMatch = () => {\n    return this.__store.state.matches.some(\n      (d) => d.status === 'notFound' || d.globalNotFound,\n    )\n  }\n}\n\n// A function that takes an import() argument which is a function and returns a new function that will\n// proxy arguments from the caller to the imported function, retaining all type\n// information along the way\nexport function lazyFn<\n  T extends Record<string, (...args: Array<any>) => any>,\n  TKey extends keyof T = 'default',\n>(fn: () => Promise<T>, key?: TKey) {\n  return async (\n    ...args: Parameters<T[TKey]>\n  ): Promise<Awaited<ReturnType<T[TKey]>>> => {\n    const imported = await fn()\n    return imported[key || 'default'](...args)\n  }\n}\n\nexport class SearchParamError extends Error {}\n\nexport class PathParamError extends Error {}\n\nexport function getInitialRouterState(\n  location: ParsedLocation,\n): RouterState<any> {\n  return {\n    loadedAt: 0,\n    isLoading: false,\n    isTransitioning: false,\n    status: 'idle',\n    resolvedLocation: { ...location },\n    location,\n    matches: [],\n    pendingMatches: [],\n    cachedMatches: [],\n    statusCode: 200,\n  }\n}\n\nexport function defaultSerializeError(err: unknown) {\n  if (err instanceof Error) {\n    const obj = {\n      name: err.name,\n      message: err.message,\n    }\n\n    if (process.env.NODE_ENV === 'development') {\n      ;(obj as any).stack = err.stack\n    }\n\n    return obj\n  }\n\n  return {\n    data: err,\n  }\n}\n"],"names":["trimPath","createMemoryHistory","createBrowserHistory","Store","trimPathRight","trimPathLeft","parsePathname","replaceEqualDeep","path","resolvePath","cleanPath","matchPathname","rootRouteId","interpolatePath","joinPaths","createControlledPromise","last","functionalUpdate","_a","pick","deepEqual","notFound","isResolvedRedirect","isNotFound","isRedirect","_b","routeContext","_c","match","defaultStringifySearch","defaultParseSearch"],"mappings":"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"}