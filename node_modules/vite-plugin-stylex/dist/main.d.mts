import type { Plugin, ViteDevServer, Rollup } from "vite";
import babel from "@babel/core";
import { Options as StyleXOptions } from "@stylexjs/babel-plugin";
interface StyleXVitePluginOptions extends Partial<Pick<StyleXOptions, "test" | "classNamePrefix" | "unstable_moduleResolution" | "useRemForFontSize" | "importSources">> {
    /**
     * @deprecated Use `importSources` instead. You should be able to just replace `stylexImports` with `importSources` in your config.
     */
    stylexImports?: string[];
    /**
     * A map of aliases to their respective paths.
     *
     * @example
     *
     * ```ts
     * {
     *   "@/*": [path.resolve(__dirname, "src", "*")]
     * }
     * ```
     *
     * Ensure that the paths are absolute and that you include the `*` at the end of the path.
     */
    aliases?: {
        [alias: string]: string[];
    };
    /**
     * Define external modules that export StyleX styles.
     *
     * This is useful when you want to pull UI tokens or components from a separate package, like a Design System.
     *
     * @default ["@stylexjs/open-props"]
     */
    libraries?: string[];
}
export default function styleXVitePlugin({ unstable_moduleResolution, stylexImports, libraries: inputLibraries, ...options }?: Omit<StyleXVitePluginOptions, "dev" | "fileName">): ({
    name: string;
    enforce: "pre";
    configResolved(this: void, config: Readonly<Omit<import("vite").UserConfig, "plugins" | "css" | "assetsInclude" | "optimizeDeps" | "worker" | "build"> & {
        configFile: string | undefined;
        configFileDependencies: string[];
        inlineConfig: import("vite").InlineConfig;
        root: string;
        base: string;
        publicDir: string;
        cacheDir: string;
        command: "build" | "serve";
        mode: string;
        isWorker: boolean;
        isProduction: boolean;
        envDir: string;
        env: Record<string, any>;
        resolve: Required<import("vite").ResolveOptions> & {
            alias: import("vite").Alias[];
        };
        plugins: readonly Plugin<any>[];
        css: import("vite").ResolvedCSSOptions;
        esbuild: false | import("vite").ESBuildOptions;
        server: import("vite").ResolvedServerOptions;
        build: import("vite").ResolvedBuildOptions;
        preview: import("vite").ResolvedPreviewOptions;
        ssr: import("vite").ResolvedSSROptions;
        assetsInclude: (file: string) => boolean;
        logger: import("vite").Logger;
        createResolver: (options?: Partial<import("vite").InternalResolveOptions> | undefined) => import("vite").ResolveFn;
        optimizeDeps: import("vite").DepOptimizationOptions;
        worker: import("vite").ResolvedWorkerOptions;
        appType: import("vite").AppType;
        experimental: import("vite").ExperimentalOptions;
    } & import("vite").PluginHookUtils>): void;
    buildStart(this: Rollup.PluginContext): void;
    configureServer(this: void, _server: ViteDevServer): void;
    transform(this: Rollup.TransformPluginContext, inputCode: string, id: string, { ssr: isSSR }?: {
        ssr?: boolean | undefined;
    } | undefined): Promise<string | undefined>;
    shouldTransformCachedModule?: undefined;
    renderChunk?: undefined;
} | {
    name: string;
    shouldTransformCachedModule(this: Rollup.PluginContext, { id, meta }: {
        ast: Rollup.ProgramNode;
        code: string;
        id: string;
        meta: Rollup.CustomPluginOptions;
        moduleSideEffects: boolean | "no-treeshake";
        resolvedSources: Rollup.ResolvedIdMap;
        syntheticNamedExports: string | boolean;
    }): false;
    transform(this: Rollup.TransformPluginContext, inputCode: string, id: string): Promise<{
        code: string | undefined;
        map: {
            version: number;
            sources: string[];
            names: string[];
            sourceRoot?: string | undefined;
            sourcesContent?: string[] | undefined;
            mappings: string;
            file: string;
        } | null | undefined;
        meta: babel.BabelFileMetadata | undefined;
    } | undefined>;
    renderChunk(this: Rollup.PluginContext): Promise<void>;
    enforce?: undefined;
    configResolved?: undefined;
    buildStart?: undefined;
    configureServer?: undefined;
})[];
export {};
//# sourceMappingURL=main.d.mts.map