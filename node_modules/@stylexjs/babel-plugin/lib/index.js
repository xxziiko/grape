'use strict';

var t = require('@babel/types');
var path = require('path');
var helperModuleImports = require('@babel/helper-module-imports');
var require$$0 = require('postcss-value-parser');
var core = require('@babel/core');
var traverse = require('@babel/traverse');
var require$$0$1 = require('styleq');

function _interopNamespaceDefault(e) {
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n.default = e;
  return Object.freeze(n);
}

var t__namespace = /*#__PURE__*/_interopNamespaceDefault(t);

var name = "@stylexjs/stylex";

const DEFAULT_INJECT_PATH = '@stylexjs/stylex/lib/stylex-inject';
class StateManager {
  importPaths = new Set();
  stylexImport = new Set();
  stylexPropsImport = new Set();
  stylexCreateImport = new Set();
  stylexIncludeImport = new Set();
  stylexFirstThatWorksImport = new Set();
  stylexKeyframesImport = new Set();
  stylexDefineVarsImport = new Set();
  stylexCreateThemeImport = new Set();
  stylexTypesImport = new Set();
  injectImportInserted = null;
  styleMap = new Map();
  styleVars = new Map();
  styleVarsToKeep = new Set();
  inStyleXCreate = false;
  constructor(state) {
    this._state = state;
    state.file.metadata.stylex = [];
  }
  get options() {
    const options = this._state.opts || {};
    const opts = {
      ...options,
      dev: !!options.dev,
      test: !!options.test,
      runtimeInjection: options.runtimeInjection === true ? DEFAULT_INJECT_PATH : options.runtimeInjection ? options.runtimeInjection : options.dev ? DEFAULT_INJECT_PATH : undefined,
      classNamePrefix: options.classNamePrefix ?? 'x',
      importSources: [name, 'stylex', ...(options.importSources ?? [])],
      definedStylexCSSVariables: options.definedStylexCSSVariables ?? {},
      genConditionalClasses: !!options.genConditionalClasses,
      useRemForFontSize: !!options.useRemForFontSize,
      styleResolution: options.styleResolution ?? 'application-order',
      unstable_moduleResolution: options.unstable_moduleResolution ?? undefined,
      treeshakeCompensation: !!options.treeshakeCompensation
    };
    this._state.opts = opts;
    return this._state.opts;
  }
  get importPathString() {
    if (this.importPaths.has('@stylexjs/stylex')) {
      return '@stylexjs/stylex';
    }
    if (this.importPaths.size > 0) {
      return [...this.importPaths][0];
    }
    return '@stylexjs/stylex';
  }
  get importSources() {
    return this.options.importSources.map(source => typeof source === 'string' ? source : source.from);
  }
  importAs(source) {
    for (const importSource of this.options.importSources) {
      if (typeof importSource !== 'string' && importSource.from === source) {
        return importSource.as;
      }
    }
    return null;
  }
  get canReferenceTheme() {
    return !!this.inStyleXCreate;
  }
  get metadata() {
    return this._state.file.metadata;
  }
  get runtimeInjection() {
    return typeof this.options.runtimeInjection === 'string' ? {
      from: this.options.runtimeInjection
    } : this.options.runtimeInjection || null;
  }
  get isDev() {
    return !!this.options.dev;
  }
  get isTest() {
    return !!this.options.test;
  }
  get filename() {
    return this._state.filename;
  }
  get cssVars() {
    return this.options.definedStylexCSSVariables;
  }
  get treeshakeCompensation() {
    return !!this.options.treeshakeCompensation;
  }
  get fileNameForHashing() {
    const filename = this.filename;
    const themeFileExtension = this.options.unstable_moduleResolution?.themeFileExtension ?? '.stylex';
    if (filename == null || !matchesFileSuffix(themeFileExtension)(filename) || this.options.unstable_moduleResolution == null) {
      return null;
    }
    switch (this.options.unstable_moduleResolution.type) {
      case 'haste':
        return path.basename(filename);
      default:
        {
          const rootDir = this.options.unstable_moduleResolution.rootDir;
          return path.relative(rootDir, filename);
        }
    }
  }
  importPathResolver(importPath) {
    const sourceFilePath = this.filename;
    if (sourceFilePath == null) {
      return false;
    }
    switch (this.options.unstable_moduleResolution?.type) {
      case 'commonJS':
        {
          const rootDir = this.options.unstable_moduleResolution.rootDir;
          const themeFileExtension = this.options.unstable_moduleResolution.themeFileExtension ?? '.stylex';
          if (!matchesFileSuffix(themeFileExtension)(importPath)) {
            return false;
          }
          const resolvedFilePath = filePathResolver(importPath, sourceFilePath);
          return resolvedFilePath ? ['themeNameRef', path.relative(rootDir, resolvedFilePath)] : false;
        }
      case 'haste':
        {
          const themeFileExtension = this.options.unstable_moduleResolution.themeFileExtension ?? '.stylex';
          if (!matchesFileSuffix(themeFileExtension)(importPath)) {
            return false;
          }
          return ['themeNameRef', addFileExtension(importPath, sourceFilePath)];
        }
      case 'experimental_crossFileParsing':
        {
          const themeFileExtension = this.options.unstable_moduleResolution.themeFileExtension ?? '.stylex';
          if (!matchesFileSuffix(themeFileExtension)(importPath)) {
            return false;
          }
          const resolvedFilePath = filePathResolver(importPath, sourceFilePath);
          return resolvedFilePath ? ['filePath', resolvedFilePath] : false;
        }
      default:
        return false;
    }
  }
  addStyle(style) {
    this.metadata.stylex.push(style);
  }
  markComposedNamespace(memberExpression) {
    this.styleVarsToKeep.add(memberExpression);
  }
}
const filePathResolver = (relativeFilePath, sourceFilePath) => {
  const fileToLookFor = relativeFilePath;
  if (EXTENSIONS.some(ext => fileToLookFor.endsWith(ext))) {
    try {
      const resolvedFilePath = require.resolve(fileToLookFor, {
        paths: [path.dirname(sourceFilePath)]
      });
      return resolvedFilePath;
    } catch {}
  }
  for (const ext of EXTENSIONS) {
    try {
      const importPathStr = fileToLookFor.startsWith('.') ? fileToLookFor + ext : fileToLookFor;
      const resolvedFilePath = require.resolve(importPathStr, {
        paths: [path.dirname(sourceFilePath)]
      });
      return resolvedFilePath;
    } catch {}
  }
};
const EXTENSIONS = ['.js', '.ts', '.tsx', '.jsx', '.mjs', '.cjs'];
const addFileExtension = (importedFilePath, sourceFile) => {
  if (EXTENSIONS.some(ext => importedFilePath.endsWith(ext))) {
    return importedFilePath;
  }
  const fileExtension = path.extname(sourceFile);
  return importedFilePath + fileExtension;
};
const matchesFileSuffix = allowedSuffix => filename => filename.endsWith(`${allowedSuffix}.js`) || filename.endsWith(`${allowedSuffix}.ts`) || filename.endsWith(`${allowedSuffix}.tsx`) || filename.endsWith(`${allowedSuffix}.jsx`) || filename.endsWith(`${allowedSuffix}.mjs`) || filename.endsWith(`${allowedSuffix}.cjs`) || filename.endsWith(allowedSuffix);

function readImportDeclarations(path, state) {
  const {
    node
  } = path;
  if (node?.importKind === 'type' || node?.importKind === 'typeof') {
    return;
  }
  const sourcePath = node.source.value;
  if (state.importSources.includes(sourcePath)) {
    for (const specifier of node.specifiers) {
      if (specifier.type === 'ImportDefaultSpecifier' && state.importAs(sourcePath) === null) {
        state.importPaths.add(sourcePath);
        state.stylexImport.add(specifier.local.name);
      }
      if (specifier.type === 'ImportNamespaceSpecifier' && state.importAs(sourcePath) === null) {
        state.importPaths.add(sourcePath);
        state.stylexImport.add(specifier.local.name);
      }
      if (specifier.type === 'ImportSpecifier') {
        if (specifier.imported.type === 'Identifier' || specifier.imported.type === 'StringLiteral') {
          const importedName = specifier.imported.type === 'Identifier' ? specifier.imported.name : specifier.imported.value;
          const localName = specifier.local.name;
          if (state.importAs(sourcePath) === importedName) {
            state.importPaths.add(sourcePath);
            state.stylexImport.add(localName);
          }
          if (state.importAs(sourcePath) === null) {
            state.importPaths.add(sourcePath);
            if (importedName === 'create') {
              state.stylexCreateImport.add(localName);
            }
            if (importedName === 'props') {
              state.stylexPropsImport.add(localName);
            }
            if (importedName === 'keyframes') {
              state.stylexKeyframesImport.add(localName);
            }
            if (importedName === 'include') {
              state.stylexIncludeImport.add(localName);
            }
            if (importedName === 'firstThatWorks') {
              state.stylexFirstThatWorksImport.add(localName);
            }
            if (importedName === 'defineVars') {
              state.stylexDefineVarsImport.add(localName);
            }
            if (importedName === 'createTheme') {
              state.stylexCreateThemeImport.add(localName);
            }
            if (importedName === 'types') {
              state.stylexTypesImport.add(localName);
            }
          }
        }
      }
    }
  }
}
function readRequires(path, state) {
  const {
    node
  } = path;
  const init = node.init;
  if (init != null && init.type === 'CallExpression' && init.callee?.type === 'Identifier' && init.callee?.name === 'require' && init.arguments?.length === 1 && init.arguments?.[0].type === 'StringLiteral' && state.importSources.includes(init.arguments[0].value)) {
    const importPath = init.arguments[0].value;
    if (importPath == null) {
      return;
    }
    state.importPaths.add(importPath);
    if (node.id.type === 'Identifier') {
      state.stylexImport.add(node.id.name);
    }
    if (node.id.type === 'ObjectPattern') {
      for (const prop of node.id.properties) {
        if (prop.type === 'ObjectProperty' && prop.key.type === 'Identifier' && prop.value.type === 'Identifier') {
          const value = prop.value;
          if (prop.key.name === 'create') {
            state.stylexCreateImport.add(value.name);
          }
          if (prop.key.name === 'props') {
            state.stylexPropsImport.add(value.name);
          }
          if (prop.key.name === 'keyframes') {
            state.stylexKeyframesImport.add(value.name);
          }
          if (prop.key.name === 'include') {
            state.stylexIncludeImport.add(value.name);
          }
          if (prop.key.name === 'firstThatWorks') {
            state.stylexFirstThatWorksImport.add(value.name);
          }
          if (prop.key.name === 'defineVars') {
            state.stylexDefineVarsImport.add(value.name);
          }
          if (prop.key.name === 'createTheme') {
            state.stylexCreateThemeImport.add(value.name);
          }
          if (prop.key.name === 'types') {
            state.stylexTypesImport.add(value.name);
          }
        }
      }
    }
  }
}

var lib = {};

var stylexCreate$1 = {};

var objectUtils = {};

var stylexInclude$2 = {};

var messages$3 = {};

Object.defineProperty(messages$3, "__esModule", {
  value: true
});
messages$3.UNKNOWN_PROP_KEY = messages$3.UNKNOWN_NAMESPACE = messages$3.UNEXPECTED_ARGUMENT = messages$3.UNBOUND_STYLEX_CALL_VALUE = messages$3.ONLY_TOP_LEVEL_INCLUDES = messages$3.ONLY_TOP_LEVEL = messages$3.ONLY_NAMED_PARAMETERS_IN_DYNAMIC_STYLE_FUNCTIONS = messages$3.NO_PROJECT_ROOT_DIRECTORY = messages$3.NO_PARENT_PATH = messages$3.NO_CONDITIONAL_SHORTHAND = messages$3.NON_STATIC_VALUE = messages$3.NON_STATIC_KEYFRAME_VALUE = messages$3.NON_OBJECT_KEYFRAME = messages$3.NON_OBJECT_FOR_STYLEX_KEYFRAMES_CALL = messages$3.NON_OBJECT_FOR_STYLEX_CALL = messages$3.NON_EXPORT_NAMED_DECLARATION = messages$3.LOCAL_ONLY = messages$3.LINT_UNCLOSED_FUNCTION = messages$3.INVALID_SPREAD = messages$3.INVALID_PSEUDO_OR_AT_RULE = messages$3.INVALID_PSEUDO = messages$3.ILLEGAL_PROP_VALUE = messages$3.ILLEGAL_PROP_ARRAY_VALUE = messages$3.ILLEGAL_NESTED_PSEUDO = messages$3.ILLEGAL_NAMESPACE_VALUE = messages$3.ILLEGAL_NAMESPACE_TYPE = messages$3.ILLEGAL_ARG_LENGTH_FOR_KEYFRAMES = messages$3.ILLEGAL_ARGUMENT_LENGTH = messages$3.EXPECTED_FUNCTION_CALL = messages$3.ESCAPED_STYLEX_VALUE = messages$3.DUPLICATE_CONDITIONAL = messages$3.ANONYMOUS_THEME = void 0;
messages$3.ILLEGAL_ARGUMENT_LENGTH = 'stylex.create() should have 1 argument.';
messages$3.ILLEGAL_ARG_LENGTH_FOR_KEYFRAMES = 'stylex.keyframes() should have 1 argument.';
messages$3.NON_STATIC_VALUE = 'Only static values are allowed inside of a stylex.create() call.';
messages$3.NON_STATIC_KEYFRAME_VALUE = 'Only static values are allowed inside of a stylex.keyframes() call.';
messages$3.ESCAPED_STYLEX_VALUE = 'Escaping a stylex.create() value is not allowed.';
messages$3.UNBOUND_STYLEX_CALL_VALUE = 'stylex.create calls must be bound to a bare variable.';
messages$3.ONLY_TOP_LEVEL = 'stylex.create() is only allowed at the root of a program.';
messages$3.NON_OBJECT_FOR_STYLEX_CALL = 'stylex.create() can only accept a style object.';
messages$3.NON_OBJECT_FOR_STYLEX_KEYFRAMES_CALL = 'stylex.keyframes() can only accept an object.';
messages$3.UNKNOWN_PROP_KEY = 'Unknown property key';
messages$3.INVALID_PSEUDO = 'Invalid pseudo selector, not on the whitelist.';
messages$3.INVALID_PSEUDO_OR_AT_RULE = 'Invalid pseudo or at-rule.';
messages$3.NO_CONDITIONAL_SHORTHAND = 'You cannot use conditional style values for a shorthand property.';
messages$3.ILLEGAL_NAMESPACE_TYPE = 'Only a string literal namespace is allowed here.';
messages$3.UNKNOWN_NAMESPACE = 'Unknown namespace';
messages$3.ILLEGAL_NESTED_PSEUDO = "Pseudo objects can't be nested more than one level deep.";
messages$3.ILLEGAL_PROP_VALUE = 'A style value can only contain an array, string or number.';
messages$3.ILLEGAL_PROP_ARRAY_VALUE = 'A style array value can only contain strings or numbers.';
messages$3.ILLEGAL_NAMESPACE_VALUE = 'A stylex namespace must be an object.';
messages$3.NON_OBJECT_KEYFRAME = 'Every frame within a stylex.keyframes() call must be an object.';
messages$3.INVALID_SPREAD = 'Imported styles spread with a stylex.create call must be type cast as `XStyle<>` to verify their type.';
messages$3.LINT_UNCLOSED_FUNCTION = 'Rule contains an unclosed function';
messages$3.LOCAL_ONLY = 'The return value of stylex.create() should not be exported.';
messages$3.UNEXPECTED_ARGUMENT = 'Unexpected argument passed to the stylex() function.';
messages$3.EXPECTED_FUNCTION_CALL = 'Expected a simple function call but found something else.';
messages$3.NO_PARENT_PATH = 'Unexpected AST node without a parent path.';
messages$3.ONLY_TOP_LEVEL_INCLUDES = 'stylex.include() is only at the top level of a style definition object.';
messages$3.DUPLICATE_CONDITIONAL = 'The same pseudo selector or at-rule cannot be used more than once.';
messages$3.NO_PROJECT_ROOT_DIRECTORY = 'The project root directory `rootDir` is not configured.';
messages$3.NON_EXPORT_NAMED_DECLARATION = 'The return value of stylex.defineVars() must be bound to a named export.';
messages$3.ANONYMOUS_THEME = 'stylex.createTheme() must be bound to a named constant.';
messages$3.ONLY_NAMED_PARAMETERS_IN_DYNAMIC_STYLE_FUNCTIONS = 'Only named parameters are allowed in Dynamic Style functions. Destructuring, spreading or default values are not allowed.';

Object.defineProperty(stylexInclude$2, "__esModule", {
  value: true
});
stylexInclude$2.IncludedStyles = void 0;
stylexInclude$2.default = stylexInclude$1;
var messages$2 = _interopRequireWildcard$3(messages$3);
function _getRequireWildcardCache$3(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache$3 = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard$3(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache$3(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
let number = 0;
function uuid() {
  return `__included_${++number}__`;
}
class IncludedStyles {
  constructor(astNode) {
    this.astNode = astNode;
  }
}
stylexInclude$2.IncludedStyles = IncludedStyles;
function stylexInclude$1(firstArg) {
  if ((arguments.length <= 1 ? 0 : arguments.length - 1) > 0) {
    throw new Error(messages$2.ILLEGAL_ARGUMENT_LENGTH);
  }
  return {
    [uuid()]: new IncludedStyles(firstArg.node)
  };
}

Object.defineProperty(objectUtils, "__esModule", {
  value: true
});
objectUtils.arraySort = objectUtils.arrayEquals = objectUtils.Pipe = void 0;
objectUtils.flattenObject = flattenObject;
objectUtils.isPlainObject = isPlainObject;
objectUtils.objEntries = objEntries;
objectUtils.objFromEntries = objFromEntries;
objectUtils.objMap = objMap;
objectUtils.objMapEntry = objMapEntry;
objectUtils.objMapKeys = objMapKeys;
objectUtils.objValues = objValues;
var _stylexInclude$4 = stylexInclude$2;
function isPlainObject(obj) {
  return typeof obj === 'object' && obj != null && !Array.isArray(obj) && obj?.constructor === Object;
}
function flattenObject(obj) {
  const result = {};
  for (const [key, value] of objEntries(obj)) {
    if (typeof value === 'string' || value == null) {
      result[key] = value;
    } else if (value instanceof _stylexInclude$4.IncludedStyles) {
      result[key] = value;
    } else {
      for (const [subKey, subValue] of objEntries(value)) {
        result[`${key}_${subKey}`] = subValue;
      }
    }
  }
  return result;
}
function objEntries(obj) {
  const retVal = [];
  for (const key of Object.keys(obj)) {
    retVal.push([key, obj[key]]);
  }
  return retVal;
}
function objValues(obj) {
  const retVal = [];
  for (const key of Object.keys(obj)) {
    retVal.push(obj[key]);
  }
  return retVal;
}
function objFromEntries(entries) {
  const retVal = {};
  for (const [key, value] of entries) {
    retVal[key] = value;
  }
  return retVal;
}
function objMapKeys(obj, mapper) {
  return objFromEntries(objEntries(obj).map(_ref => {
    let [key, value] = _ref;
    return [mapper(key), value];
  }));
}
function objMapEntry(obj, mapper) {
  return objFromEntries(objEntries(obj).map(_ref2 => {
    let [key, value] = _ref2;
    return mapper([key, value]);
  }));
}
function objMap(obj, mapper) {
  return objFromEntries(objEntries(obj).map(_ref3 => {
    let [key, value] = _ref3;
    return [key, mapper(value, key)];
  }));
}
class Pipe {
  constructor(val) {
    this.value = val;
  }
  pipe(mapper) {
    return new Pipe(mapper(this.value));
  }
  done() {
    return this.value;
  }
  static create(val) {
    return new Pipe(val);
  }
}
objectUtils.Pipe = Pipe;
const arraySort = (arr, fn) => [...arr].sort(fn);
objectUtils.arraySort = arraySort;
const arrayEquals = function (arr1, arr2) {
  let equals = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : (a, b) => a === b;
  if (arr1.length !== arr2.length) {
    return false;
  }
  for (let i = 0; i < arr1.length; i++) {
    if (!equals(arr1[i], arr2[i])) {
      return false;
    }
  }
  return true;
};
objectUtils.arrayEquals = arrayEquals;

var defaultOptions = {};

Object.defineProperty(defaultOptions, "__esModule", {
  value: true
});
defaultOptions.defaultOptions = void 0;
defaultOptions.defaultOptions = {
  dev: false,
  useRemForFontSize: true,
  test: false,
  classNamePrefix: 'x',
  styleResolution: 'application-order'
};

var flattenRawStyleObj = {};

var preprocessRules = {};

var applicationOrder = {};

Object.defineProperty(applicationOrder, "__esModule", {
  value: true
});
applicationOrder.default = void 0;
const shorthands$2 = {
  all: _ => {
    throw new Error('all is not supported');
  },
  animation: value => [['animation', value], ['animationComposition', null], ['animationName', null], ['animationDuration', null], ['animationTimingFunction', null], ['animationDelay', null], ['animationIterationCount', null], ['animationDirection', null], ['animationFillMode', null], ['animationPlayState', null], ...shorthands$2.animationRange(null), ['animationTimeline', null]],
  animationRange: value => [['animationRange', value], ['animationRangeEnd', null], ['animationRangeStart', null]],
  background: value => [['background', value], ['backgroundAttachment', null], ['backgroundClip', null], ['backgroundColor', null], ['backgroundImage', null], ['backgroundOrigin', null], ...shorthands$2.backgroundPosition(null), ['backgroundRepeat', null], ['backgroundSize', null]],
  backgroundPosition: value => [['backgroundPosition', value], ['backgroundPositionX', null], ['backgroundPositionY', null]],
  border: rawValue => [['border', rawValue], ...shorthands$2.borderWidth(null), ...shorthands$2.borderStyle(null), ...shorthands$2.borderColor(null)],
  borderInline: rawValue => [['borderInline', rawValue], ...shorthands$2.borderInlineWidth(null), ...shorthands$2.borderInlineStyle(null), ...shorthands$2.borderInlineColor(null)],
  borderBlock: rawValue => [['borderBlock', rawValue], ...shorthands$2.borderBlockWidth(null), ...shorthands$2.borderBlockStyle(null), ...shorthands$2.borderBlockColor(null)],
  borderTop: rawValue => [['borderTop', rawValue], ['borderTopWidth', null], ['borderTopStyle', null], ['borderTopColor', null]],
  borderInlineEnd: rawValue => [['borderInlineEnd', rawValue], ...shorthands$2.borderInlineEndWidth(null), ...shorthands$2.borderInlineEndStyle(null), ...shorthands$2.borderInlineEndColor(null)],
  borderRight: rawValue => [['borderRight', rawValue], ...shorthands$2.borderRightWidth(null), ...shorthands$2.borderRightStyle(null), ...shorthands$2.borderRightColor(null)],
  borderBottom: rawValue => [['borderBottom', rawValue], ['borderBottomWidth', null], ['borderBottomStyle', null], ['borderBottomColor', null]],
  borderInlineStart: rawValue => [['borderInlineStart', rawValue], ...shorthands$2.borderInlineStartWidth(null), ...shorthands$2.borderInlineStartStyle(null), ...shorthands$2.borderInlineStartColor(null)],
  borderLeft: rawValue => [['borderLeft', rawValue], ...shorthands$2.borderLeftWidth(null), ...shorthands$2.borderLeftStyle(null), ...shorthands$2.borderLeftColor(null)],
  borderInlineWidth: rawValue => [['borderInlineWidth', rawValue], ['borderInlineStartWidth', null], ['borderLeftWidth', null], ['borderInlineEndWidth', null], ['borderRightWidth', null]],
  borderInlineStyle: rawValue => [['borderInlineStyle', rawValue], ['borderInlineStartStyle', null], ['borderLeftStyle', null], ['borderInlineEndStyle', null], ['borderRightStyle', null]],
  borderInlineColor: rawValue => [['borderInlineColor', rawValue], ['borderInlineStartColor', null], ['borderLeftColor', null], ['borderInlineEndColor', null], ['borderRightColor', null]],
  borderBlockWidth: rawValue => [['borderBlockWidth', rawValue], ['borderTopWidth', null], ['borderBottomWidth', null]],
  borderBlockStyle: rawValue => [['borderBlockStyle', rawValue], ['borderTopStyle', null], ['borderBottomStyle', null]],
  borderBlockColor: rawValue => [['borderBlockColor', rawValue], ['borderTopColor', null], ['borderBottomColor', null]],
  borderColor: value => [['borderColor', value], ...shorthands$2.borderInlineColor(null), ...shorthands$2.borderBlockColor(null)],
  borderStyle: value => [['borderStyle', value], ...shorthands$2.borderInlineStyle(null), ...shorthands$2.borderBlockStyle(null)],
  borderWidth: value => [['borderWidth', value], ...shorthands$2.borderInlineWidth(null), ...shorthands$2.borderBlockWidth(null)],
  borderInlineStartColor: value => [['borderInlineStartColor', value], ['borderLeftColor', null], ['borderRightColor', null]],
  borderInlineEndColor: value => [['borderInlineEndColor', value], ['borderLeftColor', null], ['borderRightColor', null]],
  borderInlineStartStyle: value => [['borderInlineStartStyle', value], ['borderLeftStyle', null], ['borderRightStyle', null]],
  borderInlineEndStyle: value => [['borderInlineEndStyle', value], ['borderLeftStyle', null], ['borderRightStyle', null]],
  borderInlineStartWidth: value => [['borderInlineStartWidth', value], ['borderLeftWidth', null], ['borderRightWidth', null]],
  borderInlineEndWidth: value => [['borderInlineEndWidth', value], ['borderLeftWidth', null], ['borderRightWidth', null]],
  borderLeftColor: value => [['borderLeftColor', value], ['borderInlineStartColor', null], ['borderInlineEndColor', null]],
  borderRightColor: value => [['borderRightColor', value], ['borderInlineStartColor', null], ['borderInlineEndColor', null]],
  borderLeftStyle: value => [['borderLeftStyle', value], ['borderInlineStartStyle', null], ['borderInlineEndStyle', null]],
  borderRightStyle: value => [['borderRightStyle', value], ['borderInlineStartStyle', null], ['borderInlineEndStyle', null]],
  borderLeftWidth: value => [['borderLeftWidth', value], ['borderInlineStartWidth', null], ['borderInlineEndWidth', null]],
  borderRightWidth: value => [['borderRightWidth', value], ['borderInlineStartWidth', null], ['borderInlineEndWidth', null]],
  borderRadius: value => [['borderRadius', value], ['borderStartStartRadius', null], ['borderStartEndRadius', null], ['borderEndStartRadius', null], ['borderEndEndRadius', null], ['borderTopLeftRadius', null], ['borderTopRightRadius', null], ['borderBottomLeftRadius', null], ['borderBottomRightRadius', null]],
  borderStartStartRadius: value => [['borderStartStartRadius', value], ['borderTopLeftRadius', null], ['borderTopRightRadius', null]],
  borderStartEndRadius: value => [['borderStartEndRadius', value], ['borderTopLeftRadius', null], ['borderTopRightRadius', null]],
  borderEndStartRadius: value => [['borderEndStartRadius', value], ['borderBottomLeftRadius', null], ['borderBottomRightRadius', null]],
  borderEndEndRadius: value => [['borderEndEndRadius', value], ['borderBottomLeftRadius', null], ['borderBottomRightRadius', null]],
  borderTopLeftRadius: value => [['borderTopLeftRadius', value], ['borderStartStartRadius', null], ['borderStartEndRadius', null]],
  borderTopRightRadius: value => [['borderTopRightRadius', value], ['borderStartStartRadius', null], ['borderStartEndRadius', null]],
  borderBottomLeftRadius: value => [['borderBottomLeftRadius', value], ['borderEndStartRadius', null], ['borderEndEndRadius', null]],
  borderBottomRightRadius: value => [['borderBottomRightRadius', value], ['borderEndStartRadius', null], ['borderEndEndRadius', null]],
  borderImage: value => [['borderImage', value], ['borderImageOutset', null], ['borderImageRepeat', null], ['borderImageSlice', null], ['borderImageSource', null], ['borderImageWidth', null]],
  columnRule: value => [['columnRule', value], ['columnRuleColor', null], ['columnRuleStyle', null], ['columnRuleWidth', null]],
  columns: value => [['columns', value], ['columnCount', null], ['columnWidth', null]],
  container: value => [['container', value], ['containerName', null], ['containerType', null]],
  containIntrinsicSize: value => [['containIntrinsicSize', value], ['containIntrinsicWidth', null], ['containIntrinsicHeight', null]],
  flex: value => [['flex', value], ['flexGrow', null], ['flexShrink', null], ['flexBasis', null]],
  flexFlow: value => [['flexFlow', value], ['flexDirection', null], ['flexWrap', null]],
  font: value => [['font', value], ['fontFamily', null], ['fontSize', null], ['fontStretch', null], ['fontStyle', null], ...shorthands$2.fontVariant(null), ['fontWeight', null], ['lineHeight', null]],
  fontVariant: value => [['fontVariant', value], ['fontVariantAlternates', null], ['fontVariantCaps', null], ['fontVariantEastAsian', null], ['fontVariantEmoji', null], ['fontVariantLigatures', null], ['fontVariantNumeric', null], ['fontVariantPosition', null]],
  gap: value => [['gap', value], ['rowGap', null], ['columnGap', null]],
  grid: value => [['grid', value], ...shorthands$2.gridTemplate(null), ['gridAutoRows', null], ['gridAutoColumns', null], ['gridAutoFlow', null]],
  gridArea: value => [['gridArea', value], ['gridRow', null], ['gridRowStart', null], ['gridRowEnd', null], ['gridColumn', null], ['gridColumnStart', null], ['gridColumnEnd', null]],
  gridRow: value => [['gridRow', value], ['gridRowStart', null], ['gridRowEnd', null]],
  gridColumn: value => [['gridColumn', value], ['gridColumnStart', null], ['gridColumnEnd', null]],
  gridTemplate: value => [['gridTemplate', value], ['gridTemplateAreas', null], ['gridTemplateColumns', null], ['gridTemplateRows', null]],
  inset: value => [['inset', value], ...shorthands$2.insetInline(null), ...shorthands$2.insetBlock(null)],
  insetInline: value => [['insetInline', value], ['insetInlineStart', null], ['insetInlineEnd', null], ['left', null], ['right', null]],
  insetBlock: value => [['insetBlock', value], ['top', null], ['bottom', null]],
  insetInlineStart: value => [['insetInlineStart', value], ['left', null], ['right', null]],
  insetInlineEnd: value => [['insetInlineEnd', value], ['left', null], ['right', null]],
  left: value => [['left', value], ['insetInlineStart', null], ['insetInlineEnd', null]],
  right: value => [['right', value], ['insetInlineStart', null], ['insetInlineEnd', null]],
  listStyle: value => [['listStyle', value], ['listStyleImage', null], ['listStylePosition', null], ['listStyleType', null]],
  margin: value => [['margin', value], ...shorthands$2.marginInline(null), ...shorthands$2.marginBlock(null)],
  marginInline: value => [['marginInline', value], ['marginInlineStart', null], ['marginLeft', null], ['marginInlineEnd', null], ['marginRight', null]],
  marginBlock: value => [['marginBlock', value], ['marginTop', null], ['marginBottom', null]],
  marginInlineStart: value => [['marginInlineStart', value], ['marginLeft', null], ['marginRight', null]],
  marginInlineEnd: value => [['marginInlineEnd', value], ['marginLeft', null], ['marginRight', null]],
  marginLeft: value => [['marginLeft', value], ['marginInlineStart', null], ['marginInlineEnd', null]],
  marginRight: value => [['marginRight', value], ['marginInlineStart', null], ['marginInlineEnd', null]],
  mask: value => [['mask', value], ['maskClip', null], ['maskComposite', null], ['maskImage', null], ['maskMode', null], ['maskOrigin', null], ['maskPosition', null], ['maskRepeat', null], ['maskSize', null]],
  maskBorder: value => [['maskBorder', value], ['maskBorderMode', null], ['maskBorderOutset', null], ['maskBorderRepeat', null], ['maskBorderSlice', null], ['maskBorderSource', null], ['maskBorderWidth', null]],
  offset: value => [['offset', value], ['offsetAnchor', null], ['offsetDistance', null], ['offsetPath', null], ['offsetPosition', null], ['offsetRotate', null]],
  outline: value => [['outline', value], ['outlineColor', null], ['outlineOffset', null], ['outlineStyle', null], ['outlineWidth', null]],
  overflow: value => [['overflow', value], ['overflowX', null], ['overflowY', null]],
  padding: rawValue => {
    return [['padding', rawValue], ...shorthands$2.paddingInline(null), ...shorthands$2.paddingBlock(null)];
  },
  paddingInline: rawValue => [['paddingInline', rawValue], ['paddingStart', null], ['paddingLeft', null], ['paddingEnd', null], ['paddingRight', null]],
  paddingBlock: rawValue => [['paddingBlock', rawValue], ['paddingTop', null], ['paddingBottom', null]],
  paddingInlineStart: value => [['paddingInlineStart', value], ['paddingLeft', null], ['paddingRight', null]],
  paddingInlineEnd: value => [['paddingInlineEnd', value], ['paddingLeft', null], ['paddingRight', null]],
  paddingLeft: value => [['paddingLeft', value], ['paddingInlineStart', null], ['paddingInlineEnd', null]],
  paddingRight: value => [['paddingRight', value], ['paddingInlineStart', null], ['paddingInlineEnd', null]],
  placeContent: value => [['placeContent', value], ['alignContent', null], ['justifyContent', null]],
  placeItems: value => [['placeItems', value], ['alignItems', null], ['justifyItems', null]],
  placeSelf: value => [['placeSelf', value], ['alignSelf', null], ['justifySelf', null]],
  scrollMargin: value => [['scrollMargin', value], ...shorthands$2.scrollMarginBlock(null), ...shorthands$2.scrollMarginInline(null)],
  scrollMarginBlock: value => [['scrollMarginBlock', value], ['scrollMarginTop', null], ['scrollMarginBottom', null]],
  scrollMarginInline: value => [['scrollMarginInline', value], ['scrollMarginInlineStart', null], ['scrollMarginInlineEnd', null], ['scrollMarginLeft', null], ['scrollMarginRight', null]],
  scrollMarginInlineStart: value => [['scrollMarginInlineStart', value], ['scrollMarginLeft', null], ['scrollMarginRight', null]],
  scrollMarginInlineEnd: value => [['scrollMarginInlineEnd', value], ['scrollMarginLeft', null], ['scrollMarginRight', null]],
  scrollMarginLeft: value => [['scrollMarginLeft', value], ['scrollMarginInlineStart', null], ['scrollMarginInlineEnd', null]],
  scrollMarginRight: value => [['scrollMarginRight', value], ['scrollMarginInlineStart', null], ['scrollMarginInlineEnd', null]],
  scrollPadding: value => [['scrollPadding', value], ...shorthands$2.scrollPaddingBlock(null), ...shorthands$2.scrollPaddingInline(null)],
  scrollPaddingBlock: value => [['scrollPaddingBlock', value], ['scrollPaddingTop', null], ['scrollPaddingBottom', null]],
  scrollPaddingInline: value => [['scrollPaddingInline', value], ['scrollPaddingInlineStart', null], ['scrollPaddingInlineEnd', null], ['scrollPaddingLeft', null], ['scrollPaddingRight', null]],
  scrollPaddingInlineStart: value => [['scrollPaddingInlineStart', value], ['scrollPaddingLeft', null], ['scrollPaddingRight', null]],
  scrollPaddingInlineEnd: value => [['scrollPaddingInlineEnd', value], ['scrollPaddingLeft', null], ['scrollPaddingRight', null]],
  scrollPaddingLeft: value => [['scrollPaddingLeft', value], ['scrollPaddingInlineStart', null], ['scrollPaddingInlineEnd', null]],
  scrollPaddingRight: value => [['scrollPaddingRight', value], ['scrollPaddingInlineStart', null], ['scrollPaddingInlineEnd', null]],
  scrollSnapType: value => [['scrollSnapType', value], ['scrollSnapTypeX', null], ['scrollSnapTypeY', null]],
  scrollTimeline: value => [['scrollTimeline', value], ['scrollTimelineName', null], ['scrollTimelineAxis', null]],
  textDecoration: value => [['textDecoration', value], ['textDecorationColor', null], ['textDecorationLine', null], ['textDecorationStyle', null], ['textDecorationThickness', null]],
  textEmphasis: value => [['textEmphasis', value], ['textEmphasisColor', null], ['textEmphasisStyle', null]],
  transition: value => [['transition', value], ['transitionBehavior', null], ['transitionDelay', null], ['transitionDuration', null], ['transitionProperty', null], ['transitionTimingFunction', null]]
};
const aliases$2 = {
  borderHorizontal: shorthands$2.borderInline,
  borderVertical: shorthands$2.borderBlock,
  borderBlockStart: shorthands$2.borderTop,
  borderEnd: shorthands$2.borderInlineEnd,
  borderBlockEnd: shorthands$2.borderBottom,
  borderStart: shorthands$2.borderInlineStart,
  blockSize: val => [['height', val]],
  inlineSize: val => [['width', val]],
  minBlockSize: val => [['minHeight', val]],
  minInlineSize: val => [['minWidth', val]],
  maxBlockSize: val => [['maxHeight', val]],
  maxInlineSize: val => [['maxWidth', val]],
  borderHorizontalWidth: shorthands$2.borderInlineWidth,
  borderHorizontalStyle: shorthands$2.borderInlineStyle,
  borderHorizontalColor: shorthands$2.borderInlineColor,
  borderVerticalWidth: shorthands$2.borderBlockWidth,
  borderVerticalStyle: shorthands$2.borderBlockStyle,
  borderVerticalColor: shorthands$2.borderBlockColor,
  borderBlockStartColor: value => [['borderTopColor', value]],
  borderBlockEndColor: value => [['borderBottomColor', value]],
  borderBlockStartStyle: value => [['borderTopStyle', value]],
  borderBlockEndStyle: value => [['borderBottomStyle', value]],
  borderBlockStartWidth: value => [['borderTopWidth', value]],
  borderBlockEndWidth: value => [['borderBottomWidth', value]],
  borderStartColor: shorthands$2.borderInlineStartColor,
  borderEndColor: shorthands$2.borderInlineEndColor,
  borderStartStyle: shorthands$2.borderInlineStartStyle,
  borderEndStyle: shorthands$2.borderInlineEndStyle,
  borderStartWidth: shorthands$2.borderInlineStartWidth,
  borderEndWidth: shorthands$2.borderInlineEndWidth,
  borderTopStartRadius: value => [['borderStartStartRadius', value]],
  borderTopEndRadius: value => [['borderStartEndRadius', value]],
  borderBottomStartRadius: value => [['borderEndStartRadius', value]],
  borderBottomEndRadius: value => [['borderEndEndRadius', value]],
  containIntrinsicBlockSize: value => [['containIntrinsicHeight', value]],
  containIntrinsicInlineSize: value => [['containIntrinsicWidth', value]],
  gridGap: shorthands$2.gap,
  gridRowGap: value => [['rowGap', value]],
  gridColumnGap: value => [['columnGap', value]],
  marginBlockStart: value => [['marginTop', value]],
  marginBlockEnd: value => [['marginBottom', value]],
  marginStart: shorthands$2.marginInlineStart,
  marginEnd: shorthands$2.marginInlineEnd,
  marginHorizontal: shorthands$2.marginInline,
  marginVertical: shorthands$2.marginBlock,
  overflowBlock: value => [['overflowY', value]],
  overflowInline: value => [['overflowX', value]],
  paddingBlockStart: rawValue => [['paddingTop', rawValue]],
  paddingBlockEnd: rawValue => [['paddingBottom', rawValue]],
  paddingStart: shorthands$2.paddingInlineStart,
  paddingEnd: shorthands$2.paddingInlineEnd,
  paddingHorizontal: shorthands$2.paddingInline,
  paddingVertical: shorthands$2.paddingBlock,
  scrollMarginBlockStart: value => [['scrollMarginTop', value]],
  scrollMarginBlockEnd: value => [['scrollMarginBottom', value]],
  insetBlockStart: value => [['top', value]],
  insetBlockEnd: value => [['bottom', value]],
  start: shorthands$2.insetInlineStart,
  end: shorthands$2.insetInlineEnd
};
const expansions$3 = {
  ...shorthands$2,
  ...aliases$2
};
applicationOrder.default = expansions$3;

var legacyExpandShorthands = {};

var splitCssValue = {};

Object.defineProperty(splitCssValue, "__esModule", {
  value: true
});
splitCssValue.default = splitValue;
var _postcssValueParser$6 = _interopRequireDefault$h(require$$0);
function _interopRequireDefault$h(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function printNode(node) {
  switch (node.type) {
    case 'word':
    case 'string':
      return `${node.value}`;
    case 'function':
      return `${node.value}(${node.nodes.map(printNode).join('')})`;
    default:
      return node.value;
  }
}
function splitValue(str) {
  if (str == null || typeof str === 'number') {
    return [str];
  }
  if (Array.isArray(str)) {
    return str;
  }
  const parsed = (0, _postcssValueParser$6.default)(str.trim());
  const nodes = parsed.nodes.filter(node => node.type !== 'space' && node.type !== 'div').map(printNode);
  if (nodes.length > 1 && nodes[nodes.length - 1].toLowerCase() === '!important') {
    return nodes.slice(0, nodes.length - 1).map(node => node + ' !important');
  }
  return nodes;
}

Object.defineProperty(legacyExpandShorthands, "__esModule", {
  value: true
});
legacyExpandShorthands.default = void 0;
var _splitCssValue = _interopRequireDefault$g(splitCssValue);
function _interopRequireDefault$g(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const shorthands$1 = {
  border: rawValue => {
    return [['borderTop', rawValue], ['borderEnd', rawValue], ['borderBottom', rawValue], ['borderStart', rawValue]];
  },
  borderColor: rawValue => {
    const [top, right = top, bottom = top, left = right] = (0, _splitCssValue.default)(rawValue);
    return [['borderTopColor', top], ['borderEndColor', right], ['borderBottomColor', bottom], ['borderStartColor', left]];
  },
  borderHorizontal: rawValue => {
    return [['borderStart', rawValue], ['borderEnd', rawValue]];
  },
  borderStyle: rawValue => {
    const [top, right = top, bottom = top, left = right] = (0, _splitCssValue.default)(rawValue);
    return [['borderTopStyle', top], ['borderEndStyle', right], ['borderBottomStyle', bottom], ['borderStartStyle', left]];
  },
  borderVertical: rawValue => {
    return [['borderTop', rawValue], ['borderBottom', rawValue]];
  },
  borderWidth: rawValue => {
    const [top, right = top, bottom = top, left = right] = (0, _splitCssValue.default)(rawValue);
    return [['borderTopWidth', top], ['borderEndWidth', right], ['borderBottomWidth', bottom], ['borderStartWidth', left]];
  },
  borderHorizontalColor: rawValue => [['borderStartColor', rawValue], ['borderEndColor', rawValue]],
  borderHorizontalStyle: rawValue => [['borderStartStyle', rawValue], ['borderEndStyle', rawValue]],
  borderHorizontalWidth: rawValue => [['borderStartWidth', rawValue], ['borderEndWidth', rawValue]],
  borderVerticalColor: rawValue => [['borderTopColor', rawValue], ['borderBottomColor', rawValue]],
  borderVerticalStyle: rawValue => [['borderTopStyle', rawValue], ['borderBottomStyle', rawValue]],
  borderVerticalWidth: rawValue => [['borderTopWidth', rawValue], ['borderBottomWidth', rawValue]],
  borderRadius: rawValue => {
    const [top, right = top, bottom = top, left = right] = (0, _splitCssValue.default)(rawValue);
    return [['borderTopStartRadius', top], ['borderTopEndRadius', right], ['borderBottomEndRadius', bottom], ['borderBottomStartRadius', left]];
  },
  inset: rawValue => [['top', rawValue], ['end', rawValue], ['bottom', rawValue], ['start', rawValue]],
  insetInline: rawValue => [...shorthands$1.start(rawValue), ...shorthands$1.end(rawValue)],
  insetBlock: rawValue => [['top', rawValue], ['bottom', rawValue]],
  start: rawValue => [['start', rawValue], ['left', null], ['right', null]],
  end: rawValue => [['end', rawValue], ['left', null], ['right', null]],
  left: rawValue => [['left', rawValue], ['start', null], ['end', null]],
  right: rawValue => [['right', rawValue], ['start', null], ['end', null]],
  gap: rawValue => {
    const [row, column = row] = (0, _splitCssValue.default)(rawValue);
    return [['rowGap', row], ['columnGap', column]];
  },
  margin: rawValue => {
    const [top, right = top, bottom = top, left = right] = (0, _splitCssValue.default)(rawValue);
    return [['marginTop', top], ['marginEnd', right], ['marginBottom', bottom], ['marginStart', left]];
  },
  marginHorizontal: rawValue => [...shorthands$1.marginStart(rawValue), ...shorthands$1.marginEnd(rawValue)],
  marginStart: rawValue => [['marginStart', rawValue], ['marginLeft', null], ['marginRight', null]],
  marginEnd: rawValue => [['marginEnd', rawValue], ['marginLeft', null], ['marginRight', null]],
  marginLeft: rawValue => [['marginLeft', rawValue], ['marginStart', null], ['marginEnd', null]],
  marginRight: rawValue => [['marginRight', rawValue], ['marginStart', null], ['marginEnd', null]],
  marginVertical: rawValue => {
    return [['marginTop', rawValue], ['marginBottom', rawValue]];
  },
  overflow: rawValue => {
    const [x, y = x] = (0, _splitCssValue.default)(rawValue);
    return [['overflowX', x], ['overflowY', y]];
  },
  padding: rawValue => {
    const [top, right = top, bottom = top, left = right] = (0, _splitCssValue.default)(rawValue);
    return [['paddingTop', top], ['paddingEnd', right], ['paddingBottom', bottom], ['paddingStart', left]];
  },
  paddingHorizontal: val => [...shorthands$1.paddingStart(val), ...shorthands$1.paddingEnd(val)],
  paddingStart: val => [['paddingStart', val], ['paddingLeft', null], ['paddingRight', null]],
  paddingEnd: val => [['paddingEnd', val], ['paddingLeft', null], ['paddingRight', null]],
  paddingLeft: val => [['paddingLeft', val], ['paddingStart', null], ['paddingEnd', null]],
  paddingRight: val => [['paddingRight', val], ['paddingStart', null], ['paddingEnd', null]],
  paddingVertical: val => [['paddingTop', val], ['paddingBottom', val]]
};
const aliases$1 = {
  insetBlockStart: val => [['top', val]],
  insetBlockEnd: val => [['bottom', val]],
  insetInlineStart: shorthands$1.start,
  insetInlineEnd: shorthands$1.end,
  blockSize: val => [['height', val]],
  inlineSize: val => [['width', val]],
  minBlockSize: val => [['minHeight', val]],
  minInlineSize: val => [['minWidth', val]],
  maxBlockSize: val => [['maxHeight', val]],
  maxInlineSize: val => [['maxWidth', val]],
  borderBlockWidth: shorthands$1.borderVerticalWidth,
  borderBlockStyle: shorthands$1.borderVerticalStyle,
  borderBlockColor: shorthands$1.borderVerticalColor,
  borderBlockStartWidth: val => [['borderTopWidth', val]],
  borderBlockStartStyle: val => [['borderTopStyle', val]],
  borderBlockStartColor: val => [['borderTopColor', val]],
  borderBlockEndWidth: val => [['borderBottomWidth', val]],
  borderBlockEndStyle: val => [['borderBottomStyle', val]],
  borderBlockEndColor: val => [['borderBottomColor', val]],
  borderInlineWidth: shorthands$1.borderHorizontalWidth,
  borderInlineStyle: shorthands$1.borderHorizontalStyle,
  borderInlineColor: shorthands$1.borderHorizontalColor,
  borderInlineStartWidth: val => [['borderStartWidth', val]],
  borderInlineStartStyle: val => [['borderStartStyle', val]],
  borderInlineStartColor: val => [['borderStartColor', val]],
  borderInlineEndWidth: val => [['borderEndWidth', val]],
  borderInlineEndStyle: val => [['borderEndStyle', val]],
  borderInlineEndColor: val => [['borderEndColor', val]],
  borderStartStartRadius: val => [['borderTopStartRadius', val]],
  borderStartEndRadius: val => [['borderTopEndRadius', val]],
  borderEndStartRadius: val => [['borderBottomStartRadius', val]],
  borderEndEndRadius: val => [['borderBottomEndRadius', val]],
  gridGap: shorthands$1.gap,
  gridRowGap: value => [['rowGap', value]],
  gridColumnGap: value => [['columnGap', value]],
  marginBlock: shorthands$1.marginVertical,
  marginBlockStart: val => [['marginTop', val]],
  marginBlockEnd: val => [['marginBottom', val]],
  marginInline: shorthands$1.marginHorizontal,
  marginInlineStart: val => [['marginStart', val]],
  marginInlineEnd: val => [['marginEnd', val]],
  overflowBlock: value => [['overflowY', value]],
  overflowInline: value => [['overflowX', value]],
  paddingBlock: shorthands$1.paddingVertical,
  paddingBlockStart: val => [['paddingTop', val]],
  paddingBlockEnd: val => [['paddingBottom', val]],
  paddingInline: shorthands$1.paddingHorizontal,
  paddingInlineStart: val => [['paddingStart', val]],
  paddingInlineEnd: val => [['paddingEnd', val]],
  scrollMarginBlockStart: value => [['scrollMarginTop', value]],
  scrollMarginBlockEnd: value => [['scrollMarginBottom', value]]
};
const expansions$2 = {
  ...shorthands$1,
  ...aliases$1
};
legacyExpandShorthands.default = expansions$2;

var propertySpecificity = {};

Object.defineProperty(propertySpecificity, "__esModule", {
  value: true
});
propertySpecificity.default = void 0;
const shorthands = {
  all: _ => {
    throw new Error('all is not supported');
  },
  animation: _value => {
    throw new Error('animation is not supported');
  },
  background: _value => {
    throw new Error('background is not supported. Use background-color, border-image etc. instead.');
  },
  border: _rawValue => {
    throw new Error('border is not supported. Use border-width, border-style and border-color instead.');
  },
  borderInline: _rawValue => {
    throw new Error('borderInline is not supported. Use borderInlineWidth, borderInlineStyle and borderInlineColor instead.');
  },
  borderBlock: _rawValue => {
    throw new Error('borderBlock is not supported. Use borderBlockWidth, borderBlockStyle and borderBlockColor instead.');
  },
  borderTop: _rawValue => {
    throw new Error('borderTop is not supported. Use borderTopWidth, borderTopStyle and borderTopColor instead.');
  },
  borderInlineEnd: _rawValue => {
    throw new Error('borderInlineEnd is not supported. Use borderInlineEndWidth, borderInlineEndStyle and borderInlineEndColor instead.');
  },
  borderRight: _rawValue => {
    throw new Error('borderRight is not supported. Use borderRightWidth, borderRightStyle and borderRightColor instead.');
  },
  borderBottom: _rawValue => {
    throw new Error('borderBottom is not supported. Use borderBottomWidth, borderBottomStyle and borderBottomColor instead.');
  },
  borderInlineStart: _rawValue => {
    throw new Error('borderInlineStart is not supported. Use borderInlineStartWidth, borderInlineStartStyle and borderInlineStartColor instead.');
  },
  borderLeft: _rawValue => {
    throw new Error(['`borderLeft` is not supported.', 'You could use `borderLeftWidth`, `borderLeftStyle` and `borderLeftColor`,', 'but it is preferable to use `borderInlineStartWidth`, `borderInlineStartStyle` and `borderInlineStartColor`.'].join(' '));
  }
};
const aliases = {
  borderHorizontal: shorthands.borderInline,
  borderVertical: shorthands.borderBlock,
  borderBlockStart: shorthands.borderTop,
  borderEnd: shorthands.borderInlineEnd,
  borderBlockEnd: shorthands.borderBottom,
  borderStart: shorthands.borderInlineStart,
  blockSize: val => [['height', val]],
  inlineSize: val => [['width', val]],
  minBlockSize: val => [['minHeight', val]],
  minInlineSize: val => [['minWidth', val]],
  maxBlockSize: val => [['maxHeight', val]],
  maxInlineSize: val => [['maxWidth', val]],
  borderHorizontalWidth: val => [['borderInlineWidth', val]],
  borderHorizontalStyle: val => [['borderInlineStyle', val]],
  borderHorizontalColor: val => [['borderInlineColor', val]],
  borderVerticalWidth: val => [['borderBlockWidth', val]],
  borderVerticalStyle: val => [['borderBlockStyle', val]],
  borderVerticalColor: val => [['borderBlockColor', val]],
  borderBlockStartColor: value => [['borderTopColor', value]],
  borderBlockEndColor: value => [['borderBottomColor', value]],
  borderBlockStartStyle: value => [['borderTopStyle', value]],
  borderBlockEndStyle: value => [['borderBottomStyle', value]],
  borderBlockStartWidth: value => [['borderTopWidth', value]],
  borderBlockEndWidth: value => [['borderBottomWidth', value]],
  borderStartColor: val => [['borderInlineStartColor', val]],
  borderEndColor: val => [['borderInlineEndColor', val]],
  borderStartStyle: val => [['borderInlineStartStyle', val]],
  borderEndStyle: val => [['borderInlineEndStyle', val]],
  borderStartWidth: val => [['borderInlineStartWidth', val]],
  borderEndWidth: val => [['borderInlineEndWidth', val]],
  borderTopStartRadius: value => [['borderStartStartRadius', value]],
  borderTopEndRadius: value => [['borderStartEndRadius', value]],
  borderBottomStartRadius: value => [['borderEndStartRadius', value]],
  borderBottomEndRadius: value => [['borderEndEndRadius', value]],
  containIntrinsicBlockSize: value => [['containIntrinsicHeight', value]],
  containIntrinsicInlineSize: value => [['containIntrinsicWidth', value]],
  marginBlockStart: value => [['marginTop', value]],
  marginBlockEnd: value => [['marginBottom', value]],
  marginStart: val => [['marginInlineStart', val]],
  marginEnd: val => [['marginInlineEnd', val]],
  marginHorizontal: val => [['marginInline', val]],
  marginVertical: val => [['marginBlock', val]],
  overflowBlock: value => [['overflowY', value]],
  overflowInline: value => [['overflowX', value]],
  paddingBlockStart: rawValue => [['paddingTop', rawValue]],
  paddingBlockEnd: rawValue => [['paddingBottom', rawValue]],
  paddingStart: val => [['paddingInlineStart', val]],
  paddingEnd: val => [['paddingInlineEnd', val]],
  paddingHorizontal: val => [['paddingInline', val]],
  paddingVertical: val => [['paddingBlock', val]],
  scrollMarginBlockStart: value => [['scrollMarginTop', value]],
  scrollMarginBlockEnd: value => [['scrollMarginBottom', value]],
  insetBlockStart: value => [['top', value]],
  insetBlockEnd: value => [['bottom', value]],
  start: val => [['insetInlineStart', val]],
  end: val => [['insetInlineEnd', val]]
};
const expansions$1 = {
  ...shorthands,
  ...aliases
};
propertySpecificity.default = expansions$1;

Object.defineProperty(preprocessRules, "__esModule", {
  value: true
});
preprocessRules.default = flatMapExpandedShorthands;
preprocessRules.getExpandedKeys = getExpandedKeys;
var _applicationOrder = _interopRequireDefault$f(applicationOrder);
var _legacyExpandShorthands = _interopRequireDefault$f(legacyExpandShorthands);
var _propertySpecificity = _interopRequireDefault$f(propertySpecificity);
function _interopRequireDefault$f(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const expansions = {
  'application-order': _applicationOrder.default,
  'property-specificity': _propertySpecificity.default,
  'legacy-expand-shorthands': _legacyExpandShorthands.default
};
function getExpandedKeys(options) {
  return Object.keys(expansions[options.styleResolution ?? 'application-order']);
}
function flatMapExpandedShorthands(objEntry, options) {
  const [key, value] = objEntry;
  const expansion = expansions[options.styleResolution ?? 'application-order'][key];
  if (expansion) {
    if (Array.isArray(value)) {
      throw new Error('Cannot use fallbacks for shorthands. Use the expansion instead.');
    }
    return expansion(value);
  }
  return [[key, value]];
}

var PreRule$1 = {};

var convertToClassName = {};

var hash$1 = {};

Object.defineProperty(hash$1, "__esModule", {
  value: true
});
hash$1.default = void 0;
function murmurhash2_32_gc(str) {
  let seed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  let l = str.length,
    h = seed ^ l,
    i = 0,
    k;
  while (l >= 4) {
    k = str.charCodeAt(i) & 0xff | (str.charCodeAt(++i) & 0xff) << 8 | (str.charCodeAt(++i) & 0xff) << 16 | (str.charCodeAt(++i) & 0xff) << 24;
    k = (k & 0xffff) * 0x5bd1e995 + (((k >>> 16) * 0x5bd1e995 & 0xffff) << 16);
    k ^= k >>> 24;
    k = (k & 0xffff) * 0x5bd1e995 + (((k >>> 16) * 0x5bd1e995 & 0xffff) << 16);
    h = (h & 0xffff) * 0x5bd1e995 + (((h >>> 16) * 0x5bd1e995 & 0xffff) << 16) ^ k;
    l -= 4;
    ++i;
  }
  switch (l) {
    case 3:
      h ^= (str.charCodeAt(i + 2) & 0xff) << 16;
    case 2:
      h ^= (str.charCodeAt(i + 1) & 0xff) << 8;
    case 1:
      h ^= str.charCodeAt(i) & 0xff;
      h = (h & 0xffff) * 0x5bd1e995 + (((h >>> 16) * 0x5bd1e995 & 0xffff) << 16);
  }
  h ^= h >>> 13;
  h = (h & 0xffff) * 0x5bd1e995 + (((h >>> 16) * 0x5bd1e995 & 0xffff) << 16);
  h ^= h >>> 15;
  return h >>> 0;
}
const hash = str => murmurhash2_32_gc(str, 1).toString(36);
hash$1.default = hash;

var dashify$1 = {};

Object.defineProperty(dashify$1, "__esModule", {
  value: true
});
dashify$1.default = dashify;
function dashify(str) {
  return str.replace(/(^|[a-z])([A-Z])/g, '$1-$2').toLowerCase();
}

var transformValue$1 = {};

var normalizeValue$1 = {};

var fontSizePxToRem = {};

Object.defineProperty(fontSizePxToRem, "__esModule", {
  value: true
});
fontSizePxToRem.default = convertFontSizeToRem;
var _postcssValueParser$5 = _interopRequireDefault$e(require$$0);
function _interopRequireDefault$e(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const ROOT_FONT_SIZE = 16;
function convertFontSizeToRem(ast, key) {
  if (key !== 'fontSize') {
    return ast;
  }
  ast.walk(node => {
    if (node.type !== 'word') {
      return;
    }
    const dimension = _postcssValueParser$5.default.unit(node.value);
    if (dimension && dimension.unit === 'px') {
      node.value = `${parseFloat(dimension.number) / ROOT_FONT_SIZE}rem`;
    }
  });
  return ast;
}

var leadingZero = {};

Object.defineProperty(leadingZero, "__esModule", {
  value: true
});
leadingZero.default = normalizeLeadingZero;
var _postcssValueParser$4 = _interopRequireDefault$d(require$$0);
function _interopRequireDefault$d(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function normalizeLeadingZero(ast, _) {
  ast.walk(node => {
    if (node.type !== 'word') {
      return;
    }
    const value = Number.parseFloat(node.value);
    if (Number.isNaN(value)) {
      return;
    }
    const dimension = _postcssValueParser$4.default.unit(node.value);
    if (value < 1 && value >= 0) {
      node.value = value.toString().replace('0.', '.') + (dimension ? dimension.unit : '');
    }
  });
  return ast;
}

var quotes = {};

Object.defineProperty(quotes, "__esModule", {
  value: true
});
quotes.default = normalizeQuotes;
function normalizeQuotes(ast, _) {
  ast.walk(node => {
    if (node.type !== 'string') {
      return;
    }
    if (node.value === '') {
      node.quote = '"';
    }
  });
  return ast;
}

var timings$1 = {};

Object.defineProperty(timings$1, "__esModule", {
  value: true
});
timings$1.default = normalizeTimings;
var _postcssValueParser$3 = _interopRequireDefault$c(require$$0);
function _interopRequireDefault$c(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function normalizeTimings(ast, _) {
  ast.walk(node => {
    if (node.type !== 'word') {
      return;
    }
    const value = Number.parseFloat(node.value);
    if (Number.isNaN(value)) {
      return;
    }
    const dimension = _postcssValueParser$3.default.unit(node.value);
    if (!dimension || dimension.unit !== 'ms' || value < 10) {
      return;
    }
    node.value = value / 1000 + 's';
  });
  return ast;
}

var whitespace = {};

Object.defineProperty(whitespace, "__esModule", {
  value: true
});
whitespace.default = normalizeWhitespace;
function normalizeWhitespace(ast, _) {
  if (ast.nodes[0].type === 'space') {
    ast.nodes.shift();
  }
  if (ast.nodes[ast.nodes.length - 1].type === 'space') {
    ast.nodes.pop();
  }
  ast.walk((node, idx) => {
    switch (node.type) {
      case 'space':
        {
          node.value = ' ';
          break;
        }
      case 'div':
      case 'function':
        {
          node.before = '';
          node.after = '';
          break;
        }
      case 'word':
        {
          if (node.value === '!important') {
            if (ast.nodes[idx - 1] && ast.nodes[idx - 1].type === 'space') {
              ast.nodes.splice(idx - 1, 1);
            }
          }
          break;
        }
    }
  });
  return ast;
}

var zeroDimensions = {};

Object.defineProperty(zeroDimensions, "__esModule", {
  value: true
});
zeroDimensions.default = normalizeZeroDimensions;
var _postcssValueParser$2 = _interopRequireDefault$b(require$$0);
function _interopRequireDefault$b(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const angles = ['deg', 'grad', 'turn', 'rad'];
const timings = ['ms', 's'];
function normalizeZeroDimensions(ast, _) {
  ast.walk(node => {
    if (node.type !== 'word') {
      return;
    }
    const dimension = _postcssValueParser$2.default.unit(node.value);
    if (!dimension || dimension.number !== '0') {
      return;
    }
    if (angles.indexOf(dimension.unit) !== -1) {
      node.value = '0deg';
    } else if (timings.indexOf(dimension.unit) !== -1) {
      node.value = '0s';
    } else {
      node.value = '0';
    }
  });
  return ast;
}

var detectUnclosedFns$1 = {};

Object.defineProperty(detectUnclosedFns$1, "__esModule", {
  value: true
});
detectUnclosedFns$1.default = detectUnclosedFns;
var messages$1 = _interopRequireWildcard$2(messages$3);
function _getRequireWildcardCache$2(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache$2 = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard$2(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache$2(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function detectUnclosedFns(ast, _) {
  ast.walk(node => {
    if (node.type === 'function' && node.unclosed) {
      throw new Error(messages$1.LINT_UNCLOSED_FUNCTION);
    }
  });
  return ast;
}

var convertCamelCaseValues = {};

Object.defineProperty(convertCamelCaseValues, "__esModule", {
  value: true
});
convertCamelCaseValues.default = convertCamelCasedValues;
var _dashify$2 = _interopRequireDefault$a(dashify$1);
function _interopRequireDefault$a(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function convertCamelCasedValues(ast, key) {
  if (key !== 'transitionProperty' && key !== 'willChange') {
    return ast;
  }
  const nodes = ast.nodes;
  if (!nodes) {
    return ast;
  }
  nodes.forEach(node => {
    if (node.type === 'word' && !node.value.startsWith('--')) {
      node.value = (0, _dashify$2.default)(node.value);
    }
  });
  return ast;
}

Object.defineProperty(normalizeValue$1, "__esModule", {
  value: true
});
normalizeValue$1.default = normalizeValue;
var _fontSizePxToRem = _interopRequireDefault$9(fontSizePxToRem);
var _leadingZero = _interopRequireDefault$9(leadingZero);
var _quotes = _interopRequireDefault$9(quotes);
var _timings = _interopRequireDefault$9(timings$1);
var _whitespace = _interopRequireDefault$9(whitespace);
var _zeroDimensions = _interopRequireDefault$9(zeroDimensions);
var _detectUnclosedFns = _interopRequireDefault$9(detectUnclosedFns$1);
var _postcssValueParser$1 = _interopRequireDefault$9(require$$0);
var _convertCamelCaseValues = _interopRequireDefault$9(convertCamelCaseValues);
function _interopRequireDefault$9(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const normalizers = [_detectUnclosedFns.default, _whitespace.default, _timings.default, _zeroDimensions.default, _leadingZero.default, _quotes.default, _convertCamelCaseValues.default];
function normalizeValue(value, key, _ref) {
  let {
    useRemForFontSize
  } = _ref;
  if (value == null) {
    return value;
  }
  const parsedAST = (0, _postcssValueParser$1.default)(value);
  const relevantNormalizers = useRemForFontSize ? [...normalizers, _fontSizePxToRem.default] : normalizers;
  return relevantNormalizers.reduce((ast, fn) => fn(ast, key), parsedAST).toString();
}

var lengthUnits_1;

Object.defineProperty(transformValue$1, "__esModule", {
  value: true
});
transformValue$1.default = transformValue;
var getNumberSuffix_1 = transformValue$1.getNumberSuffix = getNumberSuffix;
var timeUnits_1 = transformValue$1.timeUnits = lengthUnits_1 = transformValue$1.lengthUnits = void 0;
var _normalizeValue = _interopRequireDefault$8(normalizeValue$1);
function _interopRequireDefault$8(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function transformValue(key, rawValue, options) {
  const value = typeof rawValue === 'number' ? String(Math.round(rawValue * 10000) / 10000) + getNumberSuffix(key) : rawValue;
  if ((key === 'content' || key === 'hyphenateCharacter' || key === 'hyphenate-character') && typeof value === 'string') {
    const val = value.trim();
    if (val.match(/^attr\([a-zA-Z0-9-]+\)$/)) {
      return val;
    }
    if (!(val.startsWith('"') && val.endsWith('"') || val.startsWith("'") && val.endsWith("'"))) {
      return `"${val}"`;
    }
  }
  return (0, _normalizeValue.default)(value, key, options);
}
function getNumberSuffix(key) {
  if (unitlessNumberProperties.has(key)) {
    return '';
  }
  const suffix = numberPropertySuffixes[key];
  if (suffix == null) {
    return 'px';
  } else {
    return suffix;
  }
}
const unitlessNumberProperties = new Set(['WebkitLineClamp', 'animationIterationCount', 'aspectRatio', 'borderImageOutset', 'borderImageSlice', 'borderImageWidth', 'counterSet', 'columnCount', 'flex', 'flexGrow', 'flexPositive', 'flexShrink', 'flexOrder', 'gridRow', 'gridColumn', 'fontWeight', 'hyphenateLimitChars', 'lineClamp', 'lineHeight', 'maskBorderOutset', 'maskBorderSlice', 'maskBorderWidth', 'opacity', 'order', 'orphans', 'tabSize', 'widows', 'zIndex', 'fillOpacity', 'floodOpacity', 'rotate', 'scale', 'stopOpacity', 'strokeDasharray', 'strokeDashoffset', 'strokeMiterlimit', 'strokeOpacity', 'strokeWidth', 'scale', 'mathDepth']);
const numberPropertySuffixes = {
  animationDelay: 'ms',
  animationDuration: 'ms',
  transitionDelay: 'ms',
  transitionDuration: 'ms',
  voiceDuration: 'ms'
};
timeUnits_1 = transformValue$1.timeUnits = new Set(Object.keys(numberPropertySuffixes));
lengthUnits_1 = transformValue$1.lengthUnits = new Set(['backgroundPositionX', 'backgroundPositionY', 'blockSize', 'borderBlockEndWidth', 'borderBlockStartWidth', 'borderBlockWidth', 'borderVerticalWidth', 'borderVerticalWidth', 'borderBottomLeftRadius', 'borderBottomRightRadius', 'borderBottomWidth', 'borderEndEndRadius', 'borderEndStartRadius', 'borderImageWidth', 'borderInlineEndWidth', 'borderEndWidth', 'borderInlineStartWidth', 'borderStartWidth', 'borderInlineWidth', 'borderHorizontalWidth', 'borderLeftWidth', 'borderRightWidth', 'borderSpacing', 'borderStartEndRadius', 'borderStartStartRadius', 'borderTopLeftRadius', 'borderTopRightRadius', 'borderTopWidth', 'bottom', 'columnGap', 'columnRuleWidth', 'columnWidth', 'containIntrinsicBlockSize', 'containIntrinsicHeight', 'containIntrinsicInlineSize', 'containIntrinsicWidth', 'flexBasis', 'fontSize', 'fontSmooth', 'height', 'inlineSize', 'insetBlockEnd', 'insetBlockStart', 'insetInlineEnd', 'insetInlineStart', 'left', 'letterSpacing', 'marginBlockEnd', 'marginBlockStart', 'marginBottom', 'marginInlineEnd', 'marginEnd', 'marginInlineStart', 'marginStart', 'marginLeft', 'marginRight', 'marginTop', 'maskBorderOutset', 'maskBorderWidth', 'maxBlockSize', 'maxHeight', 'maxInlineSize', 'maxWidth', 'minBlockSize', 'minHeight', 'minInlineSize', 'minWidth', 'offsetDistance', 'outlineOffset', 'outlineWidth', 'overflowClipMargin', 'paddingBlockEnd', 'paddingBlockStart', 'paddingBottom', 'paddingInlineEnd', 'paddingEnd', 'paddingInlineStart', 'paddingStart', 'paddingLeft', 'paddingRight', 'paddingTop', 'perspective', 'right', 'rowGap', 'scrollMarginBlockEnd', 'scrollMarginBlockStart', 'scrollMarginBottom', 'scrollMarginInlineEnd', 'scrollMarginInlineStart', 'scrollMarginLeft', 'scrollMarginRight', 'scrollMarginTop', 'scrollPaddingBlockEnd', 'scrollPaddingBlockStart', 'scrollPaddingBottom', 'scrollPaddingInlineEnd', 'scrollPaddingInlineStart', 'scrollPaddingLeft', 'scrollPaddingRight', 'scrollPaddingTop', 'scrollSnapMarginBottom', 'scrollSnapMarginLeft', 'scrollSnapMarginRight', 'scrollSnapMarginTop', 'shapeMargin', 'tabSize', 'textDecorationThickness', 'textIndent', 'textUnderlineOffset', 'top', 'transformOrigin', 'translate', 'verticalAlign', 'width', 'wordSpacing', 'border', 'borderBlock', 'borderBlockEnd', 'borderBlockStart', 'borderBottom', 'borderLeft', 'borderRadius', 'borderRight', 'borderTop', 'borderWidth', 'columnRule', 'containIntrinsicSize', 'gap', 'inset', 'insetBlock', 'insetInline', 'margin', 'marginBlock', 'marginVertical', 'marginInline', 'marginHorizontal', 'offset', 'outline', 'padding', 'paddingBlock', 'paddingVertical', 'paddingInline', 'paddingHorizontal', 'scrollMargin', 'scrollMarginBlock', 'scrollMarginInline', 'scrollPadding', 'scrollPaddingBlock', 'scrollPaddingInline', 'scrollSnapMargin']);

var generateCssRule = {};

var generateLtr = {};

Object.defineProperty(generateLtr, "__esModule", {
  value: true
});
generateLtr.default = generateLTR;
const logicalToPhysical$1 = {
  start: 'left',
  end: 'right'
};
const propertyToLTR = {
  'margin-start': _ref => {
    let [_key, val] = _ref;
    return ['margin-left', val];
  },
  'margin-end': _ref2 => {
    let [_key, val] = _ref2;
    return ['margin-right', val];
  },
  'padding-start': _ref3 => {
    let [_key, val] = _ref3;
    return ['padding-left', val];
  },
  'padding-end': _ref4 => {
    let [_key, val] = _ref4;
    return ['padding-right', val];
  },
  'border-start': _ref5 => {
    let [_key, val] = _ref5;
    return ['border-left', val];
  },
  'border-end': _ref6 => {
    let [_key, val] = _ref6;
    return ['border-right', val];
  },
  'border-start-width': _ref7 => {
    let [_key, val] = _ref7;
    return ['border-left-width', val];
  },
  'border-end-width': _ref8 => {
    let [_key, val] = _ref8;
    return ['border-right-width', val];
  },
  'border-start-color': _ref9 => {
    let [_key, val] = _ref9;
    return ['border-left-color', val];
  },
  'border-end-color': _ref10 => {
    let [_key, val] = _ref10;
    return ['border-right-color', val];
  },
  'border-start-style': _ref11 => {
    let [_key, val] = _ref11;
    return ['border-left-style', val];
  },
  'border-end-style': _ref12 => {
    let [_key, val] = _ref12;
    return ['border-right-style', val];
  },
  'border-top-start-radius': _ref13 => {
    let [_key, val] = _ref13;
    return ['border-top-left-radius', val];
  },
  'border-bottom-start-radius': _ref14 => {
    let [_key, val] = _ref14;
    return ['border-bottom-left-radius', val];
  },
  'border-top-end-radius': _ref15 => {
    let [_key, val] = _ref15;
    return ['border-top-right-radius', val];
  },
  'border-bottom-end-radius': _ref16 => {
    let [_key, val] = _ref16;
    return ['border-bottom-right-radius', val];
  },
  'text-align': _ref17 => {
    let [key, val] = _ref17;
    return [key, logicalToPhysical$1[val] ?? val];
  },
  float: _ref18 => {
    let [key, val] = _ref18;
    return [key, logicalToPhysical$1[val] ?? val];
  },
  clear: _ref19 => {
    let [key, val] = _ref19;
    return [key, logicalToPhysical$1[val] ?? val];
  },
  start: _ref20 => {
    let [_key, val] = _ref20;
    return ['left', val];
  },
  end: _ref21 => {
    let [_key, val] = _ref21;
    return ['right', val];
  },
  'background-position': _ref22 => {
    let [key, val] = _ref22;
    return [key, val.split(' ').map(word => word === 'start' ? 'left' : word === 'end' ? 'right' : word).join(' ')];
  }
};
function generateLTR(pair) {
  const [key] = pair;
  if (propertyToLTR[key]) {
    return propertyToLTR[key](pair);
  }
  return pair;
}

var generateRtl = {};

Object.defineProperty(generateRtl, "__esModule", {
  value: true
});
generateRtl.default = generateRTL;
var _postcssValueParser = _interopRequireDefault$7(require$$0);
function _interopRequireDefault$7(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const cursorFlip = {
  'e-resize': 'w-resize',
  'w-resize': 'e-resize',
  'ne-resize': 'nw-resize',
  'nesw-resize': 'nwse-resize',
  'nw-resize': 'ne-resize',
  'nwse-resize': 'nesw-resize',
  'se-resize': 'sw-resize',
  'sw-resize': 'se-resize'
};
function splitByDivisor(value) {
  const ast = (0, _postcssValueParser.default)(value);
  const groups = [];
  let currGroup = [];
  function push() {
    if (currGroup.length === 0) {
      return;
    }
    groups.push(_postcssValueParser.default.stringify(currGroup));
    currGroup = [];
  }
  for (const node of ast.nodes) {
    if (node.type === 'div') {
      push();
    } else {
      currGroup.push(node);
    }
  }
  push();
  return groups;
}
function flipSign(value) {
  if (value === '0') {
    return value;
  } else {
    return value[0] === '-' ? value.slice(1) : '-' + value;
  }
}
function flipShadow(value) {
  const defs = splitByDivisor(value);
  const builtDefs = [];
  for (const def of defs) {
    const parts = def.split(' ');
    const index = _postcssValueParser.default.unit(parts[0]) === false ? 1 : 0;
    if (index < parts.length) {
      parts[index] = flipSign(parts[index]);
    }
    builtDefs.push(parts.join(' '));
  }
  const rtl = builtDefs.join(', ');
  if (rtl !== value) {
    return rtl;
  }
}
const shadowsFlip = {
  'box-shadow': _ref => {
    let [key, val] = _ref;
    const rtlVal = flipShadow(val);
    return rtlVal ? [key, rtlVal] : null;
  },
  'text-shadow': _ref2 => {
    let [key, val] = _ref2;
    const rtlVal = flipShadow(val);
    return rtlVal ? [key, rtlVal] : null;
  }
};
const logicalToPhysical = {
  start: 'right',
  end: 'left'
};
const propertyToRTL = {
  'margin-start': _ref3 => {
    let [_key, val] = _ref3;
    return ['margin-right', val];
  },
  'margin-end': _ref4 => {
    let [_key, val] = _ref4;
    return ['margin-left', val];
  },
  'padding-start': _ref5 => {
    let [_key, val] = _ref5;
    return ['padding-right', val];
  },
  'padding-end': _ref6 => {
    let [_key, val] = _ref6;
    return ['padding-left', val];
  },
  'border-start': _ref7 => {
    let [_key, val] = _ref7;
    return ['border-right', val];
  },
  'border-end': _ref8 => {
    let [_key, val] = _ref8;
    return ['border-left', val];
  },
  'border-start-width': _ref9 => {
    let [_key, val] = _ref9;
    return ['border-right-width', val];
  },
  'border-end-width': _ref10 => {
    let [_key, val] = _ref10;
    return ['border-left-width', val];
  },
  'border-start-color': _ref11 => {
    let [_key, val] = _ref11;
    return ['border-right-color', val];
  },
  'border-end-color': _ref12 => {
    let [_key, val] = _ref12;
    return ['border-left-color', val];
  },
  'border-start-style': _ref13 => {
    let [_key, val] = _ref13;
    return ['border-right-style', val];
  },
  'border-end-style': _ref14 => {
    let [_key, val] = _ref14;
    return ['border-left-style', val];
  },
  'border-top-start-radius': _ref15 => {
    let [_key, val] = _ref15;
    return ['border-top-right-radius', val];
  },
  'border-bottom-start-radius': _ref16 => {
    let [_key, val] = _ref16;
    return ['border-bottom-right-radius', val];
  },
  'border-top-end-radius': _ref17 => {
    let [_key, val] = _ref17;
    return ['border-top-left-radius', val];
  },
  'border-bottom-end-radius': _ref18 => {
    let [_key, val] = _ref18;
    return ['border-bottom-left-radius', val];
  },
  'text-align': _ref19 => {
    let [key, val] = _ref19;
    return logicalToPhysical[val] != null ? [key, logicalToPhysical[val]] : null;
  },
  float: _ref20 => {
    let [key, val] = _ref20;
    return logicalToPhysical[val] != null ? [key, logicalToPhysical[val]] : null;
  },
  clear: _ref21 => {
    let [key, val] = _ref21;
    return logicalToPhysical[val] != null ? [key, logicalToPhysical[val]] : null;
  },
  start: _ref22 => {
    let [_key, val] = _ref22;
    return ['right', val];
  },
  end: _ref23 => {
    let [_key, val] = _ref23;
    return ['left', val];
  },
  'background-position': _ref24 => {
    let [key, val] = _ref24;
    const words = val.split(' ');
    if (!words.includes('start') && !words.includes('end')) {
      return null;
    }
    return [key, words.map(word => word === 'start' ? 'right' : word === 'end' ? 'left' : word).join(' ')];
  },
  cursor: _ref25 => {
    let [key, val] = _ref25;
    return cursorFlip[val] != null ? [key, cursorFlip[val]] : null;
  },
  ...shadowsFlip
};
function generateRTL(_ref26) {
  let [key, value] = _ref26;
  if (propertyToRTL[key]) {
    return propertyToRTL[key]([key, value]);
  }
  return null;
}

var genCSSRule$1 = {};

Object.defineProperty(genCSSRule$1, "__esModule", {
  value: true
});
genCSSRule$1.genCSSRule = genCSSRule;
const THUMB_VARIANTS = ['::-webkit-slider-thumb', '::-moz-range-thumb', '::-ms-thumb'];
function genCSSRule(className, decls, pseudos, atRules) {
  const pseudo = pseudos.filter(p => p !== '::thumb').join('');
  let selectorForAtRules = `.${className}` + atRules.map(() => `.${className}`).join('') + pseudo;
  if (pseudos.includes('::thumb')) {
    selectorForAtRules = THUMB_VARIANTS.map(suffix => selectorForAtRules + suffix).join(', ');
  }
  return atRules.reduce((acc, atRule) => `${atRule}{${acc}}`, `${selectorForAtRules}{${decls}}`);
}

var propertyPriorities = {};

Object.defineProperty(propertyPriorities, "__esModule", {
  value: true
});
propertyPriorities.default = getPriority;
const longHandPhysical = new Set();
const longHandLogical = new Set();
const shorthandsOfLonghands = new Set();
const shorthandsOfShorthands = new Set();
longHandLogical.add('background-blend-mode');
longHandLogical.add('isolation');
longHandLogical.add('mix-blend-mode');
shorthandsOfShorthands.add('animation');
longHandLogical.add('animation-composition');
longHandLogical.add('animation-delay');
longHandLogical.add('animation-direction');
longHandLogical.add('animation-duration');
longHandLogical.add('animation-fill-mode');
longHandLogical.add('animation-iteration-count');
longHandLogical.add('animation-name');
longHandLogical.add('animation-play-state');
shorthandsOfLonghands.add('animation-range');
longHandLogical.add('animation-range-end');
longHandLogical.add('animation-range-start');
longHandLogical.add('animation-timing-function');
longHandLogical.add('animation-timeline');
shorthandsOfLonghands.add('scroll-timeline');
longHandLogical.add('scroll-timeline-axis');
longHandLogical.add('scroll-timeline-name');
longHandLogical.add('timeline-scope');
shorthandsOfLonghands.add('view-timeline');
longHandLogical.add('view-timeline-axis');
longHandLogical.add('view-timeline-inset');
longHandLogical.add('view-timeline-name');
shorthandsOfShorthands.add('background');
longHandLogical.add('background-attachment');
longHandLogical.add('background-clip');
longHandLogical.add('background-color');
longHandLogical.add('background-image');
longHandLogical.add('background-origin');
longHandLogical.add('background-repeat');
longHandLogical.add('background-size');
shorthandsOfLonghands.add('background-position');
longHandLogical.add('background-position-x');
longHandLogical.add('background-position-y');
shorthandsOfShorthands.add('border');
shorthandsOfLonghands.add('border-color');
shorthandsOfLonghands.add('border-style');
shorthandsOfLonghands.add('border-width');
shorthandsOfShorthands.add('border-block');
longHandLogical.add('border-block-color');
longHandLogical.add('border-block-stylex');
longHandLogical.add('border-block-width');
shorthandsOfLonghands.add('border-block-start');
shorthandsOfLonghands.add('border-top');
longHandLogical.add('border-block-start-color');
longHandLogical.add('border-top-color');
longHandLogical.add('border-block-start-style');
longHandLogical.add('border-top-style');
longHandLogical.add('border-block-start-width');
longHandLogical.add('border-top-width');
shorthandsOfLonghands.add('border-block-end');
shorthandsOfLonghands.add('border-bottom');
longHandLogical.add('border-block-end-color');
longHandPhysical.add('border-bottom-color');
longHandLogical.add('border-block-end-style');
longHandPhysical.add('border-bottom-style');
longHandLogical.add('border-block-end-width');
longHandPhysical.add('border-bottom-width');
shorthandsOfShorthands.add('border-inline');
shorthandsOfLonghands.add('border-inline-color');
shorthandsOfLonghands.add('border-inline-style');
shorthandsOfLonghands.add('border-inline-width');
shorthandsOfLonghands.add('border-inline-start');
shorthandsOfLonghands.add('border-left');
longHandLogical.add('border-inline-start-color');
longHandPhysical.add('border-left-color');
longHandLogical.add('border-inline-start-style');
longHandPhysical.add('border-left-style');
longHandLogical.add('border-inline-start-width');
longHandPhysical.add('border-left-width');
shorthandsOfLonghands.add('border-inline-end');
shorthandsOfLonghands.add('border-right');
longHandLogical.add('border-inline-end-color');
longHandPhysical.add('border-right-color');
longHandLogical.add('border-inline-end-style');
longHandPhysical.add('border-right-style');
longHandLogical.add('border-inline-end-width');
longHandPhysical.add('border-right-width');
shorthandsOfLonghands.add('border-image');
longHandLogical.add('border-image-outset');
longHandLogical.add('border-image-repeat');
longHandLogical.add('border-image-slice');
longHandLogical.add('border-image-source');
longHandLogical.add('border-image-width');
shorthandsOfLonghands.add('border-radius');
longHandLogical.add('border-start-end-radius');
longHandLogical.add('border-start-start-radius');
longHandLogical.add('border-end-end-radius');
longHandLogical.add('border-end-start-radius');
longHandPhysical.add('border-top-left-radius');
longHandPhysical.add('border-top-right-radius');
longHandPhysical.add('border-bottom-left-radius');
longHandPhysical.add('border-bottom-right-radius');
longHandLogical.add('box-shadow');
longHandLogical.add('accent-color');
longHandLogical.add('appearance');
longHandLogical.add('aspect-ratio');
shorthandsOfLonghands.add('caret');
longHandLogical.add('caret-color');
longHandLogical.add('caret-shape');
longHandLogical.add('cursor');
longHandLogical.add('ime-mode');
longHandLogical.add('input-security');
shorthandsOfLonghands.add('outline');
longHandLogical.add('outline-color');
longHandLogical.add('outline-offset');
longHandLogical.add('outline-style');
longHandLogical.add('outline-width');
longHandLogical.add('pointer-events');
longHandLogical.add('resize');
longHandLogical.add('text-overflow');
longHandLogical.add('user-select');
shorthandsOfLonghands.add('grid-gap');
shorthandsOfLonghands.add('gap');
longHandLogical.add('grid-row-gap');
longHandLogical.add('row-gap');
longHandLogical.add('grid-column-gap');
longHandLogical.add('column-gap');
shorthandsOfLonghands.add('place-content');
longHandLogical.add('align-content');
longHandLogical.add('justify-content');
shorthandsOfLonghands.add('place-items');
longHandLogical.add('align-items');
longHandLogical.add('justify-items');
shorthandsOfLonghands.add('place-self');
longHandLogical.add('align-self');
longHandLogical.add('justify-self');
longHandLogical.add('box-sizing');
longHandLogical.add('block-size');
longHandPhysical.add('height');
longHandLogical.add('inline-size');
longHandPhysical.add('width');
longHandLogical.add('max-block-size');
longHandPhysical.add('max-height');
longHandLogical.add('max-inline-size');
longHandPhysical.add('max-width');
longHandLogical.add('min-block-size');
longHandPhysical.add('min-height');
longHandLogical.add('min-inline-size');
longHandPhysical.add('min-width');
shorthandsOfShorthands.add('margin');
shorthandsOfLonghands.add('margin-block');
longHandLogical.add('margin-block-start');
longHandPhysical.add('margin-top');
longHandLogical.add('margin-block-end');
longHandPhysical.add('margin-bottom');
shorthandsOfLonghands.add('margin-inline');
longHandLogical.add('margin-inline-start');
longHandPhysical.add('margin-left');
longHandLogical.add('margin-inline-end');
longHandPhysical.add('margin-right');
longHandLogical.add('margin-trim');
shorthandsOfLonghands.add('overscroll-behavior');
longHandLogical.add('overscroll-behavior-block');
longHandPhysical.add('overscroll-behavior-y');
longHandLogical.add('overscroll-behavior-inline');
longHandPhysical.add('overscroll-behavior-x');
shorthandsOfShorthands.add('padding');
shorthandsOfLonghands.add('padding-block');
longHandLogical.add('padding-block-start');
longHandPhysical.add('padding-top');
longHandLogical.add('padding-block-end');
longHandPhysical.add('padding-bottom');
shorthandsOfLonghands.add('padding-inline');
longHandLogical.add('padding-inline-start');
longHandPhysical.add('padding-left');
longHandLogical.add('padding-inline-end');
longHandPhysical.add('padding-right');
longHandLogical.add('visibility');
longHandLogical.add('color');
longHandLogical.add('color-scheme');
longHandLogical.add('forced-color-adjust');
longHandLogical.add('opacity');
longHandLogical.add('print-color-adjust');
shorthandsOfLonghands.add('columns');
longHandLogical.add('column-count');
longHandLogical.add('column-width');
longHandLogical.add('column-fill');
longHandLogical.add('column-span');
shorthandsOfLonghands.add('column-rule');
longHandLogical.add('column-rule-color');
longHandLogical.add('column-rule-style');
longHandLogical.add('column-rule-width');
longHandLogical.add('contain');
shorthandsOfLonghands.add('contain-intrinsic-size');
longHandLogical.add('contain-intrinsic-block-size');
longHandLogical.add('contain-intrinsic-width');
longHandLogical.add('contain-intrinsic-height');
longHandLogical.add('contain-intrinsic-inline-size');
shorthandsOfLonghands.add('container');
longHandLogical.add('container-name');
longHandLogical.add('container-type');
longHandLogical.add('content-visibility');
longHandLogical.add('counter-increment');
longHandLogical.add('counter-reset');
longHandLogical.add('counter-set');
longHandLogical.add('display');
shorthandsOfLonghands.add('flex');
longHandLogical.add('flex-basis');
longHandLogical.add('flex-grow');
longHandLogical.add('flex-shrink');
shorthandsOfLonghands.add('flex-flow');
longHandLogical.add('flex-direction');
longHandLogical.add('flex-wrap');
longHandLogical.add('order');
shorthandsOfShorthands.add('font');
longHandLogical.add('font-family');
longHandLogical.add('font-size');
longHandLogical.add('font-stretch');
longHandLogical.add('font-style');
longHandLogical.add('font-weight');
longHandLogical.add('line-height');
shorthandsOfLonghands.add('font-variant');
longHandLogical.add('font-variant-alternates');
longHandLogical.add('font-variant-caps');
longHandLogical.add('font-variant-east-asian');
longHandLogical.add('font-variant-emoji');
longHandLogical.add('font-variant-ligatures');
longHandLogical.add('font-variant-numeric');
longHandLogical.add('font-variant-position');
longHandLogical.add('font-feature-settings');
longHandLogical.add('font-kerning');
longHandLogical.add('font-language-override');
longHandLogical.add('font-optical-sizing');
longHandLogical.add('font-palette');
longHandLogical.add('font-variation-settings');
longHandLogical.add('font-size-adjust');
longHandLogical.add('font-smooth');
longHandLogical.add('font-synthesis-position');
longHandLogical.add('font-synthesis-small-caps');
longHandLogical.add('font-synthesis-style');
longHandLogical.add('font-synthesis-weight');
longHandLogical.add('line-height-step');
longHandLogical.add('box-decoration-break');
longHandLogical.add('break-after');
longHandLogical.add('break-before');
longHandLogical.add('break-inside');
longHandLogical.add('orphans');
longHandLogical.add('widows');
longHandLogical.add('content');
longHandLogical.add('quotes');
shorthandsOfShorthands.add('grid');
longHandLogical.add('grid-auto-flow');
longHandLogical.add('grid-auto-rows');
longHandLogical.add('grid-auto-columns');
shorthandsOfShorthands.add('grid-template');
shorthandsOfLonghands.add('grid-template-areas');
longHandLogical.add('grid-template-columns');
longHandLogical.add('grid-template-rows');
shorthandsOfShorthands.add('grid-area');
shorthandsOfLonghands.add('grid-row');
longHandLogical.add('grid-row-start');
longHandLogical.add('grid-row-end');
shorthandsOfLonghands.add('grid-column');
longHandLogical.add('grid-column-start');
longHandLogical.add('grid-column-end');
longHandLogical.add('align-tracks');
longHandLogical.add('justify-tracks');
longHandLogical.add('masonry-auto-flow');
longHandLogical.add('image-orientation');
longHandLogical.add('image-rendering');
longHandLogical.add('image-resolution');
longHandLogical.add('object-fit');
longHandLogical.add('object-position');
longHandLogical.add('initial-letter');
longHandLogical.add('initial-letter-align');
shorthandsOfLonghands.add('list-style');
longHandLogical.add('list-style-image');
longHandLogical.add('list-style-position');
longHandLogical.add('list-style-type');
longHandLogical.add('clip');
longHandLogical.add('clip-path');
shorthandsOfLonghands.add('mask');
longHandLogical.add('mask-clip');
longHandLogical.add('mask-composite');
longHandLogical.add('mask-image');
longHandLogical.add('mask-mode');
longHandLogical.add('mask-origin');
longHandLogical.add('mask-position');
longHandLogical.add('mask-repeat');
longHandLogical.add('mask-size');
longHandLogical.add('mask-type');
shorthandsOfLonghands.add('mask-border');
longHandLogical.add('mask-border-mode');
longHandLogical.add('mask-border-outset');
longHandLogical.add('mask-border-repeat');
longHandLogical.add('mask-border-slice');
longHandLogical.add('mask-border-source');
longHandLogical.add('mask-border-width');
shorthandsOfShorthands.add('all');
longHandLogical.add('text-rendering');
shorthandsOfLonghands.add('offset');
longHandLogical.add('offset-anchor');
longHandLogical.add('offset-distance');
longHandLogical.add('offset-path');
longHandLogical.add('offset-position');
longHandLogical.add('offset-rotate');
longHandLogical.add('-webkit-box-orient');
longHandLogical.add('-webkit-line-clamp');
shorthandsOfLonghands.add('overflow');
longHandLogical.add('overflow-block');
longHandPhysical.add('overflow-y');
longHandLogical.add('overflow-inline');
longHandPhysical.add('overflow-x');
longHandLogical.add('overflow-clip-margin');
longHandLogical.add('scroll-gutter');
longHandLogical.add('scroll-behavior');
longHandLogical.add('page');
longHandLogical.add('page-break-after');
longHandLogical.add('page-break-before');
longHandLogical.add('page-break-inside');
shorthandsOfShorthands.add('inset');
shorthandsOfLonghands.add('inset-block');
longHandLogical.add('inset-block-start');
longHandPhysical.add('top');
longHandLogical.add('inset-block-end');
longHandPhysical.add('bottom');
shorthandsOfLonghands.add('inset-inline');
longHandLogical.add('inset-inline-start');
longHandPhysical.add('left');
longHandLogical.add('inset-inline-end');
longHandPhysical.add('right');
longHandLogical.add('clear');
longHandLogical.add('float');
longHandLogical.add('position');
longHandLogical.add('z-index');
longHandLogical.add('ruby-align');
longHandLogical.add('ruby-merge');
longHandLogical.add('ruby-position');
longHandLogical.add('overflow-anchor');
shorthandsOfShorthands.add('scroll-margin');
shorthandsOfLonghands.add('scroll-margin-block');
longHandLogical.add('scroll-margin-block-start');
longHandPhysical.add('scroll-margin-top');
longHandLogical.add('scroll-margin-block-end');
longHandPhysical.add('scroll-margin-bottom');
shorthandsOfLonghands.add('scroll-margin-inline');
longHandLogical.add('scroll-margin-inline-start');
longHandPhysical.add('scroll-margin-left');
longHandLogical.add('scroll-margin-inline-end');
longHandPhysical.add('scroll-margin-right');
shorthandsOfShorthands.add('scroll-padding');
shorthandsOfLonghands.add('scroll-padding-block');
longHandLogical.add('scroll-padding-block-start');
longHandPhysical.add('scroll-padding-top');
longHandLogical.add('scroll-padding-block-end');
longHandPhysical.add('scroll-padding-bottom');
shorthandsOfLonghands.add('scroll-padding-inline');
longHandLogical.add('scroll-padding-inline-start');
longHandPhysical.add('scroll-padding-left');
longHandLogical.add('scroll-padding-inline-end');
longHandPhysical.add('scroll-padding-right');
longHandLogical.add('scroll-snap-align');
longHandLogical.add('scroll-snap-stop');
shorthandsOfLonghands.add('scroll-snap-type');
longHandLogical.add('scrollbar-color');
longHandLogical.add('scrollbar-width');
longHandLogical.add('shape-image-threshold');
longHandLogical.add('shape-margin');
longHandLogical.add('shape-outside');
longHandLogical.add('azimuth');
longHandLogical.add('border-collapse');
longHandLogical.add('border-spacing');
longHandLogical.add('caption-side');
longHandLogical.add('empty-cells');
longHandLogical.add('table-layout');
longHandLogical.add('vertical-align');
shorthandsOfLonghands.add('text-decoration');
longHandLogical.add('text-decoration-color');
longHandLogical.add('text-decoration-line');
longHandLogical.add('text-decoration-skip');
longHandLogical.add('text-decoration-skip-ink');
longHandLogical.add('text-decoration-style');
longHandLogical.add('text-decoration-thickness');
shorthandsOfLonghands.add('text-emphasis');
longHandLogical.add('text-emphasis-color');
longHandLogical.add('text-emphasis-position');
longHandLogical.add('text-emphasis-style');
longHandLogical.add('text-shadow');
longHandLogical.add('text-underline-offset');
longHandLogical.add('text-underline-position');
longHandLogical.add('hanging-punctuation');
longHandLogical.add('hyphenate-character');
longHandLogical.add('hyphenate-limit-chars');
longHandLogical.add('hyphens');
longHandLogical.add('letter-spacing');
longHandLogical.add('line-break');
longHandLogical.add('overflow-wrap');
longHandLogical.add('paint-order');
longHandLogical.add('tab-size');
longHandLogical.add('text-align');
longHandLogical.add('text-align-last');
longHandLogical.add('text-indent');
longHandLogical.add('text-justify');
longHandLogical.add('text-size-adjust');
longHandLogical.add('text-transform');
longHandLogical.add('text-wrap');
longHandLogical.add('white-space');
longHandLogical.add('white-space-collapse');
longHandLogical.add('word-break');
longHandLogical.add('word-spacing');
longHandLogical.add('word-wrap');
longHandLogical.add('backface-visibility');
longHandLogical.add('perspective');
longHandLogical.add('perspective-origin');
longHandLogical.add('rotate');
longHandLogical.add('scale');
longHandLogical.add('transform');
longHandLogical.add('transform-box');
longHandLogical.add('transform-origin');
longHandLogical.add('transform-style');
longHandLogical.add('translate');
shorthandsOfLonghands.add('transition');
longHandLogical.add('transition-delay');
longHandLogical.add('transition-duration');
longHandLogical.add('transition-property');
longHandLogical.add('transition-timing-function');
longHandLogical.add('view-transition-name');
longHandLogical.add('will-change');
longHandLogical.add('direction');
longHandLogical.add('text-combine-upright');
longHandLogical.add('text-orientation');
longHandLogical.add('unicode-bidi');
longHandLogical.add('writing-mode');
longHandLogical.add('backdrop-filter');
longHandLogical.add('filter');
longHandLogical.add('math-depth');
longHandLogical.add('math-shift');
longHandLogical.add('math-style');
longHandLogical.add('touch-action');
const PRIORITIES = {
  ':is': 40,
  ':where': 40,
  ':not': 40,
  ':has': 45,
  ':dir': 50,
  ':lang': 51,
  ':first-child': 52,
  ':first-of-type': 53,
  ':last-child': 54,
  ':last-of-type': 55,
  ':only-child': 56,
  ':only-of-type': 57,
  ':nth-child': 60,
  ':nth-last-child': 61,
  ':nth-of-type': 62,
  ':nth-last-of-type': 63,
  ':empty': 70,
  ':link': 80,
  ':any-link': 81,
  ':local-link': 82,
  ':target-within': 83,
  ':target': 84,
  ':visited': 85,
  ':enabled': 91,
  ':disabled': 92,
  ':required': 93,
  ':optional': 94,
  ':read-only': 95,
  ':read-write': 96,
  ':placeholder-shown': 97,
  ':in-range': 98,
  ':out-of-range': 99,
  ':default': 100,
  ':checked': 101,
  ':indeterminate': 101,
  ':blank': 102,
  ':valid': 103,
  ':invalid': 104,
  ':user-invalid': 105,
  ':autofill': 110,
  ':picture-in-picture': 120,
  ':modal': 121,
  ':fullscreen': 122,
  ':paused': 123,
  ':playing': 124,
  ':current': 125,
  ':past': 126,
  ':future': 127,
  ':hover': 130,
  ':focusWithin': 140,
  ':focus': 150,
  ':focusVisible': 160,
  ':active': 170
};
function getPriority(key) {
  if (key.startsWith('--')) {
    return 1;
  }
  if (key.startsWith('@supports')) {
    return 30;
  }
  if (key.startsWith('@media')) {
    return 200;
  }
  if (key.startsWith('@container')) {
    return 300;
  }
  if (key.startsWith('::')) {
    return 5000;
  }
  if (key.startsWith(':')) {
    const prop = key.startsWith(':') && key.includes('(') ? key.slice(0, key.indexOf('(')) : key;
    return PRIORITIES[prop] ?? 40;
  }
  if (longHandPhysical.has(key)) {
    return 4000;
  }
  if (longHandLogical.has(key)) {
    return 3000;
  }
  if (shorthandsOfLonghands.has(key)) {
    return 2000;
  }
  if (shorthandsOfShorthands.has(key)) {
    return 1000;
  }
  return 3000;
}

Object.defineProperty(generateCssRule, "__esModule", {
  value: true
});
generateCssRule.generateRule = generateRule;
var _generateLtr$1 = _interopRequireDefault$6(generateLtr);
var _generateRtl$1 = _interopRequireDefault$6(generateRtl);
var _genCSSRule = genCSSRule$1;
var _propertyPriorities = _interopRequireDefault$6(propertyPriorities);
function _interopRequireDefault$6(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function generateRule(className, key, value, pseudos, atRules) {
  const pairs = Array.isArray(value) ? value.map(eachValue => [key, eachValue]) : [[key, value]];
  const ltrPairs = pairs.map(_generateLtr$1.default);
  const ltrDecls = ltrPairs.map(pair => pair.join(':')).join(';');
  const rtlDecls = pairs.map(_generateRtl$1.default).filter(Boolean).map(pair => pair.join(':')).join(';');
  const ltrRule = (0, _genCSSRule.genCSSRule)(className, ltrDecls, pseudos, atRules);
  const rtlRule = !rtlDecls ? null : (0, _genCSSRule.genCSSRule)(className, rtlDecls, pseudos, atRules);
  const priority = (0, _propertyPriorities.default)(key) + pseudos.map(_propertyPriorities.default).reduce((a, b) => a + b, 0) + atRules.map(_propertyPriorities.default).reduce((a, b) => a + b, 0);
  return {
    priority,
    ltr: ltrRule,
    rtl: rtlRule
  };
}

Object.defineProperty(convertToClassName, "__esModule", {
  value: true
});
convertToClassName.convertStyleToClassName = convertStyleToClassName;
var _hash$4 = _interopRequireDefault$5(hash$1);
var _dashify$1 = _interopRequireDefault$5(dashify$1);
var _transformValue$1 = _interopRequireDefault$5(transformValue$1);
var _generateCssRule = generateCssRule;
var _defaultOptions$4 = defaultOptions;
var _objectUtils$5 = objectUtils;
function _interopRequireDefault$5(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function convertStyleToClassName(objEntry, pseudos, atRules) {
  let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : _defaultOptions$4.defaultOptions;
  const {
    classNamePrefix = 'x'
  } = options;
  const [key, rawValue] = objEntry;
  const dashedKey = (0, _dashify$1.default)(key);
  const value = Array.isArray(rawValue) ? rawValue.map(eachValue => (0, _transformValue$1.default)(key, eachValue, options)) : (0, _transformValue$1.default)(key, rawValue, options);
  const sortedPseudos = (0, _objectUtils$5.arraySort)(pseudos ?? []);
  const sortedAtRules = (0, _objectUtils$5.arraySort)(atRules ?? []);
  const atRuleHashString = sortedPseudos.join('');
  const pseudoHashString = sortedAtRules.join('');
  const modifierHashString = atRuleHashString + pseudoHashString || 'null';
  const stringToHash = Array.isArray(value) ? dashedKey + value.join(', ') + modifierHashString : dashedKey + value + modifierHashString;
  const className = classNamePrefix + (0, _hash$4.default)('<>' + stringToHash);
  const cssRules = (0, _generateCssRule.generateRule)(className, dashedKey, value, pseudos, atRules);
  return [key, className, cssRules];
}

Object.defineProperty(PreRule$1, "__esModule", {
  value: true
});
PreRule$1.PreRuleSet = PreRule$1.PreRule = PreRule$1.PreIncludedStylesRule = PreRule$1.NullPreRule = void 0;
var _convertToClassName = convertToClassName;
var _objectUtils$4 = objectUtils;
class NullPreRule {
  compiled(_options) {
    return [null];
  }
  equals(other) {
    return other instanceof NullPreRule;
  }
}
PreRule$1.NullPreRule = NullPreRule;
class PreIncludedStylesRule {
  constructor(IncludedStyles) {
    this.includedStyles = IncludedStyles;
  }
  equals(other) {
    return other instanceof PreIncludedStylesRule && this.includedStyles === other.includedStyles;
  }
  compiled(_options) {
    return this.includedStyles;
  }
}
PreRule$1.PreIncludedStylesRule = PreIncludedStylesRule;
const stringComparator = (a, b) => {
  if (a === 'default') {
    return -1;
  }
  if (b === 'default') {
    return 1;
  }
  return a.localeCompare(b);
};
class PreRule {
  constructor(property, value, pseudos, atRules) {
    this.property = property;
    this.value = value;
    this.pseudos = pseudos ? (0, _objectUtils$4.arraySort)(pseudos, stringComparator) : [];
    this.atRules = atRules ? (0, _objectUtils$4.arraySort)(atRules) : [];
  }
  compiled(options) {
    const [_key, className, rule] = (0, _convertToClassName.convertStyleToClassName)([this.property, this.value], this.pseudos ?? [], this.atRules ?? [], options);
    return [[className, rule]];
  }
  equals(other) {
    if (!(other instanceof PreRule)) {
      return false;
    }
    const valuesEqual = Array.isArray(this.value) && Array.isArray(other.value) ? (0, _objectUtils$4.arrayEquals)(this.value, other.value) : this.value === other.value;
    return this.property === other.property && valuesEqual && (0, _objectUtils$4.arrayEquals)(this.pseudos, other.pseudos) && (0, _objectUtils$4.arrayEquals)(this.atRules, other.atRules);
  }
}
PreRule$1.PreRule = PreRule;
class PreRuleSet {
  constructor(rules) {
    this.rules = rules;
  }
  static create(rules) {
    const flatRules = rules.flatMap(rule => rule instanceof PreRuleSet ? rule.rules : [rule]);
    if (flatRules.length === 0) {
      return new NullPreRule();
    }
    if (flatRules.length === 1) {
      return flatRules[0];
    }
    return new PreRuleSet(flatRules);
  }
  compiled(options) {
    const styleTuple = this.rules.flatMap(rule => rule.compiled(options)).filter(Boolean);
    return styleTuple.length > 0 ? styleTuple : [null];
  }
  equals(other) {
    if (!(other instanceof PreRuleSet)) {
      return false;
    }
    if (this.rules.length !== other.rules.length) {
      return false;
    }
    return (0, _objectUtils$4.arrayEquals)(this.rules, other.rules, (a, b) => a.equals(b));
  }
}
PreRule$1.PreRuleSet = PreRuleSet;

Object.defineProperty(flattenRawStyleObj, "__esModule", {
  value: true
});
flattenRawStyleObj._flattenRawStyleObject = _flattenRawStyleObject;
flattenRawStyleObj.flattenRawStyleObject = flattenRawStyleObject;
var _index$1 = _interopRequireDefault$4(preprocessRules);
var _PreRule = PreRule$1;
var _stylexInclude$3 = stylexInclude$2;
function _interopRequireDefault$4(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function flattenRawStyleObject(style, options) {
  return _flattenRawStyleObject(style, [], [], options);
}
function _flattenRawStyleObject(style, pseudos, atRules, options) {
  const flattened = [];
  for (const _key in style) {
    const value = style[_key];
    const key = _key.match(/var\(--[a-z0-9]+\)/) ? _key.slice(4, -1) : _key;
    if (typeof value === 'object' && value instanceof _stylexInclude$3.IncludedStyles) {
      flattened.push([key, new _PreRule.PreIncludedStylesRule(value)]);
      continue;
    }
    if (value === null || typeof value === 'string' || typeof value === 'number') {
      const pairs = (0, _index$1.default)([key, value], options);
      for (const [property, value] of pairs) {
        if (value === null) {
          flattened.push([property, new _PreRule.NullPreRule()]);
        } else {
          flattened.push([property, new _PreRule.PreRule(property, value, pseudos, atRules)]);
        }
      }
      continue;
    }
    if (Array.isArray(value)) {
      const equivalentPairs = {};
      for (const eachVal of value) {
        const pairs = (0, _index$1.default)([key, eachVal], options);
        for (const [property, val] of pairs) {
          if (Array.isArray(val)) {
            if (equivalentPairs[property] == null) {
              equivalentPairs[property] = [...val];
            } else {
              equivalentPairs[property].push(...val);
            }
          } else if (equivalentPairs[property] == null) {
            equivalentPairs[property] = [val];
          } else {
            equivalentPairs[property].push(val);
          }
        }
      }
      Object.entries(equivalentPairs).map(_ref => {
        let [property, values] = _ref;
        return [property, [...new Set(values.filter(Boolean))]];
      }).map(_ref2 => {
        let [property, values] = _ref2;
        return [property, values.length === 0 ? null : values.length === 1 ? values[0] : values];
      }).forEach(_ref3 => {
        let [property, value] = _ref3;
        if (value === null) {
          flattened.push([property, new _PreRule.NullPreRule()]);
        } else {
          flattened.push([property, new _PreRule.PreRule(property, value, pseudos, atRules)]);
        }
      });
      continue;
    }
    if (typeof value === 'object' && !key.startsWith(':') && !key.startsWith('@')) {
      const equivalentPairs = {};
      for (const condition in value) {
        const innerValue = value[condition];
        const pseudosToPassDown = [...pseudos];
        const atRulesToPassDown = [...atRules];
        if (condition.startsWith(':')) {
          pseudosToPassDown.push(condition);
        } else if (condition.startsWith('@')) {
          atRulesToPassDown.push(condition);
        }
        const pairs = _flattenRawStyleObject({
          [key]: innerValue
        }, pseudosToPassDown, atRulesToPassDown, options);
        for (const [property, preRule] of pairs) {
          if (preRule instanceof _PreRule.PreIncludedStylesRule) {
            throw new Error('stylex.include can only be used at the top-level');
          }
          if (equivalentPairs[property] == null) {
            equivalentPairs[property] = {
              [condition]: preRule
            };
          } else {
            equivalentPairs[property][condition] = preRule;
          }
        }
      }
      for (const [property, obj] of Object.entries(equivalentPairs)) {
        const sortedKeys = Object.keys(obj);
        const rules = [];
        for (const condition of sortedKeys) {
          rules.push(obj[condition]);
        }
        flattened.push([property, _PreRule.PreRuleSet.create(rules)]);
      }
    }
    if (typeof value === 'object' && (key.startsWith(':') || key.startsWith('@'))) {
      const pseudosToPassDown = [...pseudos];
      const atRulesToPassDown = [...atRules];
      if (key.startsWith(':')) {
        pseudosToPassDown.push(key);
      } else if (key.startsWith('@')) {
        atRulesToPassDown.push(key);
      }
      const pairs = _flattenRawStyleObject(value, pseudosToPassDown, atRulesToPassDown, options);
      for (const [property, preRule] of pairs) {
        flattened.push([key + '_' + property, preRule]);
      }
    }
  }
  return flattened;
}

var basicValidation = {};

Object.defineProperty(basicValidation, "__esModule", {
  value: true
});
basicValidation.validateNamespace = validateNamespace;
var _stylexInclude$2 = stylexInclude$2;
var messages = _interopRequireWildcard$1(messages$3);
var _objectUtils$3 = objectUtils;
function _getRequireWildcardCache$1(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache$1 = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard$1(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache$1(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function validateNamespace(namespace) {
  let conditions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  if (!(0, _objectUtils$3.isPlainObject)(namespace)) {
    throw new Error(messages.ILLEGAL_NAMESPACE_VALUE);
  }
  const ns = namespace;
  for (const key in ns) {
    const val = ns[key];
    if (val === null || typeof val === 'string' || typeof val === 'number') {
      continue;
    }
    if (Array.isArray(val)) {
      for (const v of val) {
        if (v === null || typeof v === 'string' || typeof v === 'number') {
          continue;
        }
        throw new Error(messages.ILLEGAL_PROP_ARRAY_VALUE);
      }
      continue;
    }
    if (val instanceof _stylexInclude$2.IncludedStyles) {
      if (conditions.length === 0) {
        continue;
      }
      throw new Error(messages.ONLY_TOP_LEVEL_INCLUDES);
    }
    if ((0, _objectUtils$3.isPlainObject)(val)) {
      if (key.startsWith('@') || key.startsWith(':')) {
        if (conditions.includes(key)) {
          throw new Error(messages.DUPLICATE_CONDITIONAL);
        }
        validateNamespace(val, [...conditions, key]);
      } else {
        validateConditionalStyles(val);
      }
      continue;
    }
    throw new Error(messages.ILLEGAL_PROP_VALUE);
  }
}
function validateConditionalStyles(val) {
  let conditions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  for (const key in val) {
    const v = val[key];
    if (!(key.startsWith('@') || key.startsWith(':') || key === 'default')) {
      throw new Error(messages.INVALID_PSEUDO_OR_AT_RULE);
    }
    if (conditions.includes(key)) {
      throw new Error(messages.DUPLICATE_CONDITIONAL);
    }
    if (v === null || typeof v === 'string' || typeof v === 'number') {
      continue;
    }
    if (Array.isArray(v)) {
      for (const vv of v) {
        if (vv === null || typeof vv === 'string' || typeof vv === 'number') {
          continue;
        }
        throw new Error(messages.ILLEGAL_PROP_VALUE);
      }
      continue;
    }
    if (v instanceof _stylexInclude$2.IncludedStyles) {
      throw new Error(messages.ONLY_TOP_LEVEL_INCLUDES);
    }
    if ((0, _objectUtils$3.isPlainObject)(v)) {
      validateConditionalStyles(v, [...conditions, key]);
      continue;
    }
    throw new Error(messages.ILLEGAL_PROP_VALUE);
  }
}

Object.defineProperty(stylexCreate$1, "__esModule", {
  value: true
});
stylexCreate$1.default = styleXCreateSet;
var _objectUtils$2 = objectUtils;
var _stylexInclude$1 = stylexInclude$2;
var _defaultOptions$3 = defaultOptions;
var _flattenRawStyleObj = flattenRawStyleObj;
var _basicValidation = basicValidation;
function styleXCreateSet(namespaces) {
  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _defaultOptions$3.defaultOptions;
  const resolvedNamespaces = {};
  const injectedStyles = {};
  for (const namespaceName of Object.keys(namespaces)) {
    const namespace = namespaces[namespaceName];
    (0, _basicValidation.validateNamespace)(namespace);
    const flattenedNamespace = (0, _flattenRawStyleObj.flattenRawStyleObject)(namespace, options);
    const compiledNamespaceTuples = flattenedNamespace.map(_ref => {
      let [key, value] = _ref;
      return [key, value.compiled(options)];
    });
    const compiledNamespace = (0, _objectUtils$2.objFromEntries)(compiledNamespaceTuples);
    const namespaceObj = {};
    for (const key of Object.keys(compiledNamespace)) {
      const value = compiledNamespace[key];
      if (value instanceof _stylexInclude$1.IncludedStyles) {
        namespaceObj[key] = value;
      } else {
        const classNameTuples = value.map(v => Array.isArray(v) ? v : null).filter(Boolean);
        const className = classNameTuples.map(_ref2 => {
          let [className] = _ref2;
          return className;
        }).join(' ') || null;
        namespaceObj[key] = className;
        for (const [className, injectable] of classNameTuples) {
          if (injectedStyles[className] == null) {
            injectedStyles[className] = injectable;
          }
        }
      }
    }
    resolvedNamespaces[namespaceName] = {
      ...namespaceObj,
      $$css: true
    };
  }
  return [resolvedNamespaces, injectedStyles];
}

var stylexDefineVars$1 = {};

Object.defineProperty(stylexDefineVars$1, "__esModule", {
  value: true
});
stylexDefineVars$1.default = styleXDefineVars;
var _hash$3 = _interopRequireDefault$3(hash$1);
var _objectUtils$1 = objectUtils;
var _defaultOptions$2 = defaultOptions;
function _interopRequireDefault$3(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function styleXDefineVars(variables, options) {
  const {
    classNamePrefix,
    themeName
  } = {
    ..._defaultOptions$2.defaultOptions,
    ...options
  };
  const themeNameHash = classNamePrefix + (0, _hash$3.default)(themeName);
  const variablesMap = (0, _objectUtils$1.objMap)(variables, (value, key) => {
    const nameHash = classNamePrefix + (0, _hash$3.default)(`${themeName}.${key}`);
    return {
      nameHash,
      value
    };
  });
  const themeVariablesObject = (0, _objectUtils$1.objMap)(variablesMap, _ref => {
    let {
      nameHash
    } = _ref;
    return `var(--${nameHash})`;
  });
  const injectableStyles = constructCssVariablesString(variablesMap, themeNameHash);
  return [{
    ...themeVariablesObject,
    __themeName__: themeNameHash
  }, injectableStyles];
}
function constructCssVariablesString(variables, themeNameHash) {
  const ruleByAtRule = {};
  for (const [key, {
    nameHash,
    value
  }] of (0, _objectUtils$1.objEntries)(variables)) {
    if (value !== null && typeof value === 'object') {
      if (value.default === undefined) {
        throw new Error('Default value is not defined for ' + key + ' variable.');
      }
      const v = value;
      for (const [key, value] of (0, _objectUtils$1.objEntries)(v)) {
        ruleByAtRule[key] ??= [];
        ruleByAtRule[key].push(`--${nameHash}:${value};`);
      }
    } else {
      ruleByAtRule.default ??= [];
      ruleByAtRule.default.push(`--${nameHash}:${value};`);
    }
  }
  const result = {};
  for (const [key, value] of (0, _objectUtils$1.objEntries)(ruleByAtRule)) {
    const suffix = key === 'default' ? '' : `-${(0, _hash$3.default)(key)}`;
    let ltr = `:root{${value.join('')}}`;
    if (key !== 'default') {
      ltr = `${key}{${ltr}}`;
    }
    result[themeNameHash + suffix] = {
      ltr,
      rtl: null,
      priority: key === 'default' ? 0 : 0.1
    };
  }
  return result;
}

var stylexCreateTheme$1 = {};

Object.defineProperty(stylexCreateTheme$1, "__esModule", {
  value: true
});
stylexCreateTheme$1.default = styleXCreateTheme;
var _hash$2 = _interopRequireDefault$2(hash$1);
var _defaultOptions$1 = defaultOptions;
function _interopRequireDefault$2(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function styleXCreateTheme(themeVars, variables, options) {
  if (typeof themeVars.__themeName__ !== 'string') {
    throw new Error('Can only override variables theme created with stylex.defineVars().');
  }
  const {
    classNamePrefix
  } = {
    ..._defaultOptions$1.defaultOptions,
    ...options
  };
  const sortedKeys = Object.keys(variables).sort();
  const atRules = {};
  const cssVariablesOverrideString = sortedKeys.map(key => {
    const varNameHash = themeVars[key].slice(4, -1);
    const value = variables[key];
    if (varNameHash != null && value !== null && typeof value === 'object') {
      if (value.default === undefined) {
        throw new Error('Default value is not defined for ' + key + ' variable.');
      }
      const definedVarString = `${varNameHash}:${value.default};`;
      Object.keys(value).forEach(key => {
        if (key.startsWith('@')) {
          const definedVarStringForAtRule = `${varNameHash}:${value[key]};`;
          if (atRules[key] == null) {
            atRules[key] = [definedVarStringForAtRule];
          } else {
            atRules[key].push(definedVarStringForAtRule);
          }
        }
      });
      return definedVarString;
    }
    return varNameHash != null && typeof value !== 'object' ? `${varNameHash}:${value};` : '';
  }).join('');
  const sortedAtRules = Object.keys(atRules).sort();
  const atRulesStringForHash = sortedAtRules.map(atRule => {
    return `${atRule}{${atRules[atRule].sort().join('')}}`;
  }).join('');
  const overrideClassName = classNamePrefix + (0, _hash$2.default)(cssVariablesOverrideString + atRulesStringForHash);
  const stylesToInject = {
    [overrideClassName]: {
      ltr: `.${overrideClassName}{${cssVariablesOverrideString}}`,
      priority: 0.8,
      rtl: undefined
    }
  };
  for (const atRule of sortedAtRules) {
    stylesToInject[overrideClassName + '-' + (0, _hash$2.default)(atRule)] = {
      ltr: `${atRule}{.${overrideClassName}{${atRules[atRule].join('')}}}`,
      priority: 0.9,
      rtl: null
    };
  }
  return [{
    $$css: true,
    [themeVars.__themeName__]: overrideClassName
  }, stylesToInject];
}

var stylexKeyframes = {};

Object.defineProperty(stylexKeyframes, "__esModule", {
  value: true
});
stylexKeyframes.default = styleXKeyframes;
var _hash$1 = _interopRequireDefault$1(hash$1);
var _index = _interopRequireDefault$1(preprocessRules);
var _generateLtr = _interopRequireDefault$1(generateLtr);
var _generateRtl = _interopRequireDefault$1(generateRtl);
var _transformValue = _interopRequireDefault$1(transformValue$1);
var _dashify = _interopRequireDefault$1(dashify$1);
var _objectUtils = objectUtils;
var _defaultOptions = defaultOptions;
function _interopRequireDefault$1(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function styleXKeyframes(frames) {
  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _defaultOptions.defaultOptions;
  const {
    classNamePrefix = 'x'
  } = options;
  const expandedObject = (0, _objectUtils.objMap)(frames, frame => _objectUtils.Pipe.create(frame).pipe(frame => expandFrameShorthands(frame, options)).pipe(x => (0, _objectUtils.objMapKeys)(x, _dashify.default)).pipe(x => (0, _objectUtils.objMap)(x, (value, key) => (0, _transformValue.default)(key, value, options))).done());
  const ltrStyles = (0, _objectUtils.objMap)(expandedObject, frame => (0, _objectUtils.objMapEntry)(frame, _generateLtr.default));
  const rtlStyles = (0, _objectUtils.objMap)(expandedObject, frame => (0, _objectUtils.objMapEntry)(frame, entry => (0, _generateRtl.default)(entry) ?? entry));
  const ltrString = constructKeyframesObj(ltrStyles);
  const rtlString = constructKeyframesObj(rtlStyles);
  const animationName = classNamePrefix + (0, _hash$1.default)('<>' + ltrString) + '-B';
  const ltr = `@keyframes ${animationName}{${ltrString}}`;
  const rtl = ltrString === rtlString ? null : `@keyframes ${animationName}{${rtlString}}`;
  return [animationName, {
    ltr,
    rtl,
    priority: 1
  }];
}
function expandFrameShorthands(frame, options) {
  return (0, _objectUtils.objFromEntries)((0, _objectUtils.objEntries)(frame).flatMap(pair => (0, _index.default)(pair, options).map(_ref => {
    let [key, value] = _ref;
    if (typeof value === 'string' || typeof value === 'number') {
      return [key, value];
    }
    return null;
  }).filter(Boolean)).filter(_ref2 => {
    let [_key, value] = _ref2;
    return value != null;
  }));
}
function constructKeyframesObj(frames) {
  return (0, _objectUtils.objEntries)(frames).map(_ref3 => {
    let [key, value] = _ref3;
    return `${key}{${(0, _objectUtils.objEntries)(value).map(_ref4 => {
      let [k, v] = _ref4;
      return `${k}:${v};`;
    }).join('')}}`;
  }).join('');
}

var stylexFirstThatWorks$1 = {};

Object.defineProperty(stylexFirstThatWorks$1, "__esModule", {
  value: true
});
stylexFirstThatWorks$1.default = stylexFirstThatWorks;
function stylexFirstThatWorks() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return [...args].reverse();
}

var fileBasedIdentifier = {};

Object.defineProperty(fileBasedIdentifier, "__esModule", {
  value: true
});
fileBasedIdentifier.default = genFileBasedIdentifier;
function genFileBasedIdentifier(_ref) {
  let {
    fileName,
    exportName,
    key
  } = _ref;
  return `${fileName}//${exportName}${key != null ? `.${key}` : ''}`;
}

var types$1 = {};

Object.defineProperty(types$1, "__esModule", {
  value: true
});
types$1.url = types$1.transformList = types$1.transformFunction = types$1.time = types$1.resolution = types$1.percentage = types$1.number = types$1.lengthPercentage = types$1.length = types$1.integer = types$1.image = types$1.color = types$1.angle = types$1.Url = types$1.TransformList = types$1.TransformFunction = types$1.Time = types$1.Resolution = types$1.Percentage = types$1.Num = types$1.LengthPercentage = types$1.Length = types$1.Integer = types$1.Image = types$1.Color = types$1.CSSType = types$1.Angle = void 0;
class CSSType {}
types$1.CSSType = CSSType;
class Angle extends CSSType {
  syntax = '<angle>';
  static syntax = '<angle>';
  constructor(value) {
    super();
    this.value = value;
  }
  static create(value) {
    return new Angle(value);
  }
}
types$1.Angle = Angle;
types$1.angle = Angle.create;
class Color extends CSSType {
  syntax = '<color>';
  constructor(value) {
    super();
    this.value = value;
  }
  static create(value) {
    return new Color(value);
  }
}
types$1.Color = Color;
types$1.color = Color.create;
class Url extends CSSType {
  syntax = '<url>';
  constructor(value) {
    super();
    this.value = value;
  }
  static create(value) {
    return new Url(value);
  }
}
types$1.Url = Url;
types$1.url = Url.create;
class Image extends Url {
  syntax = '<image>';
  constructor(value) {
    super(value);
    this.value = value;
  }
  static create(value) {
    return new Image(value);
  }
}
types$1.Image = Image;
types$1.image = Image.create;
class Integer extends CSSType {
  syntax = '<integer>';
  constructor(value) {
    super();
    this.value = value;
  }
  static create(value) {
    return new Integer(value);
  }
}
types$1.Integer = Integer;
types$1.integer = Integer.create;
class LengthPercentage extends CSSType {
  syntax = '<length-percentage>';
  constructor(value) {
    super();
    this.value = value;
  }
  static createLength(value) {
    return new LengthPercentage(convertNumberToLength(value));
  }
  static createPercentage(value) {
    return new LengthPercentage(convertNumberToPercentage(value));
  }
}
types$1.LengthPercentage = LengthPercentage;
types$1.lengthPercentage = LengthPercentage.createLength;
class Length extends LengthPercentage {
  syntax = '<length>';
  constructor(value) {
    super(convertNumberToLength(value));
  }
  static create(value) {
    return new Length(value);
  }
}
types$1.Length = Length;
types$1.length = Length.create;
class Percentage extends LengthPercentage {
  syntax = '<percentage>';
  constructor(value) {
    super(convertNumberToPercentage(value));
  }
  static create(value) {
    return new Percentage(value);
  }
}
types$1.Percentage = Percentage;
types$1.percentage = Percentage.create;
class Num extends CSSType {
  syntax = '<number>';
  constructor(value) {
    super();
    this.value = value;
  }
  static create(value) {
    return new Num(value);
  }
}
types$1.Num = Num;
types$1.number = Num.create;
class Resolution extends CSSType {
  syntax = '<resolution>';
  constructor(value) {
    super();
    this.value = value;
  }
  static create(value) {
    return new Resolution(value);
  }
}
types$1.Resolution = Resolution;
types$1.resolution = Resolution.create;
class Time extends CSSType {
  syntax = '<time>';
  constructor(value) {
    super();
    this.value = value;
  }
  static create(value) {
    return new Time(value);
  }
}
types$1.Time = Time;
types$1.time = Time.create;
class TransformFunction extends CSSType {
  syntax = '<transform-function>';
  constructor(value) {
    super();
    this.value = value;
  }
  static create(value) {
    return new TransformFunction(value);
  }
}
types$1.TransformFunction = TransformFunction;
types$1.transformFunction = TransformFunction.create;
class TransformList extends CSSType {
  syntax = '<transform-list>';
  constructor(value) {
    super();
    this.value = value;
  }
  static create(value) {
    return new TransformList(value);
  }
}
types$1.TransformList = TransformList;
types$1.transformList = TransformList.create;
const convertNumberToStringUsing = (transformNumber, defaultStr) => value => {
  if (typeof value === 'number') {
    return transformNumber(value);
  }
  if (typeof value === 'string') {
    return value;
  }
  if (typeof value === 'object') {
    const {
      default: defaultValue,
      ...rest
    } = value;
    const defaultResult = convertNumberToLength(defaultValue);
    const result = {
      default: typeof defaultResult === 'string' ? defaultResult : defaultStr
    };
    for (const [key, value] of Object.entries(rest)) {
      result[key] = convertNumberToLength(value);
    }
    return result;
  }
  return value;
};
const convertNumberToLength = convertNumberToStringUsing(value => value === 0 ? '0' : `${value}px`, '0px');
const convertNumberToPercentage = convertNumberToStringUsing(value => value === 0 ? '0' : `${value * 100}%`, '0');

var IncludedStyles_1;
var create_1;
var createTheme_1;
var defineVars_1;
var firstThatWorks_1;
var include_1;
var keyframes_1;
var messages_1;

Object.defineProperty(lib, "__esModule", {
  value: true
});
var utils_1 = lib.utils = lib.types = messages_1 = lib.messages = keyframes_1 = lib.keyframes = include_1 = lib.include = firstThatWorks_1 = lib.firstThatWorks = defineVars_1 = lib.defineVars = createTheme_1 = lib.createTheme = create_1 = lib.create = IncludedStyles_1 = lib.IncludedStyles = void 0;
var _stylexCreate = _interopRequireDefault(stylexCreate$1);
var _stylexDefineVars = _interopRequireDefault(stylexDefineVars$1);
var _stylexCreateTheme = _interopRequireDefault(stylexCreateTheme$1);
var _stylexKeyframes = _interopRequireDefault(stylexKeyframes);
var _stylexInclude = _interopRequireWildcard(stylexInclude$2);
var _stylexFirstThatWorks = _interopRequireDefault(stylexFirstThatWorks$1);
var _hash = _interopRequireDefault(hash$1);
var _fileBasedIdentifier = _interopRequireDefault(fileBasedIdentifier);
var m = _interopRequireWildcard(messages$3);
var _types = _interopRequireWildcard(types$1);
lib.types = _types;
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
create_1 = lib.create = _stylexCreate.default;
defineVars_1 = lib.defineVars = _stylexDefineVars.default;
createTheme_1 = lib.createTheme = _stylexCreateTheme.default;
keyframes_1 = lib.keyframes = _stylexKeyframes.default;
include_1 = lib.include = _stylexInclude.default;
utils_1 = lib.utils = {
  hash: _hash.default,
  genFileBasedIdentifier: _fileBasedIdentifier.default
};
messages_1 = lib.messages = m;
IncludedStyles_1 = lib.IncludedStyles = _stylexInclude.IncludedStyles;
firstThatWorks_1 = lib.firstThatWorks = _stylexFirstThatWorks.default;

function namespaceToDevClassName(namespace, varName, filename) {
  const basename = path.basename(filename).split('.')[0];
  const className = `${basename}__${varName ? `${varName}.` : ''}${namespace}`;
  return className.replace(/[^.a-zA-Z0-9_-]/g, '');
}
function injectDevClassNames(obj, varName, state) {
  const result = {};
  for (const [key, value] of Object.entries(obj)) {
    const devClassName = namespaceToDevClassName(key, varName, state.filename ?? 'UnknownFile');
    result[key] = {
      [devClassName]: devClassName,
      ...value
    };
  }
  return result;
}
function convertToTestStyles(obj, varName, state) {
  const result = {};
  for (const [key, _value] of Object.entries(obj)) {
    const devClassName = namespaceToDevClassName(key, varName, state.filename ?? 'UnknownFile');
    result[key] = {
      [devClassName]: devClassName,
      $$css: true
    };
  }
  return result;
}

function convertObjectToAST(obj) {
  return t__namespace.objectExpression(Object.entries(obj).map(_ref => {
    let [key, value] = _ref;
    return value instanceof IncludedStyles_1 ? t__namespace.spreadElement(value.astNode) : t__namespace.objectProperty(canBeIdentifier(key) ? t__namespace.identifier(key) : t__namespace.stringLiteral(key), typeof value === 'string' ? t__namespace.stringLiteral(value) : typeof value === 'number' ? t__namespace.numericLiteral(value) : typeof value === 'boolean' ? t__namespace.booleanLiteral(value) : value === null ? t__namespace.nullLiteral() : convertObjectToAST(value));
  }));
}
function canBeIdentifier(str) {
  return str.match(/^[a-zA-Z_$][a-zA-Z0-9_$]*$/) != null;
}

function isArrayExpression(path, props) {
  return path.isArrayExpression(props);
}
function isArrowFunctionExpression(path, props) {
  return path.isArrowFunctionExpression(props);
}
function isBinaryExpression(path, props) {
  return path.isBinaryExpression(props);
}
function isBooleanLiteral(path, props) {
  return path.isBooleanLiteral(props);
}
function isCallExpression(path, props) {
  return path.isCallExpression(props);
}
function isClass(path, props) {
  return path.isClass(props);
}
function isConditionalExpression(path, props) {
  return path.isConditionalExpression(props);
}
function isExportDefaultDeclaration(path, props) {
  return path.isExportDefaultDeclaration(props);
}
function isExportNamedDeclaration(path, props) {
  return path.isExportNamedDeclaration(props);
}
function isExpression(path, props) {
  return path.isExpression(props);
}
function isExpressionStatement(path, props) {
  return path.isExpressionStatement(props);
}
function isExpressionWrapper(path, props) {
  return path.isExpressionWrapper(props);
}
function isFunction(path, props) {
  return path.isFunction(props);
}
function isIdentifier(path, props) {
  return path.isIdentifier(props);
}
function isImportDeclaration(path, props) {
  return path.isImportDeclaration(props);
}
function isImportDefaultSpecifier(path, props) {
  return path.isImportDefaultSpecifier(props);
}
function isImportNamespaceSpecifier(path, props) {
  return path.isImportNamespaceSpecifier(props);
}
function isImportSpecifier(path, props) {
  return path.isImportSpecifier(props);
}
function isLogicalExpression(path, props) {
  return path.isLogicalExpression(props);
}
function isMemberExpression(path, props) {
  return path.isMemberExpression(props);
}
function isNullLiteral(path, props) {
  return path.isNullLiteral(props);
}
function isNumericLiteral(path, props) {
  return path.isNumericLiteral(props);
}
function isObjectExpression(path, props) {
  return path.isObjectExpression(props);
}
function isObjectMethod(path, props) {
  return path.isObjectMethod(props);
}
function isObjectProperty(path, props) {
  return path.isObjectProperty(props);
}
function isProgram(path, props) {
  return path.isProgram(props);
}
function isSequenceExpression(path, props) {
  return path.isSequenceExpression(props);
}
function isSpreadElement(path, props) {
  return path.isSpreadElement(props);
}
function isStatement(path, props) {
  return path.isStatement(props);
}
function isStringLiteral(path, props) {
  return path.isStringLiteral(props);
}
function isTSAsExpression(path, props) {
  return path.isTSAsExpression(props);
}
function isTaggedTemplateExpression(path, props) {
  return path.isTaggedTemplateExpression(props);
}
function isTemplateLiteral(path, props) {
  return path.isTemplateLiteral(props);
}
function isUnaryExpression(path, props) {
  return path.isUnaryExpression(props);
}
function isVariableDeclaration(path, props) {
  return path.isVariableDeclaration(props);
}
function isVariableDeclarator(path, props) {
  return path.isVariableDeclarator(props);
}
function isReferencedIdentifier(path, props) {
  return path.isReferencedIdentifier(props);
}

const VALID_CALLEES = ['String', 'Number', 'Math', 'Object', 'Array'];
const INVALID_METHODS = ['random', 'assign', 'defineProperties', 'defineProperty', 'freeze', 'seal', 'splice'];
function isValidCallee(val) {
  return VALID_CALLEES.includes(val);
}
function isInvalidMethod(val) {
  return INVALID_METHODS.includes(val);
}
function deopt(path, state) {
  if (!state.confident) return;
  state.deoptPath = path;
  state.confident = false;
}
function evaluateImportedFile(filePath, namedExport, state) {
  const fs = require('fs');
  const fileContents = fs.readFileSync(filePath, 'utf8');
  const ast = core.parseSync(fileContents, {
    babelrc: true
  });
  if (!ast || ast.errors || !t__namespace.isNode(ast)) {
    state.confident = false;
    return;
  }
  const astNode = ast;
  let result;
  traverse(astNode, {
    ExportNamedDeclaration(path) {
      const declaration = path.get('declaration');
      if (isVariableDeclaration(declaration)) {
        const decls = declaration.get('declarations');
        const finder = decl => {
          if (isVariableDeclarator(decl)) {
            const id = decl.get('id');
            const init = decl.get('init');
            if (isIdentifier(id) && id.node.name === namedExport && init != null && isExpression(init)) {
              result = evaluateCached(init, state);
            }
          }
        };
        if (Array.isArray(decls)) {
          decls.forEach(finder);
        } else {
          finder(decls);
        }
      }
    }
  });
  if (state.confident) {
    return result;
  } else {
    state.confident = false;
    return;
  }
}
function evaluateThemeRef(fileName, exportName, state) {
  const resolveKey = key => {
    const strToHash = key === '__themeName__' ? utils_1.genFileBasedIdentifier({
      fileName,
      exportName
    }) : utils_1.genFileBasedIdentifier({
      fileName,
      exportName,
      key
    });
    const varName = state.traversalState.options.classNamePrefix + utils_1.hash(strToHash);
    return `var(--${varName})`;
  };
  const proxy = new Proxy({}, {
    get(_, key) {
      return resolveKey(key);
    },
    set(_, key, value) {
      throw new Error(`Cannot set value ${value} to key ${key} in theme ${fileName}`);
    }
  });
  return proxy;
}
function evaluateCached(path, state) {
  const {
    node
  } = path;
  const {
    seen
  } = state;
  const existing = seen.get(node);
  if (existing != null) {
    if (existing.resolved) {
      return existing.value;
    } else {
      deopt(path, state);
      return;
    }
  } else {
    const item = {
      resolved: false
    };
    seen.set(node, item);
    const val = _evaluate(path, state);
    if (state.confident) {
      item.resolved = true;
      item.value = val;
    }
    return val;
  }
}
function _evaluate(path, state) {
  if (!state.confident) return;
  if (isArrowFunctionExpression(path)) {
    const body = path.get('body');
    const params = path.get('params');
    const identParams = params.filter(param => isIdentifier(param)).map(paramPath => paramPath.node.name);
    if (isExpression(body) && identParams.length === params.length) {
      const expr = body;
      return function () {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        const identifierEntries = identParams.map((ident, index) => [ident, args[index]]);
        const identifiersObj = Object.fromEntries(identifierEntries);
        const result = evaluate(expr, state.traversalState, {
          ...state.functions,
          identifiers: {
            ...state.functions.identifiers,
            ...identifiersObj
          }
        });
        return result.value;
      };
    }
  }
  if (isIdentifier(path)) {
    const name = path.node.name;
    if (Object.keys(state.functions?.identifiers ?? {}).includes(name)) {
      return state.functions.identifiers[name];
    }
  }
  if (isTSAsExpression(path)) {
    const expr = path.get('expression');
    return evaluateCached(expr, state);
  }
  if (path.node.type === 'TSSatisfiesExpression') {
    const expr = path.get('expression');
    return evaluateCached(expr, state);
  }
  if (isSequenceExpression(path)) {
    const exprs = path.get('expressions');
    return evaluateCached(exprs[exprs.length - 1], state);
  }
  if (isStringLiteral(path) || isNumericLiteral(path) || isBooleanLiteral(path)) {
    return path.node.value;
  }
  if (isNullLiteral(path)) {
    return null;
  }
  if (isTemplateLiteral(path)) {
    return evaluateQuasis(path, path.node.quasis, state);
  }
  const maybeTag = isTaggedTemplateExpression(path) && path.get('tag');
  if (isTaggedTemplateExpression(path) && maybeTag && isMemberExpression(maybeTag)) {
    const tag = maybeTag;
    const object = tag.get('object');
    if (isIdentifier(object)) {
      const name = object.node.name;
      const property = tag.get('property');
      if (name === 'String' && !path.scope.hasBinding(name) && isIdentifier(property) && property.node.name === 'raw') {
        return evaluateQuasis(path, path.node.quasi.quasis, state, true);
      }
    }
  }
  if (isConditionalExpression(path)) {
    const testResult = evaluateCached(path.get('test'), state);
    if (!state.confident) return;
    if (testResult) {
      return evaluateCached(path.get('consequent'), state);
    } else {
      return evaluateCached(path.get('alternate'), state);
    }
  }
  if (isExpressionWrapper(path)) {
    return evaluateCached(path.get('expression'), state);
  }
  if (isMemberExpression(path) && !isCallExpression(path.parentPath, {
    callee: path.node
  })) {
    const object = evaluateCached(path.get('object'), state);
    if (!state.confident) {
      return;
    }
    const propPath = path.get('property');
    let property;
    if (path.node.computed) {
      property = evaluateCached(propPath, state);
      if (!state.confident) {
        return;
      }
    } else if (isIdentifier(propPath)) {
      property = propPath.node.name;
    } else if (isStringLiteral(propPath)) {
      property = propPath.node.value;
    } else {
      return deopt(propPath, state);
    }
    return object[property];
  }
  if (isReferencedIdentifier(path)) {
    const binding = path.scope?.getBinding(path.node.name);
    const bindingPath = binding?.path;
    if (binding && bindingPath && !isImportDefaultSpecifier(bindingPath) && !isImportNamespaceSpecifier(bindingPath) && isImportSpecifier(bindingPath)) {
      const importSpecifierPath = bindingPath;
      const importSpecifierNode = importSpecifierPath.node;
      const imported = importSpecifierNode.imported;
      const importedName = imported.type === 'Identifier' ? imported.name : imported.value;
      const importPath = binding.path.parentPath;
      if (importPath && isImportDeclaration(importPath)) {
        const absPath = state.traversalState.importPathResolver(importPath.node.source.value);
        if (!absPath) {
          return deopt(binding.path, state);
        }
        const [type, value] = absPath;
        const returnValue = type === 'themeNameRef' ? evaluateThemeRef(value, importedName, state) : evaluateImportedFile(value, importedName, state);
        if (state.confident) {
          if (!state.addedImports.has(importPath.node.source.value) && state.traversalState.treeshakeCompensation) {
            importPath.insertBefore(t__namespace.importDeclaration([], importPath.node.source));
            state.addedImports.add(importPath.node.source.value);
          }
          return returnValue;
        } else {
          deopt(binding.path, state);
        }
      }
    }
    if (binding && binding.constantViolations.length > 0) {
      return deopt(binding.path, state);
    }
    if (binding && path.node.start < binding.path.node.end) {
      return deopt(binding.path, state);
    }
    if (binding && binding.hasValue) {
      return binding.value;
    } else {
      if (path.node.name === 'undefined') {
        return binding ? deopt(binding.path, state) : undefined;
      } else if (path.node.name === 'Infinity') {
        return binding ? deopt(binding.path, state) : Infinity;
      } else if (path.node.name === 'NaN') {
        return binding ? deopt(binding.path, state) : NaN;
      }
      const resolved = path.resolve();
      if (resolved === path) {
        return deopt(path, state);
      } else {
        return evaluateCached(resolved, state);
      }
    }
  }
  if (isUnaryExpression(path, {
    prefix: true
  })) {
    if (path.node.operator === 'void') {
      return undefined;
    }
    const argument = path.get('argument');
    if (path.node.operator === 'typeof' && (isFunction(argument) || isClass(argument))) {
      return 'function';
    }
    const arg = evaluateCached(argument, state);
    if (!state.confident) return;
    switch (path.node.operator) {
      case '!':
        return !arg;
      case '+':
        return +arg;
      case '-':
        return -arg;
      case '~':
        return ~arg;
      case 'typeof':
        return typeof arg;
      case 'void':
        return undefined;
      default:
        return deopt(path, state);
    }
  }
  if (isArrayExpression(path)) {
    const arrPath = path;
    const arr = [];
    const elems = arrPath.get('elements');
    for (const elem of elems) {
      const elemValue = evaluate(elem, state.traversalState, state.functions);
      if (elemValue.confident) {
        arr.push(elemValue.value);
      } else {
        elemValue.deopt && deopt(elemValue.deopt, state);
        return;
      }
    }
    return arr;
  }
  if (isObjectExpression(path)) {
    const obj = {};
    const props = path.get('properties');
    for (const prop of props) {
      if (isObjectMethod(prop)) {
        return deopt(prop, state);
      }
      if (isSpreadElement(prop)) {
        const spreadExpression = evaluateCached(prop.get('argument'), state);
        if (!state.confident) {
          return deopt(prop, state);
        }
        Object.assign(obj, spreadExpression);
        continue;
      }
      if (isObjectProperty(prop)) {
        const keyPath = prop.get('key');
        let key;
        if (prop.node.computed) {
          const {
            confident,
            deopt: resultDeopt,
            value
          } = evaluate(keyPath, state.traversalState, state.functions);
          if (!confident) {
            resultDeopt && deopt(resultDeopt, state);
            return;
          }
          key = value;
        } else if (isIdentifier(keyPath)) {
          key = keyPath.node.name;
        } else {
          key = keyPath.node.value;
        }
        const valuePath = prop.get('value');
        let value = evaluate(valuePath, state.traversalState, state.functions);
        if (!value.confident) {
          value.deopt && deopt(value.deopt, state);
          return;
        }
        value = value.value;
        obj[key] = value;
      }
    }
    return obj;
  }
  if (isLogicalExpression(path)) {
    const wasConfident = state.confident;
    const left = evaluateCached(path.get('left'), state);
    const leftConfident = state.confident;
    state.confident = wasConfident;
    const right = evaluateCached(path.get('right'), state);
    const rightConfident = state.confident;
    switch (path.node.operator) {
      case '||':
        state.confident = leftConfident && (!!left || rightConfident);
        if (!state.confident) return;
        return left || right;
      case '&&':
        state.confident = leftConfident && (!left || rightConfident);
        if (!state.confident) return;
        return left && right;
      case '??':
        state.confident = leftConfident && !!(left ?? rightConfident);
        if (!state.confident) return;
        return left ?? right;
      default:
        path.node.operator;
    }
  }
  if (isBinaryExpression(path)) {
    const left = evaluateCached(path.get('left'), state);
    if (!state.confident) return;
    const right = evaluateCached(path.get('right'), state);
    if (!state.confident) return;
    switch (path.node.operator) {
      case '-':
        return left - right;
      case '+':
        return left + right;
      case '/':
        return left / right;
      case '*':
        return left * right;
      case '%':
        return left % right;
      case '**':
        return left ** right;
      case '<':
        return left < right;
      case '>':
        return left > right;
      case '<=':
        return left <= right;
      case '>=':
        return left >= right;
      case '==':
        return left == right;
      case '!=':
        return left !== right;
      case '===':
        return left === right;
      case '!==':
        return left !== right;
      case '|':
        return left | right;
      case '&':
        return left & right;
      case '^':
        return left ^ right;
      case '<<':
        return left << right;
      case '>>':
        return left >> right;
      case '>>>':
        return left >>> right;
      case 'in':
        return left in right;
      case 'instanceof':
        return left instanceof right;
      default:
        return;
    }
  }
  if (isCallExpression(path)) {
    const callee = path.get('callee');
    let context;
    let func;
    if (isIdentifier(callee) && !path.scope.getBinding(callee.node.name) && isValidCallee(callee.node.name)) {
      func = global[callee.node.name];
    } else if (isIdentifier(callee) && state.functions.identifiers[callee.node.name]) {
      func = state.functions.identifiers[callee.node.name];
    }
    if (isMemberExpression(callee)) {
      const object = callee.get('object');
      const property = callee.get('property');
      if (isIdentifier(object) && isIdentifier(property)) {
        if (isValidCallee(object.node.name) && !isInvalidMethod(property.node.name)) {
          context = global[object.node.name];
          func = context[property.node.name];
        } else if (state.functions.memberExpressions[object.node.name] && state.functions.memberExpressions[object.node.name][property.node.name]) {
          context = state.functions.memberExpressions[object.node.name];
          func = context[property.node.name];
        }
      }
      if (isIdentifier(object) && isStringLiteral(property) && state.functions.memberExpressions[object.node.name] && state.functions.memberExpressions[object.node.name][property.node.value]) {
        context = state.functions.memberExpressions[object.node.name];
        func = context[property.node.value];
      }
      if ((isStringLiteral(object) || isNumericLiteral(object)) && isIdentifier(property)) {
        const val = object.node.value;
        func = val[property.node.name];
      }
      const parsedObj = evaluate(object, state.traversalState, state.functions);
      if (parsedObj.confident && isIdentifier(property)) {
        func = parsedObj.value[property.node.name];
        context = parsedObj.value;
      }
      if (parsedObj.confident && isStringLiteral(property)) {
        func = parsedObj.value[property.node.value];
        context = parsedObj.value;
      }
    }
    if (func) {
      if (func.takesPath) {
        const args = path.get('arguments');
        return func.fn(...args);
      } else {
        const args = path.get('arguments').map(arg => evaluateCached(arg, state));
        if (!state.confident) return;
        if (func.fn) {
          return func.fn.apply(context, args);
        } else {
          return func.apply(context, args);
        }
      }
    }
  }
  deopt(path, state);
}
function evaluateQuasis(path, quasis, state) {
  let raw = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  let str = '';
  let i = 0;
  const exprs = isTemplateLiteral(path) ? path.get('expressions') : isTaggedTemplateExpression(path) ? path.get('quasi').get('expressions') : [];
  for (const elem of quasis) {
    if (!state.confident) break;
    str += raw ? elem.value.raw : elem.value.cooked;
    const expr = exprs[i++];
    if (expr) str += String(evaluateCached(expr, state));
  }
  if (!state.confident) return;
  return str;
}
const importsForState = new WeakMap();
function evaluate(path, traversalState) {
  let functions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
    identifiers: {},
    memberExpressions: {}
  };
  const addedImports = importsForState.get(traversalState) ?? new Set();
  importsForState.set(traversalState, addedImports);
  const state = {
    confident: true,
    deoptPath: null,
    seen: new Map(),
    addedImports,
    functions,
    traversalState
  };
  let value = evaluateCached(path, state);
  if (!state.confident) value = undefined;
  return {
    confident: state.confident,
    deopt: state.deoptPath,
    value: value
  };
}

function evaluateStyleXCreateArg(path, traversalState) {
  let functions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
    identifiers: {},
    memberExpressions: {}
  };
  if (!isObjectExpression(path)) {
    return evaluate(path, traversalState, functions);
  }
  const value = {};
  const fns = {};
  for (const prop of path.get('properties')) {
    if (!isObjectProperty(prop)) {
      return evaluate(path, traversalState, functions);
    }
    const objPropPath = prop;
    const keyResult = evaluateObjKey(objPropPath, traversalState, functions);
    if (!keyResult.confident) {
      return {
        confident: false,
        deopt: keyResult.deopt,
        value: null
      };
    }
    const key = keyResult.value;
    const valPath = prop.get('value');
    if (!isArrowFunctionExpression(valPath)) {
      const val = evaluate(valPath, traversalState, functions);
      if (!val.confident) {
        return val;
      }
      value[key] = val.value;
      continue;
    }
    const fnPath = valPath;
    const allParams = fnPath.get('params');
    validateDynamicStyleParams(allParams);
    const params = allParams.filter(param => isIdentifier(param)).map(param => param.node);
    const fnBody = fnPath.get('body');
    if (!isObjectExpression(fnBody)) {
      return evaluate(path, traversalState, functions);
    }
    const fnObjectBody = fnBody;
    const evalResult = evaluatePartialObjectRecursively(fnObjectBody, traversalState, functions);
    if (!evalResult.confident) {
      const {
        confident,
        value: v,
        deopt
      } = evalResult;
      return {
        confident,
        value: v,
        deopt
      };
    }
    const {
      value: v,
      inlineStyles
    } = evalResult;
    value[key] = v;
    fns[key] = [params, inlineStyles ?? {}];
  }
  return {
    value,
    confident: true,
    fns
  };
}
function evaluatePartialObjectRecursively(path, traversalState) {
  let functions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
    identifiers: {},
    memberExpressions: {}
  };
  let keyPath = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
  const obj = {};
  const inlineStyles = {};
  const props = path.get('properties');
  for (const prop of props) {
    if (isObjectMethod(prop)) {
      return {
        value: null,
        confident: false
      };
    }
    if (isSpreadElement(prop)) {
      const result = evaluate(prop.get('argument'), traversalState, functions);
      if (!result.confident) {
        return result;
      }
      Object.assign(obj, result.value);
      continue;
    }
    if (isObjectProperty(prop)) {
      const keyResult = evaluateObjKey(prop, traversalState, functions);
      if (!keyResult.confident) {
        return {
          confident: false,
          deopt: keyResult.deopt,
          value: null
        };
      }
      const key = keyResult.value;
      const valuePath = prop.get('value');
      if (isObjectExpression(valuePath)) {
        const result = evaluatePartialObjectRecursively(valuePath, traversalState, functions, [...keyPath, key]);
        if (!result.confident) {
          return {
            confident: false,
            deopt: result.deopt,
            value: null
          };
        }
        obj[key] = result.value;
        Object.assign(inlineStyles, result.inlineStyles);
      } else {
        const result = evaluate(valuePath, traversalState, functions);
        if (!result.confident) {
          const varName = '--' + (keyPath.length > 0 ? utils_1.hash([...keyPath, key].join('_')) : key);
          obj[key] = `var(${varName}, revert)`;
          const node = valuePath.node;
          if (!t__namespace.isExpression(node)) {
            throw new Error('Expected expression as style value');
          }
          const expression = node;
          const unit = timeUnits_1.has(key) || lengthUnits_1.has(key) ? getNumberSuffix_1(key) : '';
          inlineStyles[varName] = unit !== '' ? t__namespace.callExpression(t__namespace.arrowFunctionExpression([t__namespace.identifier('val')], t__namespace.conditionalExpression(t__namespace.binaryExpression('===', t__namespace.unaryExpression('typeof', t__namespace.identifier('val')), t__namespace.stringLiteral('number')), t__namespace.binaryExpression('+', t__namespace.identifier('val'), t__namespace.stringLiteral(unit)), t__namespace.conditionalExpression(t__namespace.binaryExpression('!=', t__namespace.identifier('val'), t__namespace.nullLiteral()), t__namespace.identifier('val'), t__namespace.stringLiteral('initial')))), [expression]) : t__namespace.conditionalExpression(t__namespace.binaryExpression('!=', expression, t__namespace.nullLiteral()), expression, t__namespace.stringLiteral('initial'));
        } else {
          obj[key] = result.value;
        }
      }
    }
  }
  return {
    value: obj,
    confident: true,
    inlineStyles
  };
}
function evaluateObjKey(prop, traversalState, functions) {
  const keyPath = prop.get('key');
  let key;
  if (prop.node.computed) {
    const result = evaluate(keyPath, traversalState, functions);
    if (!result.confident) {
      return {
        confident: false,
        deopt: result.deopt
      };
    }
    key = result.value;
  } else if (isIdentifier(keyPath)) {
    key = keyPath.node.name;
  } else {
    key = keyPath.node.value;
  }
  return {
    confident: true,
    value: String(key)
  };
}
function validateDynamicStyleParams(params) {
  if (params.some(param => !isIdentifier(param))) {
    throw new Error(messages_1.ONLY_NAMED_PARAMETERS_IN_DYNAMIC_STYLE_FUNCTIONS);
  }
}

function transformStyleXCreate(path, state) {
  const {
    node
  } = path;
  if (node.type !== 'CallExpression') {
    return;
  }
  if (node.callee.type === 'Identifier' && state.stylexCreateImport.has(node.callee.name) || node.callee.type === 'MemberExpression' && node.callee.object.type === 'Identifier' && node.callee.property.type === 'Identifier' && node.callee.property.name === 'create' && state.stylexImport.has(node.callee.object.name)) {
    validateStyleXCreate(path);
    const args = path.get('arguments');
    const firstArg = args[0];
    state.inStyleXCreate = true;
    const injectedKeyframes = {};
    function keyframes(animation) {
      const [animationName, injectedStyle] = keyframes_1(animation, state.options);
      injectedKeyframes[animationName] = injectedStyle;
      return animationName;
    }
    const identifiers = {};
    const memberExpressions = {};
    state.stylexIncludeImport.forEach(name => {
      identifiers[name] = {
        fn: include_1,
        takesPath: true
      };
    });
    state.stylexFirstThatWorksImport.forEach(name => {
      identifiers[name] = {
        fn: firstThatWorks_1
      };
    });
    state.stylexKeyframesImport.forEach(name => {
      identifiers[name] = {
        fn: keyframes
      };
    });
    state.stylexImport.forEach(name => {
      if (memberExpressions[name] == null) {
        memberExpressions[name] = {};
      }
      memberExpressions[name].include = {
        fn: include_1,
        takesPath: true
      };
      memberExpressions[name].firstThatWorks = {
        fn: firstThatWorks_1
      };
      memberExpressions[name].keyframes = {
        fn: keyframes
      };
    });
    const {
      confident,
      value,
      fns
    } = evaluateStyleXCreateArg(firstArg, state, {
      identifiers,
      memberExpressions
    });
    if (!confident) {
      throw new Error(messages_1.NON_STATIC_VALUE);
    }
    const plainObject = value;
    let [compiledStyles, injectedStylesSansKeyframes] = create_1(plainObject, state.options);
    const injectedStyles = {
      ...injectedKeyframes,
      ...injectedStylesSansKeyframes
    };
    let varName = null;
    if (isVariableDeclarator(path.parentPath)) {
      const idNode = path.parentPath.node.id;
      if (idNode.type === 'Identifier') {
        varName = idNode.name;
      }
    }
    if (state.isTest) {
      compiledStyles = {
        ...convertToTestStyles(compiledStyles, varName, state)
      };
    } else if (state.isDev) {
      compiledStyles = {
        ...injectDevClassNames(compiledStyles, varName, state)
      };
    }
    if (varName != null) {
      state.styleMap.set(varName, compiledStyles);
      state.styleVars.set(varName, path.parentPath);
    }
    const resultAst = convertObjectToAST(compiledStyles);
    if (fns != null) {
      resultAst.properties = resultAst.properties.map(prop => {
        if (t__namespace.isObjectProperty(prop)) {
          const key = prop.key.type === 'Identifier' && !prop.computed ? prop.key.name : prop.key.type === 'StringLiteral' ? prop.key.value : null;
          if (key != null && Object.keys(fns).includes(key)) {
            const [params, inlineStyles] = fns[key];
            if (t__namespace.isExpression(prop.value)) {
              const value = prop.value;
              prop.value = t__namespace.arrowFunctionExpression(params, t__namespace.arrayExpression([value, t__namespace.objectExpression(Object.entries(inlineStyles).map(_ref => {
                let [key, value] = _ref;
                return t__namespace.objectProperty(t__namespace.stringLiteral(key), value);
              }))]));
            }
          }
        }
        return prop;
      });
    }
    path.replaceWith(resultAst);
    if (Object.keys(injectedStyles).length === 0) {
      return;
    }
    const statementPath = path.getStatementParent();
    if (state.runtimeInjection != null && statementPath != null) {
      let injectName;
      if (state.injectImportInserted != null) {
        injectName = state.injectImportInserted;
      } else {
        const {
          from,
          as
        } = state.runtimeInjection;
        injectName = as != null ? helperModuleImports.addNamed(statementPath, as, from, {
          nameHint: 'inject'
        }) : helperModuleImports.addDefault(statementPath, from, {
          nameHint: 'inject'
        });
        state.injectImportInserted = injectName;
      }
      for (const [_key, {
        ltr,
        priority,
        rtl
      }] of Object.entries(injectedStyles)) {
        statementPath.insertBefore(t__namespace.expressionStatement(t__namespace.callExpression(injectName, [t__namespace.stringLiteral(ltr), t__namespace.numericLiteral(priority), ...(rtl != null ? [t__namespace.stringLiteral(rtl)] : [])])));
      }
    }
    for (const [key, {
      priority,
      ...rest
    }] of Object.entries(injectedStyles)) {
      state.addStyle([key, rest, priority]);
    }
  }
  state.inStyleXCreate = false;
}
function validateStyleXCreate(path) {
  if (path.parentPath == null || isExpressionStatement(path.parentPath)) {
    throw new Error(messages_1.UNBOUND_STYLEX_CALL_VALUE);
  }
  const nearestStatement = findNearestStatementAncestor(path);
  if (!isProgram(nearestStatement.parentPath) && !isExportNamedDeclaration(nearestStatement.parentPath)) {
    throw new Error(messages_1.ONLY_TOP_LEVEL);
  }
  if (path.node.arguments.length !== 1) {
    throw new Error(messages_1.ILLEGAL_ARGUMENT_LENGTH);
  }
  if (path.node.arguments[0].type !== 'ObjectExpression') {
    throw new Error(messages_1.NON_OBJECT_FOR_STYLEX_CALL);
  }
}
function findNearestStatementAncestor(path) {
  if (isStatement(path)) {
    return path;
  }
  if (path.parentPath == null) {
    throw new Error('Unexpected Path found that is not part of the AST.');
  }
  return findNearestStatementAncestor(path.parentPath);
}

function transformStyleXDefineVars(callExpressionPath, state) {
  const callExpressionNode = callExpressionPath.node;
  if (callExpressionNode.type !== 'CallExpression') {
    return;
  }
  if (callExpressionNode.callee.type === 'Identifier' && state.stylexDefineVarsImport.has(callExpressionNode.callee.name) || callExpressionNode.callee.type === 'MemberExpression' && callExpressionNode.callee.property.name === 'defineVars' && callExpressionNode.callee.object.type === 'Identifier' && callExpressionNode.callee.property.type === 'Identifier' && state.stylexImport.has(callExpressionNode.callee.object.name)) {
    validateStyleXDefineVars(callExpressionPath);
    const variableDeclaratorPath = callExpressionPath.parentPath;
    if (!isVariableDeclarator(variableDeclaratorPath)) {
      return;
    }
    const variableDeclaratorNode = variableDeclaratorPath.node;
    if (variableDeclaratorNode.id.type !== 'Identifier') {
      return;
    }
    const varId = variableDeclaratorNode.id;
    const args = callExpressionPath.get('arguments');
    const firstArg = args[0];
    const identifiers = {};
    const memberExpressions = {};
    const {
      confident,
      value
    } = evaluate(firstArg, state, {
      identifiers,
      memberExpressions
    });
    if (!confident) {
      throw new Error(messages_1.NON_STATIC_VALUE);
    }
    if (typeof value !== 'object' || value == null) {
      throw new Error(messages_1.NON_OBJECT_FOR_STYLEX_CALL);
    }
    const fileName = state.fileNameForHashing;
    if (fileName == null) {
      throw new Error('No filename found for generating theme name.');
    }
    const exportName = varId.name;
    const [variablesObj, injectedStyles] = defineVars_1(value, {
      ...state.options,
      themeName: utils_1.genFileBasedIdentifier({
        fileName,
        exportName
      })
    });
    callExpressionPath.replaceWith(convertObjectToAST(variablesObj));
    const statementPath = variableDeclaratorPath.parentPath.parentPath;
    if (Object.keys(injectedStyles).length === 0) {
      return;
    }
    if (state.runtimeInjection != null && statementPath != null) {
      let injectName;
      if (state.injectImportInserted != null) {
        injectName = state.injectImportInserted;
      } else {
        const {
          from,
          as
        } = state.runtimeInjection;
        injectName = as != null ? helperModuleImports.addNamed(statementPath, as, from, {
          nameHint: 'inject'
        }) : helperModuleImports.addDefault(statementPath, from, {
          nameHint: 'inject'
        });
        state.injectImportInserted = injectName;
      }
      for (const [_k, {
        ltr,
        priority
      }] of Object.entries(injectedStyles)) {
        statementPath.insertBefore(t__namespace.expressionStatement(t__namespace.callExpression(injectName, [t__namespace.stringLiteral(ltr), t__namespace.numericLiteral(priority)])));
      }
    }
    for (const [key, {
      priority,
      ltr
    }] of Object.entries(injectedStyles)) {
      state.addStyle([key, {
        ltr
      }, priority]);
    }
  }
}
function validateStyleXDefineVars(callExpressionPath) {
  const variableDeclaratorPath = callExpressionPath.parentPath;
  const exportNamedDeclarationPath = variableDeclaratorPath.parentPath?.parentPath;
  if (variableDeclaratorPath == null || variableDeclaratorPath.isExpressionStatement() || !variableDeclaratorPath.isVariableDeclarator() || variableDeclaratorPath.node.id.type !== 'Identifier') {
    throw new Error(messages_1.UNBOUND_STYLEX_CALL_VALUE);
  }
  if (exportNamedDeclarationPath == null || !exportNamedDeclarationPath.isExportNamedDeclaration()) {
    throw new Error(messages_1.NON_EXPORT_NAMED_DECLARATION);
  }
  if (callExpressionPath.node.arguments.length !== 1) {
    throw new Error(messages_1.ILLEGAL_ARGUMENT_LENGTH);
  }
}

function transformStyleXCreateTheme(callExpressionPath, state) {
  const callExpressionNode = callExpressionPath.node;
  if (callExpressionNode.type !== 'CallExpression') {
    return;
  }
  if (callExpressionNode.callee.type === 'Identifier' && state.stylexCreateThemeImport.has(callExpressionNode.callee.name) || callExpressionNode.callee.type === 'MemberExpression' && callExpressionNode.callee.object.type === 'Identifier' && callExpressionNode.callee.property.type === 'Identifier' && callExpressionNode.callee.property.name === 'createTheme' && state.stylexImport.has(callExpressionNode.callee.object.name)) {
    validateStyleXCreateTheme(callExpressionPath);
    const variableDeclaratorPath = callExpressionPath.parentPath;
    if (!isVariableDeclarator(variableDeclaratorPath)) {
      return;
    }
    const varNamePath = variableDeclaratorPath.get('id');
    let varName = 'UnknownVar';
    if (varNamePath.isIdentifier()) {
      varName = varNamePath.node.name;
    }
    const fileName = state.fileNameForHashing ?? 'UnknownFile';
    const debugName = `${fileName}__${varName}`;
    const args = callExpressionPath.get('arguments');
    const firstArg = args[0];
    const secondArg = args[1];
    const {
      confident: confident1,
      value: variables
    } = evaluate(firstArg, state);
    if (!confident1) {
      throw new Error(messages_1.NON_STATIC_VALUE);
    }
    const {
      confident: confident2,
      value: overrides
    } = evaluate(secondArg, state);
    if (!confident2) {
      throw new Error(messages_1.NON_STATIC_VALUE);
    }
    if (typeof overrides !== 'object' || overrides == null) {
      throw new Error(messages_1.NON_OBJECT_FOR_STYLEX_CALL);
    }
    if (typeof variables.__themeName__ !== 'string' || variables.__themeName__ === '') {
      throw new Error('Can only override variables theme created with stylex.defineVars().');
    }
    let [overridesObj, injectedStyles] = createTheme_1(variables, overrides, state.options);
    if (state.isDev) {
      overridesObj = {
        ...overridesObj,
        [debugName]: debugName
      };
    }
    callExpressionPath.replaceWith(convertObjectToAST(overridesObj));
    const statementPath = variableDeclaratorPath.parentPath;
    if (Object.keys(injectedStyles).length === 0) {
      return;
    }
    if (state.runtimeInjection != null && statementPath != null) {
      let injectName;
      if (state.injectImportInserted != null) {
        injectName = state.injectImportInserted;
      } else {
        const {
          from,
          as
        } = state.runtimeInjection;
        injectName = as != null ? helperModuleImports.addNamed(statementPath, as, from, {
          nameHint: 'inject'
        }) : helperModuleImports.addDefault(statementPath, from, {
          nameHint: 'inject'
        });
        state.injectImportInserted = injectName;
      }
      for (const [_k, {
        ltr,
        priority
      }] of Object.entries(injectedStyles)) {
        statementPath.insertBefore(t__namespace.expressionStatement(t__namespace.callExpression(injectName, [t__namespace.stringLiteral(ltr), t__namespace.numericLiteral(priority)])));
      }
    }
    for (const [key, {
      priority,
      ltr
    }] of Object.entries(injectedStyles)) {
      state.addStyle([key, {
        ltr
      }, priority]);
    }
  }
}
function validateStyleXCreateTheme(callExpressionPath) {
  const variableDeclaratorPath = callExpressionPath.parentPath;
  if (variableDeclaratorPath == null || variableDeclaratorPath.isExpressionStatement() || !variableDeclaratorPath.isVariableDeclarator() || variableDeclaratorPath.node.id.type !== 'Identifier') {
    throw new Error(messages_1.UNBOUND_STYLEX_CALL_VALUE);
  }
  if (callExpressionPath.node.arguments.length !== 2) {
    throw new Error(messages_1.ILLEGAL_ARGUMENT_LENGTH);
  }
}

function transformStyleXKeyframes(path, state) {
  const {
    node
  } = path;
  if (node.init?.type !== 'CallExpression') {
    return;
  }
  if (node.id.type !== 'Identifier') {
    return;
  }
  const nodeInit = node.init;
  if (nodeInit.callee.type === 'Identifier' && state.stylexKeyframesImport.has(nodeInit.callee.name) || nodeInit.callee.type === 'MemberExpression' && nodeInit.callee.object.type === 'Identifier' && nodeInit.callee.property.name === 'keyframes' && nodeInit.callee.property.type === 'Identifier' && state.stylexImport.has(nodeInit.callee.object.name)) {
    if (nodeInit.arguments.length !== 1) {
      throw new Error(messages_1.ILLEGAL_ARGUMENT_LENGTH);
    }
    if (nodeInit.arguments[0].type !== 'ObjectExpression') {
      throw new Error(messages_1.NON_OBJECT_FOR_STYLEX_KEYFRAMES_CALL);
    }
    const init = path.get('init');
    if (init == null || !isCallExpression(init)) {
      throw new Error(messages_1.NON_STATIC_KEYFRAME_VALUE);
    }
    const args = init.get('arguments');
    const firstArg = args[0];
    const identifiers = {};
    const memberExpressions = {};
    state.stylexFirstThatWorksImport.forEach(name => {
      identifiers[name] = {
        fn: firstThatWorks_1
      };
    });
    state.stylexImport.forEach(name => {
      if (memberExpressions[name] == null) {
        memberExpressions[name] = {};
      }
      memberExpressions[name].firstThatWorks = {
        fn: firstThatWorks_1
      };
    });
    const {
      confident,
      value
    } = evaluate(firstArg, state, {
      identifiers,
      memberExpressions
    });
    if (!confident) {
      throw new Error(messages_1.NON_STATIC_VALUE);
    }
    const plainObject = value;
    assertValidKeyframes(plainObject);
    const [animationName, injectedStyle] = keyframes_1(plainObject, state.options);
    init.replaceWith(t__namespace.stringLiteral(animationName));
    const {
      ltr,
      priority,
      rtl
    } = injectedStyle;
    const statementPath = path.getStatementParent();
    if (statementPath != null && state.runtimeInjection != null) {
      let injectName;
      if (state.injectImportInserted != null) {
        injectName = state.injectImportInserted;
      } else {
        const {
          from,
          as
        } = state.runtimeInjection;
        injectName = as != null ? helperModuleImports.addNamed(statementPath, as, from, {
          nameHint: 'inject'
        }) : helperModuleImports.addDefault(statementPath, from, {
          nameHint: 'inject'
        });
        state.injectImportInserted = injectName;
      }
      statementPath.insertBefore(t__namespace.expressionStatement(t__namespace.callExpression(injectName, [t__namespace.stringLiteral(ltr), t__namespace.numericLiteral(priority), ...(rtl != null ? [t__namespace.stringLiteral(rtl)] : [])])));
    }
    state.addStyle([animationName, {
      ltr,
      rtl
    }, priority]);
  }
}
function assertValidKeyframes(obj) {
  if (typeof obj !== 'object' || Array.isArray(obj) || obj == null) {
    throw new Error(messages_1.NON_OBJECT_FOR_STYLEX_KEYFRAMES_CALL);
  }
  for (const [_key, value] of Object.entries(obj)) {
    if (typeof value !== 'object' || Array.isArray(value)) {
      throw new Error(messages_1.NON_OBJECT_KEYFRAME);
    }
  }
}

var stylex = {};

var default_1;

Object.defineProperty(stylex, "__esModule", {
  value: true
});
stylex.__monkey_patch__ = __monkey_patch__;
stylex.keyframes = stylex.include = stylex.firstThatWorks = stylex.defineVars = default_1 = stylex.default = stylex.createTheme = stylex.create = void 0;
var props_1 = stylex.props = props;
stylex.types = stylex.stylex = void 0;
var _styleq = require$$0$1;
function props() {
  const options = this;
  for (var _len = arguments.length, styles = new Array(_len), _key = 0; _key < _len; _key++) {
    styles[_key] = arguments[_key];
  }
  if (__implementations.props) {
    return __implementations.props.call(options, styles);
  }
  const [className, style] = (0, _styleq.styleq)(styles);
  const result = {};
  if (className != null && className !== '') {
    result.className = className;
  }
  if (style != null && Object.keys(style).length > 0) {
    result.style = style;
  }
  return result;
}
function stylexCreate(styles) {
  if (__implementations.create != null) {
    const create = __implementations.create;
    return create(styles);
  }
  throw new Error('stylex.create should never be called. It should be compiled away.');
}
function stylexDefineVars(styles) {
  if (__implementations.defineVars) {
    return __implementations.defineVars(styles);
  }
  throw new Error('stylex.defineVars should never be called. It should be compiled away.');
}
const stylexCreateTheme = (baseTokens, overrides) => {
  if (__implementations.createTheme) {
    return __implementations.createTheme(baseTokens, overrides);
  }
  throw new Error('stylex.createTheme should never be called. It should be compiled away.');
};
const stylexInclude = styles => {
  if (__implementations.include) {
    return __implementations.include(styles);
  }
  throw new Error('stylex.extends should never be called. It should be compiled away.');
};
const create = stylex.create = stylexCreate;
const defineVars = stylex.defineVars = stylexDefineVars;
const createTheme = stylex.createTheme = stylexCreateTheme;
const include = stylex.include = stylexInclude;
const types = stylex.types = {
  angle: _v => {
    throw new Error(errorForType('angle'));
  },
  color: _v => {
    throw new Error(errorForType('color'));
  },
  url: _v => {
    throw new Error(errorForType('url'));
  },
  image: _v => {
    throw new Error(errorForType('image'));
  },
  integer: _v => {
    throw new Error(errorForType('integer'));
  },
  lengthPercentage: _v => {
    throw new Error(errorForType('lengthPercentage'));
  },
  length: _v => {
    throw new Error(errorForType('length'));
  },
  percentage: _v => {
    throw new Error(errorForType('percentage'));
  },
  number: _v => {
    throw new Error(errorForType('number'));
  },
  resolution: _v => {
    throw new Error(errorForType('resolution'));
  },
  time: _v => {
    throw new Error(errorForType('time'));
  },
  transformFunction: _v => {
    throw new Error(errorForType('transformFunction'));
  },
  transformList: _v => {
    throw new Error(errorForType('transformList'));
  }
};
const errorForType = type => `stylex.types.${type} should be compiled away by @stylexjs/babel-plugin`;
const keyframes = keyframes => {
  if (__implementations.keyframes) {
    return __implementations.keyframes(keyframes);
  }
  throw new Error('stylex.keyframes should never be called');
};
stylex.keyframes = keyframes;
const firstThatWorks = function () {
  if (__implementations.firstThatWorks) {
    return __implementations.firstThatWorks(...arguments);
  }
  throw new Error('stylex.firstThatWorks should never be called.');
};
stylex.firstThatWorks = firstThatWorks;
function _stylex() {
  for (var _len2 = arguments.length, styles = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    styles[_key2] = arguments[_key2];
  }
  const [className] = (0, _styleq.styleq)(styles);
  return className;
}
_stylex.props = props;
_stylex.create = create;
_stylex.defineVars = defineVars;
_stylex.createTheme = createTheme;
_stylex.include = include;
_stylex.keyframes = keyframes;
_stylex.firstThatWorks = firstThatWorks;
_stylex.types = types;
const __implementations = {};
function __monkey_patch__(key, implementation) {
  if (key === 'types') {
    Object.assign(types, implementation);
  } else {
    __implementations[key] = implementation;
  }
}
stylex.stylex = _stylex;
default_1 = stylex.default = _stylex;

function skipStylexMergeChildren(path, state) {
  const {
    node
  } = path;
  if (node == null || node.callee.type !== 'Identifier' || !state.stylexImport.has(node.callee.name)) {
    return;
  }
  path.skip();
}
function transformStyleXMerge(path, state) {
  const {
    node
  } = path;
  if (node == null || node.callee.type !== 'Identifier' || !state.stylexImport.has(node.callee.name)) {
    return;
  }
  let bailOut = false;
  let conditional = 0;
  let currentIndex = -1;
  let bailOutIndex = null;
  const resolvedArgs = [];
  for (const arg of node.arguments) {
    currentIndex++;
    switch (arg.type) {
      case 'MemberExpression':
        {
          const resolved = parseNullableStyle$1(arg, state);
          if (resolved === 'other') {
            bailOutIndex = currentIndex;
            bailOut = true;
          } else {
            resolvedArgs.push(resolved);
          }
          break;
        }
      case 'ConditionalExpression':
        {
          const {
            test,
            consequent,
            alternate
          } = arg;
          const primary = parseNullableStyle$1(consequent, state);
          const fallback = parseNullableStyle$1(alternate, state);
          if (primary === 'other' || fallback === 'other') {
            bailOutIndex = currentIndex;
            bailOut = true;
          } else {
            resolvedArgs.push([test, primary, fallback]);
            conditional++;
          }
          break;
        }
      case 'LogicalExpression':
        {
          if (arg.operator !== '&&') {
            bailOutIndex = currentIndex;
            bailOut = true;
            break;
          }
          const {
            left,
            right
          } = arg;
          const leftResolved = parseNullableStyle$1(left, state);
          const rightResolved = parseNullableStyle$1(right, state);
          if (leftResolved !== 'other' || rightResolved === 'other') {
            bailOutIndex = currentIndex;
            bailOut = true;
          } else {
            resolvedArgs.push([left, rightResolved, null]);
            conditional++;
          }
          break;
        }
      default:
        bailOutIndex = currentIndex;
        bailOut = true;
        break;
    }
    if (conditional > 4) {
      bailOut = true;
    }
    if (bailOut) {
      break;
    }
  }
  if (!state.options.genConditionalClasses && conditional) {
    bailOut = true;
  }
  if (bailOut) {
    const argumentPaths = path.get('arguments');
    let nonNullProps = [];
    let index = -1;
    for (const argPath of argumentPaths) {
      index++;
      function MemberExpression(path) {
        const object = path.get('object').node;
        const property = path.get('property').node;
        const computed = path.node.computed;
        let objName = null;
        let propName = null;
        if (object.type === 'Identifier' && state.styleMap.has(object.name)) {
          objName = object.name;
          if (property.type === 'Identifier' && !computed) {
            propName = property.name;
          }
          if ((property.type === 'StringLiteral' || property.type === 'NumericLiteral') && computed) {
            propName = property.value;
          }
        }
        let styleNonNullProps = [];
        if (bailOutIndex != null && index > bailOutIndex) {
          nonNullProps = true;
          styleNonNullProps = true;
        }
        if (nonNullProps === true) {
          styleNonNullProps = true;
        } else {
          const {
            confident,
            value: styleValue
          } = evaluate(path, state);
          if (!confident) {
            nonNullProps = true;
            styleNonNullProps = true;
          } else {
            styleNonNullProps = nonNullProps === true ? true : [...nonNullProps];
            if (nonNullProps !== true) {
              nonNullProps = [...nonNullProps, ...Object.keys(styleValue).filter(key => styleValue[key] !== null)];
            }
          }
        }
        if (objName != null) {
          state.styleVarsToKeep.add([objName, propName != null ? String(propName) : true, styleNonNullProps]);
        }
      }
      if (isMemberExpression(argPath)) {
        MemberExpression(argPath);
      } else {
        argPath.traverse({
          MemberExpression
        });
      }
    }
  } else {
    path.skip();
    const stringExpression = makeStringExpression$1(resolvedArgs);
    path.replaceWith(stringExpression);
  }
}
function parseNullableStyle$1(node, state) {
  if (t__namespace.isNullLiteral(node) || t__namespace.isIdentifier(node) && node.name === 'undefined') {
    return null;
  }
  if (t__namespace.isMemberExpression(node)) {
    const {
      object,
      property,
      computed: computed
    } = node;
    let objName = null;
    let propName = null;
    if (object.type === 'Identifier' && state.styleMap.has(object.name) && property.type === 'Identifier' && !computed) {
      objName = object.name;
      propName = property.name;
    }
    if (object.type === 'Identifier' && state.styleMap.has(object.name) && (property.type === 'StringLiteral' || property.type === 'NumericLiteral') && computed) {
      objName = object.name;
      propName = property.value;
    }
    if (objName != null && propName != null) {
      const style = state.styleMap.get(objName);
      if (style != null && style[String(propName)] != null) {
        return style[String(propName)];
      }
    }
  }
  return 'other';
}
function makeStringExpression$1(values) {
  const conditions = values.filter(v => Array.isArray(v)).map(v => v[0]);
  if (conditions.length === 0) {
    return t__namespace.stringLiteral(default_1(...values));
  }
  const conditionPermutations = genConditionPermutations$1(conditions.length);
  const objEntries = conditionPermutations.map(permutation => {
    let i = 0;
    const args = values.map(v => {
      if (Array.isArray(v)) {
        const [_test, primary, fallback] = v;
        return permutation[i++] ? primary : fallback;
      } else {
        return v;
      }
    });
    const key = permutation.reduce((soFar, bool) => soFar << 1 | (bool ? 1 : 0), 0);
    return t__namespace.objectProperty(t__namespace.numericLiteral(key), t__namespace.stringLiteral(default_1(...args)));
  });
  const objExpressions = t__namespace.objectExpression(objEntries);
  const conditionsToKey = genBitwiseOrOfConditions$1(conditions);
  return t__namespace.memberExpression(objExpressions, conditionsToKey, true);
}
function genConditionPermutations$1(count) {
  const result = [];
  for (let i = 0; i < 2 ** count; i++) {
    const combination = [];
    for (let j = 0; j < count; j++) {
      combination.push(Boolean(i & 1 << j));
    }
    result.push(combination);
  }
  return result;
}
function genBitwiseOrOfConditions$1(conditions) {
  const binaryExpressions = conditions.map((condition, i) => {
    const shift = conditions.length - i - 1;
    return t__namespace.binaryExpression('<<', t__namespace.unaryExpression('!', t__namespace.unaryExpression('!', condition)), t__namespace.numericLiteral(shift));
  });
  return binaryExpressions.reduce((acc, expr) => {
    return t__namespace.binaryExpression('|', acc, expr);
  });
}

function skipStylexPropsChildren(path, state) {
  if (!isCalleeIdentifier(path, state) && !isCalleeMemberExpression(path, state)) {
    return;
  }
  path.skip();
}
function transformStylexProps(path, state) {
  const {
    node
  } = path;
  if (!isCalleeIdentifier(path, state) && !isCalleeMemberExpression(path, state)) {
    return;
  }
  let bailOut = false;
  let conditional = 0;
  const args = node.arguments.flatMap(arg => arg.type === 'ArrayExpression' ? arg.elements : [arg]);
  let currentIndex = -1;
  let bailOutIndex = null;
  const resolvedArgs = [];
  for (const arg of args) {
    currentIndex++;
    switch (arg.type) {
      case 'MemberExpression':
        {
          const resolved = parseNullableStyle(arg, state);
          if (resolved === 'other') {
            bailOutIndex = currentIndex;
            bailOut = true;
          } else {
            resolvedArgs.push(resolved);
          }
          break;
        }
      case 'ConditionalExpression':
        {
          const {
            test,
            consequent,
            alternate
          } = arg;
          const primary = parseNullableStyle(consequent, state);
          const fallback = parseNullableStyle(alternate, state);
          if (primary === 'other' || fallback === 'other') {
            bailOutIndex = currentIndex;
            bailOut = true;
          } else {
            resolvedArgs.push([test, primary, fallback]);
            conditional++;
          }
          break;
        }
      case 'LogicalExpression':
        {
          if (arg.operator !== '&&') {
            bailOutIndex = currentIndex;
            bailOut = true;
            break;
          }
          const {
            left,
            right
          } = arg;
          const leftResolved = parseNullableStyle(left, state);
          const rightResolved = parseNullableStyle(right, state);
          if (leftResolved !== 'other' || rightResolved === 'other') {
            bailOutIndex = currentIndex;
            bailOut = true;
          } else {
            resolvedArgs.push([left, rightResolved, null]);
            conditional++;
          }
          break;
        }
      default:
        bailOutIndex = currentIndex;
        bailOut = true;
        break;
    }
    if (conditional > 4) {
      bailOut = true;
    }
    if (bailOut) {
      break;
    }
  }
  if (!state.options.genConditionalClasses && conditional) {
    bailOut = true;
  }
  if (bailOut) {
    const argumentPaths = path.get('arguments');
    let nonNullProps = [];
    let index = -1;
    for (const argPath of argumentPaths) {
      index++;
      function MemberExpression(path) {
        const object = path.get('object').node;
        const property = path.get('property').node;
        const computed = path.node.computed;
        let objName = null;
        let propName = null;
        if (object.type === 'Identifier' && state.styleMap.has(object.name)) {
          objName = object.name;
          if (property.type === 'Identifier' && !computed) {
            propName = property.name;
          }
          if ((property.type === 'StringLiteral' || property.type === 'NumericLiteral') && computed) {
            propName = property.value;
          }
        }
        let styleNonNullProps = [];
        if (bailOutIndex != null && index > bailOutIndex) {
          nonNullProps = true;
          styleNonNullProps = true;
        }
        if (nonNullProps === true) {
          styleNonNullProps = true;
        } else {
          const {
            confident,
            value: styleValue
          } = evaluate(path, state);
          if (!confident) {
            nonNullProps = true;
            styleNonNullProps = true;
          } else {
            styleNonNullProps = nonNullProps === true ? true : [...nonNullProps];
            if (nonNullProps !== true) {
              nonNullProps = [...nonNullProps, ...Object.keys(styleValue).filter(key => styleValue[key] !== null)];
            }
          }
        }
        if (objName != null) {
          state.styleVarsToKeep.add([objName, propName != null ? String(propName) : true, styleNonNullProps]);
        }
      }
      if (isMemberExpression(argPath)) {
        MemberExpression(argPath);
      } else {
        argPath.traverse({
          MemberExpression
        });
      }
    }
  } else {
    path.skip();
    const stringExpression = makeStringExpression(resolvedArgs);
    path.replaceWith(stringExpression);
  }
}
function parseNullableStyle(node, state) {
  if (t__namespace.isNullLiteral(node) || t__namespace.isIdentifier(node) && node.name === 'undefined') {
    return null;
  }
  if (t__namespace.isMemberExpression(node)) {
    const {
      object,
      property,
      computed: computed
    } = node;
    let objName = null;
    let propName = null;
    if (object.type === 'Identifier' && state.styleMap.has(object.name) && property.type === 'Identifier' && !computed) {
      objName = object.name;
      propName = property.name;
    }
    if (object.type === 'Identifier' && state.styleMap.has(object.name) && (property.type === 'StringLiteral' || property.type === 'NumericLiteral') && computed) {
      objName = object.name;
      propName = property.value;
    }
    if (objName != null && propName != null) {
      const style = state.styleMap.get(objName);
      if (style != null && style[String(propName)] != null) {
        return style[String(propName)];
      }
    }
  }
  return 'other';
}
function makeStringExpression(values) {
  const conditions = values.filter(v => Array.isArray(v)).map(v => v[0]);
  if (conditions.length === 0) {
    const result = props_1(values);
    return convertObjectToAST(result);
  }
  const conditionPermutations = genConditionPermutations(conditions.length);
  const objEntries = conditionPermutations.map(permutation => {
    let i = 0;
    const args = values.map(v => {
      if (Array.isArray(v)) {
        const [_test, primary, fallback] = v;
        return permutation[i++] ? primary : fallback;
      } else {
        return v;
      }
    });
    const key = permutation.reduce((soFar, bool) => soFar << 1 | (bool ? 1 : 0), 0);
    return t__namespace.objectProperty(t__namespace.numericLiteral(key), convertObjectToAST(props_1(args)));
  });
  const objExpressions = t__namespace.objectExpression(objEntries);
  const conditionsToKey = genBitwiseOrOfConditions(conditions);
  return t__namespace.memberExpression(objExpressions, conditionsToKey, true);
}
function genConditionPermutations(count) {
  const result = [];
  for (let i = 0; i < 2 ** count; i++) {
    const combination = [];
    for (let j = 0; j < count; j++) {
      combination.push(Boolean(i & 1 << j));
    }
    result.push(combination);
  }
  return result;
}
function genBitwiseOrOfConditions(conditions) {
  const binaryExpressions = conditions.map((condition, i) => {
    const shift = conditions.length - i - 1;
    return t__namespace.binaryExpression('<<', t__namespace.unaryExpression('!', t__namespace.unaryExpression('!', condition)), t__namespace.numericLiteral(shift));
  });
  return binaryExpressions.reduce((acc, expr) => {
    return t__namespace.binaryExpression('|', acc, expr);
  });
}
function isCalleeIdentifier(path, state) {
  const {
    node
  } = path;
  return node != null && node.callee != null && node.callee.type === 'Identifier' && state.stylexPropsImport.has(node.callee.name);
}
function isCalleeMemberExpression(path, state) {
  const {
    node
  } = path;
  return node != null && node.callee != null && node.callee.type === 'MemberExpression' && node.callee.object.type === 'Identifier' && node.callee.property.type === 'Identifier' && node.callee.property.name === 'props' && state.stylexImport.has(node.callee.object.name);
}

const NAME = 'stylex';
function styleXTransform() {
  let state;
  return {
    name: NAME,
    visitor: {
      Program: {
        enter: (path, s) => {
          state = new StateManager(s);
          for (const block of path.get('body')) {
            if (isImportDeclaration(block)) {
              readImportDeclarations(block, state);
            }
            if (isVariableDeclaration(block)) {
              for (const decl of block.get('declarations')) {
                readRequires(decl, state);
              }
            }
          }
          path.traverse({
            CallExpression(path) {
              if (isVariableDeclarator(path.parentPath)) {
                transformStyleXKeyframes(path.parentPath, state);
              }
              transformStyleXDefineVars(path, state);
              transformStyleXCreateTheme(path, state);
              transformStyleXCreate(path, state);
            }
          });
        },
        exit: path => {
          path.traverse({
            CallExpression(path) {
              transformStyleXMerge(path, state);
              transformStylexProps(path, state);
            }
          });
          const varsToKeep = {};
          for (const [varName, namespaceName] of state.styleVarsToKeep) {
            if (varsToKeep[varName] === true) {
              continue;
            }
            if (varsToKeep[varName] == null) {
              varsToKeep[varName] = namespaceName === true ? true : [namespaceName];
            } else if (Array.isArray(varsToKeep[varName])) {
              if (namespaceName === true) {
                varsToKeep[varName] = true;
              } else {
                varsToKeep[varName].push(namespaceName);
              }
            }
          }
          const varsToKeepOld = new Set([...state.styleVarsToKeep.values()].map(_ref => {
            let [varName, _namespaceName] = _ref;
            return varName;
          }));
          state.styleVars.forEach((path, varName) => {
            if (isExported(path)) {
              return;
            }
            if (varsToKeep[varName] === true) {
              return;
            }
            const namespacesToKeep = varsToKeep[varName];
            if (namespacesToKeep == null) {
              path.remove();
              return;
            }
            if (isVariableDeclarator(path)) {
              const init = path.get('init');
              if (init != null && isObjectExpression(init)) {
                for (const prop of init.get('properties')) {
                  if (isObjectProperty(prop)) {
                    const key = prop.get('key').node;
                    const keyAsString = key.type === 'Identifier' ? key.name : key.type === 'StringLiteral' ? key.value : key.type === 'NumericLiteral' ? String(key.value) : null;
                    if (keyAsString != null) {
                      if (!namespacesToKeep.includes(keyAsString)) {
                        prop.remove();
                      } else {
                        const allNullsToKeep = [...state.styleVarsToKeep.values()].filter(_ref2 => {
                          let [v, namespaceName] = _ref2;
                          return v === varName && namespaceName === keyAsString;
                        }).map(_ref3 => {
                          let [_v, _namespaceName, nullPropsToKeep] = _ref3;
                          return nullPropsToKeep;
                        });
                        if (!allNullsToKeep.includes(true)) {
                          const nullsToKeep = new Set(allNullsToKeep.filter(x => x !== true).flat());
                          const styleObject = prop.get('value');
                          if (isObjectExpression(styleObject)) {
                            for (const styleProp of styleObject.get('properties')) {
                              if (isObjectProperty(styleProp) && isNullLiteral(styleProp.get('value'))) {
                                const styleKey = styleProp.get('key').node;
                                const styleKeyAsString = styleKey.type === 'Identifier' ? styleKey.name : styleKey.type === 'StringLiteral' ? styleKey.value : styleKey.type === 'NumericLiteral' ? String(styleKey.value) : null;
                                if (styleKeyAsString != null && !nullsToKeep.has(styleKeyAsString)) {
                                  styleProp.remove();
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
            if (!varsToKeepOld.has(varName) && !isExported(path)) {
              path.remove();
            }
          });
        }
      },
      CallExpression(path) {
        skipStylexMergeChildren(path, state);
        skipStylexPropsChildren(path, state);
      },
      Identifier(path) {
        if (isReferencedIdentifier(path)) {
          const {
            name
          } = path.node;
          if (state.styleMap.has(name)) {
            const parentPath = path.parentPath;
            if (isMemberExpression(parentPath)) {
              const {
                property,
                computed
              } = parentPath.node;
              if (property.type === 'Identifier' && !computed) {
                state.markComposedNamespace([name, property.name, true]);
              } else if (property.type === 'StringLiteral' && computed) {
                state.markComposedNamespace([name, property.value, true]);
              } else if (property.type === 'NumericLiteral' && computed) {
                state.markComposedNamespace([name, String(property.value), true]);
              } else {
                state.markComposedNamespace([name, true, true]);
              }
            } else {
              state.markComposedNamespace([name, true, true]);
            }
          }
        }
      }
    }
  };
}
function stylexPluginWithOptions(options) {
  return [styleXTransform, options];
}
styleXTransform.withOptions = stylexPluginWithOptions;
function isExported(path) {
  if (path == null || isProgram(path)) {
    return false;
  }
  if (isExportNamedDeclaration(path) || isExportDefaultDeclaration(path)) {
    return true;
  }
  return isExported(path.parentPath);
}
function processStylexRules(rules) {
  let useLayers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  if (rules.length === 0) {
    return '';
  }
  const sortedRules = rules.sort((_ref4, _ref5) => {
    let [_1, {
      ltr: rule1
    }, firstPriority] = _ref4;
    let [_2, {
      ltr: rule2
    }, secondPriority] = _ref5;
    const priorityComparison = firstPriority - secondPriority;
    if (priorityComparison !== 0) return priorityComparison;
    if (rule1.startsWith('@') && !rule2.startsWith('@')) {
      const query1 = rule1.slice(0, rule1.indexOf('{'));
      const query2 = rule2.slice(0, rule2.indexOf('{'));
      if (query1 !== query2) {
        return query1.localeCompare(query2);
      }
    }
    const property1 = rule1.slice(rule1.lastIndexOf('{'));
    const property2 = rule2.slice(rule2.lastIndexOf('{'));
    return property1.localeCompare(property2);
  });
  let lastKPri = -1;
  const grouped = sortedRules.reduce((acc, rule) => {
    const [_key, _value, priority] = rule;
    const priorityLevel = Math.floor(priority / 1000);
    if (priorityLevel === lastKPri) {
      const last = acc[acc.length - 1];
      last.push(rule);
      return acc;
    }
    lastKPri = priorityLevel;
    acc.push([rule]);
    return acc;
  }, []);
  const header = useLayers ? '\n@layer ' + grouped.map((_, index) => `priority${index + 1}`).join(', ') + ';\n' : '';
  const collectedCSS = grouped.map((group, index) => {
    const collectedCSS = Array.from(new Map(group.map(_ref6 => {
      let [a, b, _c] = _ref6;
      return [a, b];
    })).values()).flatMap(_ref7 => {
      let {
        ltr,
        rtl
      } = _ref7;
      let ltrRule = ltr,
        rtlRule = rtl;
      if (!useLayers) {
        ltrRule = addSpecificityLevel(ltrRule, index);
        rtlRule = rtlRule && addSpecificityLevel(rtlRule, index);
      }
      return rtlRule != null ? [addAncestorSelector(ltrRule, "html:not([dir='rtl'])"), addAncestorSelector(rtlRule, "html[dir='rtl']")] : [ltrRule];
    }).join('\n');
    return useLayers ? `@layer priority${index + 1}{\n${collectedCSS}\n}` : collectedCSS;
  }).join('\n');
  return header + collectedCSS;
}
styleXTransform.processStylexRules = processStylexRules;
function addAncestorSelector(selector, ancestorSelector) {
  if (selector.startsWith('@keyframes')) {
    return selector;
  }
  if (!selector.startsWith('@')) {
    return `${ancestorSelector} ${selector}`;
  }
  const lastAtRule = selector.lastIndexOf('@');
  const atRuleBracketIndex = selector.indexOf('{', lastAtRule);
  const mediaQueryPart = selector.slice(0, atRuleBracketIndex + 1);
  const rest = selector.slice(atRuleBracketIndex + 1);
  return `${mediaQueryPart}${ancestorSelector} ${rest}`;
}
function addSpecificityLevel(selector, index) {
  if (selector.startsWith('@keyframes')) {
    return selector;
  }
  const pseudo = Array.from({
    length: index
  }).map(() => ':not(#\\#)').join('');
  const lastOpenCurly = selector.includes('::') ? selector.indexOf('::') : selector.lastIndexOf('{');
  const beforeCurly = selector.slice(0, lastOpenCurly);
  const afterCurly = selector.slice(lastOpenCurly);
  return `${beforeCurly}${pseudo}${afterCurly}`;
}

module.exports = styleXTransform;
