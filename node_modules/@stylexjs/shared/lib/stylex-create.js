"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = styleXCreateSet;
var _objectUtils = require("./utils/object-utils");
var _stylexInclude = require("./stylex-include");
var _defaultOptions = require("./utils/default-options");
var _flattenRawStyleObj = require("./preprocess-rules/flatten-raw-style-obj");
var _basicValidation = require("./preprocess-rules/basic-validation");
function styleXCreateSet(namespaces) {
  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _defaultOptions.defaultOptions;
  const resolvedNamespaces = {};
  const injectedStyles = {};
  for (const namespaceName of Object.keys(namespaces)) {
    const namespace = namespaces[namespaceName];
    (0, _basicValidation.validateNamespace)(namespace);
    const flattenedNamespace = (0, _flattenRawStyleObj.flattenRawStyleObject)(namespace, options);
    const compiledNamespaceTuples = flattenedNamespace.map(_ref => {
      let [key, value] = _ref;
      return [key, value.compiled(options)];
    });
    const compiledNamespace = (0, _objectUtils.objFromEntries)(compiledNamespaceTuples);
    const namespaceObj = {};
    for (const key of Object.keys(compiledNamespace)) {
      const value = compiledNamespace[key];
      if (value instanceof _stylexInclude.IncludedStyles) {
        namespaceObj[key] = value;
      } else {
        const classNameTuples = value.map(v => Array.isArray(v) ? v : null).filter(Boolean);
        const className = classNameTuples.map(_ref2 => {
          let [className] = _ref2;
          return className;
        }).join(' ') || null;
        namespaceObj[key] = className;
        for (const [className, injectable] of classNameTuples) {
          if (injectedStyles[className] == null) {
            injectedStyles[className] = injectable;
          }
        }
      }
    }
    resolvedNamespaces[namespaceName] = {
      ...namespaceObj,
      $$css: true
    };
  }
  return [resolvedNamespaces, injectedStyles];
}