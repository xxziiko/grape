'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.__monkey_patch__ = __monkey_patch__;
exports.attrs = attrs;
exports.legacyMerge = exports.keyframes = exports.include = exports.firstThatWorks = exports.defineVars = exports.default = exports.createTheme = exports.create = void 0;
exports.props = props;
exports.types = void 0;
var _styleq = require("styleq");
const errorForFn = name => new Error(`'stylex.${name}' should never be called at runtime. It should be compiled away by '@stylexjs/babel-plugin'`);
const errorForType = key => errorForFn(`types.${key}`);
function props() {
  const options = this;
  for (var _len = arguments.length, styles = new Array(_len), _key = 0; _key < _len; _key++) {
    styles[_key] = arguments[_key];
  }
  if (__implementations.props) {
    return __implementations.props.call(options, styles);
  }
  const [className, style] = (0, _styleq.styleq)(styles);
  const result = {};
  if (className != null && className !== '') {
    result.className = className;
  }
  if (style != null && Object.keys(style).length > 0) {
    result.style = style;
  }
  return result;
}
function attrs() {
  const {
    className,
    style
  } = props(...arguments);
  const result = {};
  if (className != null && className !== '') {
    result.class = className;
  }
  if (style != null && Object.keys(style).length > 0) {
    result.style = Object.keys(style).map(key => `${key}:${style[key]};`).join('');
  }
  return result;
}
function stylexCreate(styles) {
  if (__implementations.create != null) {
    const create = __implementations.create;
    return create(styles);
  }
  throw errorForFn('create');
}
function stylexDefineVars(styles) {
  if (__implementations.defineVars) {
    return __implementations.defineVars(styles);
  }
  throw errorForFn('defineVars');
}
const stylexCreateTheme = (baseTokens, overrides) => {
  if (__implementations.createTheme) {
    return __implementations.createTheme(baseTokens, overrides);
  }
  throw errorForFn('createTheme');
};
const stylexInclude = styles => {
  if (__implementations.include) {
    return __implementations.include(styles);
  }
  throw errorForFn('include');
};
const create = exports.create = stylexCreate;
const defineVars = exports.defineVars = stylexDefineVars;
const createTheme = exports.createTheme = stylexCreateTheme;
const include = exports.include = stylexInclude;
const types = exports.types = {
  angle: _v => {
    throw errorForType('angle');
  },
  color: _v => {
    throw errorForType('color');
  },
  url: _v => {
    throw errorForType('url');
  },
  image: _v => {
    throw errorForType('image');
  },
  integer: _v => {
    throw errorForType('integer');
  },
  lengthPercentage: _v => {
    throw errorForType('lengthPercentage');
  },
  length: _v => {
    throw errorForType('length');
  },
  percentage: _v => {
    throw errorForType('percentage');
  },
  number: _v => {
    throw errorForType('number');
  },
  resolution: _v => {
    throw errorForType('resolution');
  },
  time: _v => {
    throw errorForType('time');
  },
  transformFunction: _v => {
    throw errorForType('transformFunction');
  },
  transformList: _v => {
    throw errorForType('transformList');
  }
};
const keyframes = keyframes => {
  if (__implementations.keyframes) {
    return __implementations.keyframes(keyframes);
  }
  throw errorForFn('keyframes');
};
exports.keyframes = keyframes;
const firstThatWorks = function () {
  if (__implementations.firstThatWorks) {
    return __implementations.firstThatWorks(...arguments);
  }
  throw errorForFn('firstThatWorks');
};
exports.firstThatWorks = firstThatWorks;
function _stylex() {
  for (var _len2 = arguments.length, styles = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    styles[_key2] = arguments[_key2];
  }
  const [className] = (0, _styleq.styleq)(styles);
  return className;
}
_stylex.props = props;
_stylex.attrs = attrs;
_stylex.create = create;
_stylex.defineVars = defineVars;
_stylex.createTheme = createTheme;
_stylex.include = include;
_stylex.keyframes = keyframes;
_stylex.firstThatWorks = firstThatWorks;
_stylex.types = types;
const __implementations = {};
function __monkey_patch__(key, implementation) {
  if (key === 'types') {
    Object.assign(types, implementation);
  } else {
    __implementations[key] = implementation;
  }
}
const legacyMerge = exports.legacyMerge = _stylex;
var _default = exports.default = _stylex;