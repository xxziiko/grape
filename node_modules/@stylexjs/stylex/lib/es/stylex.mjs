var styleq$1 = {};

/**
 * Copyright (c) Nicolas Gallagher
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

Object.defineProperty(styleq$1, "__esModule", {
  value: true
});
var styleq_2 = styleq$1.styleq = void 0;
var cache = new WeakMap();
var compiledKey = '$$css';

function createStyleq(options) {
  var disableCache;
  var disableMix;
  var transform;

  if (options != null) {
    disableCache = options.disableCache === true;
    disableMix = options.disableMix === true;
    transform = options.transform;
  }

  return function styleq() {
    // Keep track of property commits to the className
    var definedProperties = []; // The className and inline style to build up

    var className = '';
    var inlineStyle = null; // The current position in the cache graph

    var nextCache = disableCache ? null : cache; // This way of creating an array from arguments is fastest

    var styles = new Array(arguments.length);

    for (var i = 0; i < arguments.length; i++) {
      styles[i] = arguments[i];
    } // Iterate over styles from last to first


    while (styles.length > 0) {
      var possibleStyle = styles.pop(); // Skip empty items

      if (possibleStyle == null || possibleStyle === false) {
        continue;
      } // Push nested styles back onto the stack to be processed


      if (Array.isArray(possibleStyle)) {
        for (var _i = 0; _i < possibleStyle.length; _i++) {
          styles.push(possibleStyle[_i]);
        }

        continue;
      } // Process an individual style object


      var style = transform != null ? transform(possibleStyle) : possibleStyle;

      if (style.$$css) {
        // Build up the class names defined by this object
        var classNameChunk = ''; // Check the cache to see if we've already done this work

        if (nextCache != null && nextCache.has(style)) {
          // Cache: read
          var cacheEntry = nextCache.get(style);

          if (cacheEntry != null) {
            classNameChunk = cacheEntry[0]; // $FlowIgnore

            definedProperties.push.apply(definedProperties, cacheEntry[1]);
            nextCache = cacheEntry[2];
          }
        } // Update the chunks with data from this object
        else {
          // The properties defined by this object
          var definedPropertiesChunk = [];

          for (var prop in style) {
            var value = style[prop];
            if (prop === compiledKey) continue; // Each property value is used as an HTML class name
            // { 'debug.string': 'debug.string', opacity: 's-jskmnoqp' }

            if (typeof value === 'string' || value === null) {
              // Only add to chunks if this property hasn't already been seen
              if (!definedProperties.includes(prop)) {
                definedProperties.push(prop);

                if (nextCache != null) {
                  definedPropertiesChunk.push(prop);
                }

                if (typeof value === 'string') {
                  classNameChunk += classNameChunk ? ' ' + value : value;
                }
              }
            } // If we encounter a value that isn't a string or `null`
            else {
              console.error("styleq: ".concat(prop, " typeof ").concat(String(value), " is not \"string\" or \"null\"."));
            }
          } // Cache: write


          if (nextCache != null) {
            // Create the next WeakMap for this sequence of styles
            var weakMap = new WeakMap();
            nextCache.set(style, [classNameChunk, definedPropertiesChunk, weakMap]);
            nextCache = weakMap;
          }
        } // Order of classes in chunks matches property-iteration order of style
        // object. Order of chunks matches passed order of styles from first to
        // last (which we iterate over in reverse).


        if (classNameChunk) {
          className = className ? classNameChunk + ' ' + className : classNameChunk;
        }
      } // ----- DYNAMIC: Process inline style object -----
      else {
        if (disableMix) {
          if (inlineStyle == null) {
            inlineStyle = {};
          }

          inlineStyle = Object.assign({}, style, inlineStyle);
        } else {
          var subStyle = null;

          for (var _prop in style) {
            var _value = style[_prop];

            if (_value !== undefined) {
              if (!definedProperties.includes(_prop)) {
                if (_value != null) {
                  if (inlineStyle == null) {
                    inlineStyle = {};
                  }

                  if (subStyle == null) {
                    subStyle = {};
                  }

                  subStyle[_prop] = _value;
                }

                definedProperties.push(_prop); // Cache is unnecessary overhead if results can't be reused.

                nextCache = null;
              }
            }
          }

          if (subStyle != null) {
            inlineStyle = Object.assign(subStyle, inlineStyle);
          }
        }
      }
    }

    var styleProps = [className, inlineStyle];
    return styleProps;
  };
}

var styleq = createStyleq();
styleq_2 = styleq$1.styleq = styleq;
styleq.factory = createStyleq;

const errorForFn = name => new Error(`'stylex.${name}' should never be called at runtime. It should be compiled away by '@stylexjs/babel-plugin'`);
const errorForType = key => errorForFn(`types.${key}`);
function props() {
  const options = this;
  for (var _len = arguments.length, styles = new Array(_len), _key = 0; _key < _len; _key++) {
    styles[_key] = arguments[_key];
  }
  if (__implementations.props) {
    return __implementations.props.call(options, styles);
  }
  const [className, style] = styleq_2(styles);
  const result = {};
  if (className != null && className !== '') {
    result.className = className;
  }
  if (style != null && Object.keys(style).length > 0) {
    result.style = style;
  }
  return result;
}
function attrs() {
  const {
    className,
    style
  } = props(...arguments);
  const result = {};
  if (className != null && className !== '') {
    result.class = className;
  }
  if (style != null && Object.keys(style).length > 0) {
    result.style = Object.keys(style).map(key => `${key}:${style[key]};`).join('');
  }
  return result;
}
function stylexCreate(styles) {
  if (__implementations.create != null) {
    const create = __implementations.create;
    return create(styles);
  }
  throw errorForFn('create');
}
function stylexDefineVars(styles) {
  if (__implementations.defineVars) {
    return __implementations.defineVars(styles);
  }
  throw errorForFn('defineVars');
}
const stylexCreateTheme = (baseTokens, overrides) => {
  if (__implementations.createTheme) {
    return __implementations.createTheme(baseTokens, overrides);
  }
  throw errorForFn('createTheme');
};
const stylexInclude = styles => {
  if (__implementations.include) {
    return __implementations.include(styles);
  }
  throw errorForFn('include');
};
const create = stylexCreate;
const defineVars = stylexDefineVars;
const createTheme = stylexCreateTheme;
const include = stylexInclude;
const types = {
  angle: _v => {
    throw errorForType('angle');
  },
  color: _v => {
    throw errorForType('color');
  },
  url: _v => {
    throw errorForType('url');
  },
  image: _v => {
    throw errorForType('image');
  },
  integer: _v => {
    throw errorForType('integer');
  },
  lengthPercentage: _v => {
    throw errorForType('lengthPercentage');
  },
  length: _v => {
    throw errorForType('length');
  },
  percentage: _v => {
    throw errorForType('percentage');
  },
  number: _v => {
    throw errorForType('number');
  },
  resolution: _v => {
    throw errorForType('resolution');
  },
  time: _v => {
    throw errorForType('time');
  },
  transformFunction: _v => {
    throw errorForType('transformFunction');
  },
  transformList: _v => {
    throw errorForType('transformList');
  }
};
const keyframes = keyframes => {
  if (__implementations.keyframes) {
    return __implementations.keyframes(keyframes);
  }
  throw errorForFn('keyframes');
};
const firstThatWorks = function () {
  if (__implementations.firstThatWorks) {
    return __implementations.firstThatWorks(...arguments);
  }
  throw errorForFn('firstThatWorks');
};
function _stylex() {
  for (var _len2 = arguments.length, styles = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    styles[_key2] = arguments[_key2];
  }
  const [className] = styleq_2(styles);
  return className;
}
_stylex.props = props;
_stylex.attrs = attrs;
_stylex.create = create;
_stylex.defineVars = defineVars;
_stylex.createTheme = createTheme;
_stylex.include = include;
_stylex.keyframes = keyframes;
_stylex.firstThatWorks = firstThatWorks;
_stylex.types = types;
const __implementations = {};
function __monkey_patch__(key, implementation) {
  if (key === 'types') {
    Object.assign(types, implementation);
  } else {
    __implementations[key] = implementation;
  }
}
const legacyMerge = _stylex;

export { __monkey_patch__, attrs, create, createTheme, _stylex as default, defineVars, firstThatWorks, include, keyframes, legacyMerge, props, types };
