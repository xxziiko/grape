'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
exports.isMathCall = isMathCall;
var _makeVariableCheckingRule = _interopRequireDefault(require("../utils/makeVariableCheckingRule"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const numericOperators = new Set(['+', '-', '*', '/']);
const isNumber = (0, _makeVariableCheckingRule.default)((node, variables) => node.type === 'Literal' && typeof node.value === 'number' || node.type === 'BinaryExpression' && numericOperators.has(node.operator) && isNumber(node.left, variables) && isNumber(node.right, variables) || node.type === 'UnaryExpression' && node.operator === '-' && isNumber(node.argument, variables) || isMathCall(node, variables) ? undefined : {
  message: 'a number literal or math expression'
});
function isMathCall(node, variables) {
  return node.type === 'CallExpression' && node.callee.type === 'MemberExpression' && node.callee.object.type === 'Identifier' && node.callee.object.name === 'Math' && node.callee.property.type === 'Identifier' && ['abs', 'ceil', 'floor', 'round'].includes(node.callee.property.name) && node.arguments.every(arg => (arg.type === 'Literal' || arg.type === 'UnaryExpression' || arg.type === 'BinaryExpression') && isNumber(arg, variables)) ? undefined : {
    message: 'a math expression'
  };
}
var _default = exports.default = isNumber;