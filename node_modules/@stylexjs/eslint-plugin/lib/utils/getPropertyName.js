'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getPropertyName;
function isNullLiteral(node) {
  return node.type === 'Literal' && node.value === null && !node.regex && !node.bigint;
}
function getStaticStringValue(node) {
  switch (node.type) {
    case 'Literal':
      if (node.value === null) {
        if (isNullLiteral(node)) {
          return String(node.value);
        }
        if (node.regex) {
          return `/${node.regex.pattern}/${node.regex.flags}`;
        }
        if (node.bigint) {
          return node.bigint;
        }
      } else {
        return String(node.value);
      }
      break;
    case 'TemplateLiteral':
      if (node.expressions.length === 0 && node.quasis.length === 1) {
        return node.quasis[0].value.cooked || null;
      }
      break;
  }
  return null;
}
function getStaticPropertyName(node) {
  let prop;
  if (node.type === 'ChainExpression' && node.expression) {
    return getStaticPropertyName(node.expression);
  }
  switch (node && node.type) {
    case 'Property':
    case 'PropertyDefinition':
    case 'MethodDefinition':
      prop = node.key;
      break;
    case 'MemberExpression':
      prop = node.property;
      break;
  }
  if (prop) {
    if (prop.type === 'Identifier' && !node.computed) {
      return prop.name;
    }
    return getStaticStringValue(prop);
  }
  return null;
}
function getPropertyName(node) {
  const staticName = getStaticPropertyName(node);
  return staticName !== null ? staticName : node.key.name || null;
}