'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _getPropertyName = _interopRequireDefault(require("./utils/getPropertyName"));
var _getPropertyPriorityAndType = _interopRequireDefault(require("./utils/getPropertyPriorityAndType"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function isValidOrder(prevName, currName) {
  const prev = (0, _getPropertyPriorityAndType.default)(prevName);
  const curr = (0, _getPropertyPriorityAndType.default)(currName);
  if (prev.type !== 'string' || curr.type !== 'string') {
    return prev.priority <= curr.priority;
  }
  return prevName <= currName;
}
const stylexSortKeys = {
  meta: {
    type: 'suggestion',
    docs: {
      description: 'Require style properties to be sorted by key',
      recommended: false,
      url: 'https://github.com/facebook/stylex/tree/main/packages/eslint-plugin'
    },
    fixable: 'code',
    schema: [{
      type: 'object',
      properties: {
        validImports: {
          type: 'array',
          items: {
            type: 'string'
          },
          default: ['stylex', '@stylexjs/stylex']
        },
        minKeys: {
          type: 'integer',
          minimum: 2,
          default: 2
        },
        allowLineSeparatedGroups: {
          type: 'boolean',
          default: false
        }
      },
      additionalProperties: false
    }]
  },
  create(context) {
    const {
      validImports: importsToLookFor = ['stylex', '@stylexjs/stylex'],
      minKeys = 2,
      allowLineSeparatedGroups = false
    } = context.options[0] || {};
    const styleXDefaultImports = new Set();
    const styleXCreateImports = new Set();
    const styleXKeyframesImports = new Set();
    function isStylexCallee(node) {
      return node.type === 'MemberExpression' && node.object.type === 'Identifier' && styleXDefaultImports.has(node.object.name) && node.property.type === 'Identifier' && (node.property.name === 'create' || node.property.name === 'keyframes') || node.type === 'Identifier' && (styleXCreateImports.has(node.name) || styleXKeyframesImports.has(node.name));
    }
    function isStylexDeclaration(node) {
      return node && node.type === 'CallExpression' && isStylexCallee(node.callee) && node.arguments.length === 1;
    }
    let stack = null;
    let isInsideStyleXCreateCall = false;
    let objectExpressionNestingLevel = -1;
    return {
      ImportDeclaration(node) {
        if (node.source.type !== 'Literal' || typeof node.source.value !== 'string') {
          return;
        }
        if (!importsToLookFor.includes(node.source.value)) {
          return;
        }
        node.specifiers.forEach(specifier => {
          if (specifier.type === 'ImportDefaultSpecifier' || specifier.type === 'ImportNamespaceSpecifier') {
            styleXDefaultImports.add(specifier.local.name);
          }
          if (specifier.type === 'ImportSpecifier' && specifier.imported.name === 'create') {
            styleXCreateImports.add(specifier.local.name);
          }
          if (specifier.type === 'ImportSpecifier' && specifier.imported.name === 'keyframes') {
            styleXKeyframesImports.add(specifier.local.name);
          }
        });
      },
      CallExpression(node) {
        if (!isStylexDeclaration(node) || !node.arguments[0].properties || node.arguments[0].properties.length === 0) {
          return;
        }
        isInsideStyleXCreateCall = true;
      },
      ObjectExpression(node) {
        if (isInsideStyleXCreateCall) {
          objectExpressionNestingLevel++;
        }
        if (objectExpressionNestingLevel > 0) {
          stack = {
            upper: stack,
            prevNode: null,
            prevName: null,
            prevBlankLine: false,
            numKeys: node.properties.length
          };
        }
      },
      'ObjectExpression:exit'() {
        if (isInsideStyleXCreateCall && objectExpressionNestingLevel > 0 && stack) {
          stack = stack.upper;
        }
        if (isInsideStyleXCreateCall) {
          objectExpressionNestingLevel--;
        }
      },
      SpreadElement(node) {
        if (isInsideStyleXCreateCall && objectExpressionNestingLevel > 0 && node.parent.type === 'ObjectExpression' && stack) {
          stack.prevName = null;
        }
      },
      Property(node) {
        if (!isInsideStyleXCreateCall || objectExpressionNestingLevel < 1 || node.parent.type === 'ObjectPattern' || stack === null) {
          return;
        }
        const sourceCode = context.sourceCode;
        const prevName = stack.prevName;
        const prevNode = stack?.prevNode;
        const numKeys = stack.numKeys;
        const currName = (0, _getPropertyName.default)(node);
        let isBlankLineBetweenNodes = stack?.prevBlankLine;
        const tokens = stack?.prevNode && sourceCode.getTokensBetween(stack.prevNode, node, {
          includeComments: true
        });
        if (tokens && tokens.length > 0) {
          tokens.forEach((token, index) => {
            const previousToken = tokens[index - 1];
            if (previousToken && token.loc && previousToken.loc && token.loc.start.line - previousToken.loc.end.line > 1) {
              isBlankLineBetweenNodes = true;
            }
          });
          if (!isBlankLineBetweenNodes && (node.loc?.start?.line ?? 0) - (tokens.at(-1)?.loc?.end.line ?? 0) > 1) {
            isBlankLineBetweenNodes = true;
          }
          if (!isBlankLineBetweenNodes && tokens[0].loc && stack?.prevNode?.loc && tokens[0].loc.start.line - stack?.prevNode?.loc?.end.line > 1) {
            isBlankLineBetweenNodes = true;
          }
        }
        if (stack) {
          stack.prevNode = node;
        }
        if (currName !== null && stack) {
          stack.prevName = currName;
        }
        if (allowLineSeparatedGroups && isBlankLineBetweenNodes && stack) {
          stack.prevBlankLine = currName === null;
          return;
        }
        if (prevName === null || currName === null || numKeys < minKeys) {
          return;
        }
        if (!isValidOrder(prevName, currName)) {
          context.report({
            node,
            loc: node.key.loc,
            message: `StyleX property key "${currName}" should be above "${prevName}"`,
            fix: createFix({
              prevNode,
              currNode: node,
              sourceCode
            })
          });
        }
      },
      'CallExpression:exit'() {
        if (isInsideStyleXCreateCall) {
          isInsideStyleXCreateCall = false;
        }
      },
      'Program:exit'() {
        styleXCreateImports.clear();
        styleXDefaultImports.clear();
        styleXKeyframesImports.clear();
      }
    };
  }
};
function createFix(_ref) {
  let {
    currNode,
    prevNode,
    sourceCode
  } = _ref;
  return function (fixer) {
    const fixes = [];
    const prevNodeCommentsBefore = getPropertyCommentsBefore(prevNode);
    const prevNodeContextStartNode = prevNodeCommentsBefore.length > 0 ? prevNodeCommentsBefore[0] : prevNode;
    const {
      indentation: startNodeIndentation,
      isTokenBeforeSameLineAsNode
    } = getNodeIndentation(prevNodeContextStartNode);
    const prevNodeSameLineComment = getPropertySameLineComment(prevNode);
    const tokenAfterPrevNode = sourceCode.getTokenAfter(prevNode, {
      includeComments: false
    });
    const prevNodeContextEndNode = prevNodeSameLineComment ?? tokenAfterPrevNode;
    if (!prevNodeContextEndNode?.range || !prevNodeContextStartNode.range) {
      return [];
    }
    const rangeStart = prevNodeContextStartNode.range[0] - startNodeIndentation.length;
    const rangeEnd = prevNodeContextEndNode.range[1];
    const textToMove = sourceCode.getText().slice(rangeStart, rangeEnd);
    fixes.push(fixer.removeRange([rangeStart - Number(!isTokenBeforeSameLineAsNode), rangeEnd]));
    const currNodeSameLineComment = getPropertySameLineComment(currNode);
    const tokenAfterCurrNode = sourceCode.getTokenAfter(currNode, {
      includeComments: false
    });
    const hasCommaAfterCurrNode = tokenAfterCurrNode && isCommaToken(tokenAfterCurrNode);
    if (!hasCommaAfterCurrNode) {
      fixes.push(fixer.insertTextAfter(currNode, ','));
    }
    const newLine = isSameLine(prevNode, currNode) ? '' : '\n';
    const fallbackNode = hasCommaAfterCurrNode && tokenAfterCurrNode ? tokenAfterCurrNode : currNode;
    fixes.push(fixer.insertTextAfter(currNodeSameLineComment ?? fallbackNode, `${newLine}${textToMove}`));
    return fixes;
  };
  function getEmptyLineCountBetweenNodes(aNode, bNode) {
    const [upperNode, lowerNode] = [aNode, bNode].sort((a, b) => (a.loc?.start.line ?? 0) - (b.loc?.start.line ?? 0));
    const upperNodeLine = upperNode.loc?.start.line;
    const lowerNodeLine = lowerNode.loc?.start.line;
    if (upperNodeLine === undefined || lowerNodeLine === undefined) {
      throw new Error('Invalid node location');
    }
    return sourceCode.lines.slice(upperNodeLine, lowerNodeLine - 1).filter(line => /^[ \t]*$/.test(line)).length;
  }
  function getPropertyCommentsBefore(node) {
    return sourceCode.getCommentsBefore(node).filter(comment => {
      const tokenBefore = sourceCode.getTokenBefore(comment, {
        includeComments: false
      });
      if (tokenBefore === null) {
        return true;
      }
      return !isSameLine(tokenBefore, comment) && getEmptyLineCountBetweenNodes(node, comment) === 0;
    });
  }
  function getPropertySameLineComment(node) {
    const tokenAfter = sourceCode.getTokenAfter(node, {
      includeComments: false
    });
    const comments = sourceCode.getCommentsAfter(tokenAfter && isCommaToken(tokenAfter) ? tokenAfter : node).filter(comment => isSameLine(node, comment));
    return comments[0];
  }
  function getNodeIndentation(node) {
    const tokenBefore = sourceCode.getTokenBefore(node, {
      includeComments: false
    });
    const isTokenBeforeSameLineAsNode = !!tokenBefore && isSameLine(tokenBefore, node);
    const sliceStart = isTokenBeforeSameLineAsNode && tokenBefore?.loc ? tokenBefore.loc.end.column : 0;
    return {
      isTokenBeforeSameLineAsNode,
      indentation: node?.loc ? sourceCode.lines[node.loc.start.line - 1].slice(sliceStart, node.loc.start.column) : ''
    };
  }
}
function isSameLine(aNode, bNode) {
  return Boolean(aNode.loc && bNode.loc && aNode.loc?.start.line === bNode.loc?.start.line);
}
function isCommaToken(token) {
  return token.type === 'Punctuator' && token.value === ',';
}
var _default = exports.default = stylexSortKeys;